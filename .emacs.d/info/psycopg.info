This is psycopg.info, produced by makeinfo version 7.2 from
psycopg.texi.

     psycopg 3.2.12, Nov 16, 2025

     Daniele Varrazzo

     Copyright © 2020, Daniele Varrazzo and The Psycopg Team

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* psycopg: (psycopg.info). One line description of project
END-INFO-DIR-ENTRY


   Generated by Sphinx 8.1.3.


File: psycopg.info,  Node: Top,  Next: Documentation,  Up: (dir)

psycopg
*******

     psycopg 3.2.12, Nov 16, 2025

     Daniele Varrazzo

     Copyright © 2020, Daniele Varrazzo and The Psycopg Team

Psycopg 3 is a newly designed PostgreSQL(1) database adapter for the
Python(2) programming language.

Psycopg 3 presents a familiar interface for everyone who has used
Psycopg 2(3) or any other DB-API 2.0(4) database adapter, but allows to
use more modern PostgreSQL and Python features, such as:

   - *note Asynchronous support: d.

   - *note COPY support from Python objects: e.

   - *note A redesigned connection pool: f.

   - *note Support for static typing: 10.

   - *note Server-side parameters binding: 11.

   - *note Prepared statements: 12.

   - *note Statements pipeline: 13.

   - *note Binary communication: 14.

   - *note Direct access to the libpq functionalities: 15.

* Menu:

* Documentation::
* Python Module Index::
* Index::

 -- The Detailed Node Listing --

Documentation

* Getting started with Psycopg 3::
* More advanced topics::
* Psycopg 3 API::
* Release notes::
* Indices and tables::

Getting started with Psycopg 3

* Installation::
* Basic module usage::
* Passing parameters to SQL queries::
* Adapting basic Python types::
* Adapting other PostgreSQL types::
* Transactions management::
* Using COPY TO and COPY FROM::
* Differences from psycopg2::

Installation

* Supported systems::
* Binary installation::
* Local installation::
* Pure Python installation::
* Installing the connection pool::
* Handling dependencies::

Basic module usage

* Main objects in Psycopg 3::
* Shortcuts::
* Connection context::
* Adapting psycopg to your program::
* Connection logging::

Passing parameters to SQL queries

* execute() arguments: execute arguments.
* Danger; SQL injection: Danger SQL injection.
* Binary parameters and results::

Adapting basic Python types

* Booleans adaptation::
* Numbers adaptation::
* Strings adaptation::
* Binary adaptation::
* Date/time types adaptation::
* JSON adaptation::
* Lists adaptation::
* UUID adaptation::
* Network data types adaptation::
* Enum adaptation::

Date/time types adaptation

* Dates and times limits in Python::
* DateStyle and IntervalStyle limits::

Adapting other PostgreSQL types

* Composite types casting::
* Range adaptation::
* Multirange adaptation::
* Hstore adaptation::
* Geometry adaptation using Shapely::

Transactions management

* Autocommit transactions::
* Transaction contexts::
* Transaction characteristics::
* Two-Phase Commit protocol support::

Transaction contexts

* Nested transactions::

Using COPY TO and COPY FROM

* Writing data row-by-row::
* Reading data row-by-row::
* Copying block-by-block::
* Binary copy::
* Asynchronous copy support::
* Example; copying a table across servers: Example copying a table across servers.

Differences from psycopg2

* Server-side binding::
* Extended query Protocol::
* Multiple statements in the same query::
* Multiple results returned from multiple statements::
* Different cast rules::
* You cannot use IN %s with a tuple::
* You cannot use IS %s::
* Cursors subclasses::
* Different adaptation system::
* Copy is no longer file-based::
* with connection::
* callproc() is gone: callproc is gone.
* client_encoding is gone::
* Transaction characteristics attributes don’t affect autocommit sessions::
* No default infinity dates handling::
* What’s new in Psycopg 3::

More advanced topics

* Concurrent operations::
* Static Typing::
* Row factories::
* Connection pools::
* Cursor types::
* Data adaptation configuration::
* Prepared statements::
* Pipeline mode support::

Concurrent operations

* Asynchronous operations::
* with async connections::
* Interrupting async operations::
* Gevent support::
* Server messages::
* Asynchronous notifications::
* Detecting disconnections::

Asynchronous notifications

* Notifies generator::
* Notifies handlers::

Static Typing

* Generic types::
* Type of rows returned::
* Generic pool types::
* Example; returning records as Pydantic models: Example returning records as Pydantic models.
* Checking literal strings in queries::

Row factories

* Creating new row factories::

Connection pools

* Basic connection pool usage::
* Pool startup check::
* Connections life cycle::
* Other ways to create a pool::
* Null connection pools::
* Pool connection and sizing::
* Connection quality::
* Pool operations logging::
* Pool stats::

Pool connection and sizing

* What’s the right size for the pool?::

Cursor types

* Client-side cursors::
* Client-side-binding cursors::
* Server-side cursors::
* Raw query cursors::

Client-side-binding cursors

* Simple query protocol::

Server-side cursors

* “Stealing” an existing cursor::

Data adaptation configuration

* Writing a custom adapter; XML: Writing a custom adapter XML.
* Example; converting empty strings to NULL: Example converting empty strings to NULL.
* Example; PostgreSQL numeric to Python float: Example PostgreSQL numeric to Python float.
* Example; handling infinity date: Example handling infinity date.
* Dumpers and loaders life cycle::

Prepared statements

* Using prepared statements with PgBouncer::

Pipeline mode support

* Client-server messages flow::
* Pipeline mode usage::
* Synchronization points::
* The fine prints::

Psycopg 3 API

* The psycopg module::
* Connection classes::
* Cursor classes::
* COPY-related objects::
* Other top-level objects::
* sql – SQL string composition::
* rows – row factory implementations::
* errors – Package exceptions::
* psycopg_pool – Connection pool implementations::
* conninfo – manipulate connection strings::
* adapt – Types adaptation::
* types – Types information and adapters::
* abc – Psycopg abstract classes::
* pq – libpq wrapper module::
* crdb – CockroachDB support::
* _dns – DNS resolution utilities::

Connection classes

* The Connection class::
* The AsyncConnection class::

Cursor classes

* The Cursor class::
* The ClientCursor class::
* The ServerCursor class::
* The RawCursor and RawServerCursor class::
* Async cursor classes::

COPY-related objects

* Main Copy objects::
* Writer objects::

Other top-level objects

* Connection information::
* Libpq capabilities information::
* The description Column object::
* Notifications::
* Pipeline-related objects::
* Transaction-related objects::
* Two-Phase Commit related objects::

sql – SQL string composition

* Module usage::
* sql objects::
* Utility functions::

rows – row factory implementations

* Formal rows protocols::

errors – Package exceptions

* DB-API exceptions::
* Error diagnostics::
* SQLSTATE exceptions::

DB-API exceptions

* Other Psycopg errors::

SQLSTATE exceptions

* List of known exceptions::

psycopg_pool – Connection pool implementations

* The ConnectionPool class::
* Pool exceptions::
* The AsyncConnectionPool class::
* Null connection pools: Null connection pools<2>.

adapt – Types adaptation

* Dumpers and loaders::
* Other objects used in adaptations::

types – Types information and adapters

* Types information::
* JSON adapters::

pq – libpq wrapper module

* pq module implementations::
* Module content::
* Objects wrapping libpq structures and functions::
* Enumerations::

crdb – CockroachDB support

* Main differences from PostgreSQL::
* CockroachDB-specific objects::

Release notes

* psycopg release notes::
* psycopg_pool release notes::

psycopg release notes

* Current release::
* Psycopg 3.2: Psycopg 3 2.
* Psycopg 3.1: Psycopg 3 1.
* Psycopg 3.0: Psycopg 3 0.

Current release

* Psycopg 3.2.12: Psycopg 3 2 12.
* Psycopg 3.2.11: Psycopg 3 2 11.
* Psycopg 3.2.10: Psycopg 3 2 10.
* Psycopg 3.2.9: Psycopg 3 2 9.
* Psycopg 3.2.8: Psycopg 3 2 8.
* Psycopg 3.2.7: Psycopg 3 2 7.
* Psycopg 3.2.6: Psycopg 3 2 6.
* Psycopg 3.2.5: Psycopg 3 2 5.
* Psycopg 3.2.4: Psycopg 3 2 4.
* Psycopg 3.2.3: Psycopg 3 2 3.
* Psycopg 3.2.2: Psycopg 3 2 2.
* Psycopg 3.2.1: Psycopg 3 2 1.

Psycopg 3.2

* Psycopg 3.1.20: Psycopg 3 1 20.
* Psycopg 3.1.19: Psycopg 3 1 19.
* Psycopg 3.1.18: Psycopg 3 1 18.
* Psycopg 3.1.17: Psycopg 3 1 17.
* Psycopg 3.1.16: Psycopg 3 1 16.
* Psycopg 3.1.15: Psycopg 3 1 15.
* Psycopg 3.1.14: Psycopg 3 1 14.
* Psycopg 3.1.13: Psycopg 3 1 13.
* Psycopg 3.1.12: Psycopg 3 1 12.
* Psycopg 3.1.11: Psycopg 3 1 11.
* Psycopg 3.1.10: Psycopg 3 1 10.
* Psycopg 3.1.9: Psycopg 3 1 9.
* Psycopg 3.1.8: Psycopg 3 1 8.
* Psycopg 3.1.7: Psycopg 3 1 7.
* Psycopg 3.1.6: Psycopg 3 1 6.
* Psycopg 3.1.5: Psycopg 3 1 5.
* Psycopg 3.1.4: Psycopg 3 1 4.
* Psycopg 3.1.3: Psycopg 3 1 3.
* Psycopg 3.1.2: Psycopg 3 1 2.
* Psycopg 3.1.1: Psycopg 3 1 1.

Psycopg 3.1

* Psycopg 3.0.17: Psycopg 3 0 17.
* Psycopg 3.0.16: Psycopg 3 0 16.
* Psycopg 3.0.15: Psycopg 3 0 15.
* Psycopg 3.0.14: Psycopg 3 0 14.
* Psycopg 3.0.13: Psycopg 3 0 13.
* Psycopg 3.0.12: Psycopg 3 0 12.
* Psycopg 3.0.11: Psycopg 3 0 11.
* Psycopg 3.0.10: Psycopg 3 0 10.
* Psycopg 3.0.9: Psycopg 3 0 9.
* Psycopg 3.0.8: Psycopg 3 0 8.
* Psycopg 3.0.7: Psycopg 3 0 7.
* Psycopg 3.0.6: Psycopg 3 0 6.
* Psycopg 3.0.5: Psycopg 3 0 5.
* Psycopg 3.0.4: Psycopg 3 0 4.
* Psycopg 3.0.3: Psycopg 3 0 3.
* Psycopg 3.0.2: Psycopg 3 0 2.
* Psycopg 3.0.1: Psycopg 3 0 1.

Psycopg 3.0

* Psycopg 3.0b1: Psycopg 3 0b1.

psycopg_pool release notes

* Future releases::
* Current release: Current release<2>.
* psycopg_pool 3.2.0: psycopg_pool 3 2 0.
* psycopg_pool 3.1.0: psycopg_pool 3 1 0.
* psycopg_pool 3.0: psycopg_pool 3 0.

Future releases

* psycopg_pool 3.2.7 (unreleased): psycopg_pool 3 2 7 unreleased.

Current release

* psycopg_pool 3.2.6: psycopg_pool 3 2 6.
* psycopg_pool 3.2.5: psycopg_pool 3 2 5.
* psycopg_pool 3.2.4: psycopg_pool 3 2 4.
* psycopg_pool 3.2.3: psycopg_pool 3 2 3.
* psycopg_pool 3.2.2: psycopg_pool 3 2 2.
* psycopg_pool 3.2.1: psycopg_pool 3 2 1.

psycopg_pool 3.2.0

* psycopg_pool 3.1.9: psycopg_pool 3 1 9.
* psycopg_pool 3.1.8: psycopg_pool 3 1 8.
* psycopg_pool 3.1.7: psycopg_pool 3 1 7.
* psycopg_pool 3.1.6: psycopg_pool 3 1 6.
* psycopg_pool 3.1.5: psycopg_pool 3 1 5.
* psycopg_pool 3.1.4: psycopg_pool 3 1 4.
* psycopg_pool 3.1.3: psycopg_pool 3 1 3.
* psycopg_pool 3.1.2: psycopg_pool 3 1 2.
* psycopg_pool 3.1.1: psycopg_pool 3 1 1.

psycopg_pool 3.1.0

* psycopg_pool 3.0.3: psycopg_pool 3 0 3.
* psycopg_pool 3.0.2: psycopg_pool 3 0 2.
* psycopg_pool 3.0.1: psycopg_pool 3 0 1.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/

   (2) https://www.python.org/

   (3) https://www.psycopg.org/docs/

   (4) https://www.python.org/dev/peps/pep-0249/


File: psycopg.info,  Node: Documentation,  Next: Python Module Index,  Prev: Top,  Up: Top

1 Documentation
***************

* Menu:

* Getting started with Psycopg 3::
* More advanced topics::
* Psycopg 3 API::
* Release notes::
* Indices and tables::


File: psycopg.info,  Node: Getting started with Psycopg 3,  Next: More advanced topics,  Up: Documentation

1.1 Getting started with Psycopg 3
==================================

This section of the documentation will explain *note how to install
Psycopg: 1c. and how to perform normal activities such as *note querying
the database: 1d. or *note loading data using COPY: e.

     Important: If you are familiar with psycopg2 please take a look at
     *note Differences from psycopg2: 1e. to see what is changed.

* Menu:

* Installation::
* Basic module usage::
* Passing parameters to SQL queries::
* Adapting basic Python types::
* Adapting other PostgreSQL types::
* Transactions management::
* Using COPY TO and COPY FROM::
* Differences from psycopg2::


File: psycopg.info,  Node: Installation,  Next: Basic module usage,  Up: Getting started with Psycopg 3

1.1.1 Installation
------------------

In short, if you use a *note supported system: 21.:

     pip install --upgrade pip           # upgrade pip to at least 20.3
     pip install "psycopg[binary]"       # remove [binary] for PyPy

and you should be *note ready to start: 22.  Read further for
alternative ways to install.

     Note: Fun fact: there is no ‘psycopg3’ package, only ‘psycopg’!

* Menu:

* Supported systems::
* Binary installation::
* Local installation::
* Pure Python installation::
* Installing the connection pool::
* Handling dependencies::


File: psycopg.info,  Node: Supported systems,  Next: Binary installation,  Up: Installation

1.1.1.1 Supported systems
.........................

The Psycopg version documented here has 'official and tested' support
for:

   - Python: from version 3.8 to 3.14

        - Python 3.6 supported before Psycopg 3.1

        - Python 3.7 supported before Psycopg 3.2

   - PyPy: from version 3.9 to 3.11

        - 'Note:' Only the pure Python version is supported.

   - PostgreSQL: from version 10 to 18

        - 'Note:' PostgreSQL currently supported release(1) are actively
          tested in the CI. Out-of-support releases are supported on a
          best-effort basis.

   - OS: Linux, macOS, Windows

The tests to verify the supported systems run in Github workflows(2):
anything that is not tested there is not officially supported.  This
includes:

   - Unofficial Python distributions such as Conda;

   - Alternative PostgreSQL implementation;

   - Other platforms such as BSD or Solaris.

If you use an unsupported system, things might work (because, for
instance, the database may use the same wire protocol as PostgreSQL) but
we cannot guarantee the correct working or a smooth ride.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/support/versioning/

   (2) https://github.com/psycopg/psycopg/actions


File: psycopg.info,  Node: Binary installation,  Next: Local installation,  Prev: Supported systems,  Up: Installation

1.1.1.2 Binary installation
...........................

The quickest way to start developing with Psycopg 3 is to install the
binary packages by running:

     pip install "psycopg[binary]"

This will install a self-contained package with all the libraries
needed.  'You will need pip 20.3 at least': please run ‘pip install
--upgrade pip’ to update it beforehand.

See also
........

Did Psycopg 3 install ok?  Great!  You can now move on to the *note
basic module usage: 22. to learn how it works.

Keep on reading if the above method didn’t work and you need a different
way to install Psycopg 3.

For further information about the differences between the packages see
*note pq module implementations: 26.

If your platform is not supported, or if the libpq packaged is not
suitable, you should proceed to a *note local installation: 27. or a
*note pure Python installation: 28.

     Note: Binary packages are produced on a best-effort basis; the
     supported platforms depend on the CI runners available to build the
     packages.  This means that:

        - binary packages for a new version of Python are made available
          once the runners used for the build support it.  You can check
          the psycopg-binary PyPI files(1) to verify whether your
          platform is supported;

        - the libpq version included in the binary packages depends on
          the version available on the runners.  You can use the *note
          psycopg.pq.version(): 29. function and *note
          __build_version__: 2a. constant to infer the features
          available.

     Warning: 

        - Starting from Psycopg 3.1.20, ARM64 macOS binary packages
          (i.e.  for Apple M1 machines) are no more available for macOS
          versions before 14.0.  Please upgrade your OS to at least 14.0
          or use a *note local: 27. or a *note Python: 28. installation.

        - The binary installation is not supported by PyPy.

   ---------- Footnotes ----------

   (1) https://pypi.org/project/psycopg-binary/#files


File: psycopg.info,  Node: Local installation,  Next: Pure Python installation,  Prev: Binary installation,  Up: Installation

1.1.1.3 Local installation
..........................

A “Local installation” results in a performing and maintainable library.
The library will include the speed-up C module and will be linked to the
system libraries (‘libpq’, ‘libssl’…) so that system upgrade of
libraries will upgrade the libraries used by Psycopg 3 too.  This is the
preferred way to install Psycopg for a production site.

In order to perform a local installation you need some prerequisites:

   - a C compiler,

   - Python development headers (e.g.  the ‘python3-dev’ package).

   - PostgreSQL client development headers (e.g.  the ‘libpq-dev’
     package).

   - The ‘pg_config’ program available in the ‘PATH’.

You 'must be able' to troubleshoot an extension build, for instance you
must be able to read your compiler’s error message.  If you are not,
please don’t try this and follow the *note binary installation: 25.
instead.

If your build prerequisites are in place you can run:

     pip install "psycopg[c]"

     Warning: The local installation is not supported by PyPy.


File: psycopg.info,  Node: Pure Python installation,  Next: Installing the connection pool,  Prev: Local installation,  Up: Installation

1.1.1.4 Pure Python installation
................................

If you simply install:

     pip install psycopg

without ‘[c]’ or ‘[binary]’ extras you will obtain a pure Python
implementation.  This is particularly handy to debug and hack, but it
still requires the system libpq to operate (which will be imported
dynamically via ctypes(1)).

In order to use the pure Python installation you will need the ‘libpq’
installed in the system: for instance on Debian system you will probably
need:

     sudo apt install libpq5

     Note: The ‘libpq’ is the client library used by ‘psql’, the
     PostgreSQL command line client, to connect to the database.  On
     most systems, installing ‘psql’ will install the ‘libpq’ too as a
     dependency.

If you are not able to fulfill this requirement please follow the *note
binary installation: 25.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/ctypes.html#module-ctypes


File: psycopg.info,  Node: Installing the connection pool,  Next: Handling dependencies,  Prev: Pure Python installation,  Up: Installation

1.1.1.5 Installing the connection pool
......................................

The *note Psycopg connection pools: f. are distributed in a separate
package from the ‘psycopg’ package itself, in order to allow a different
release cycle.

In order to use the pool you must install the ‘pool’ extra, using ‘pip
install "psycopg[pool]"’, or install the *note psycopg_pool: b. package
separately, which would allow to specify the release to install more
precisely.


File: psycopg.info,  Node: Handling dependencies,  Prev: Installing the connection pool,  Up: Installation

1.1.1.6 Handling dependencies
.............................

If you need to specify your project dependencies (for instance in a
‘requirements.txt’ file, ‘setup.py’, ‘pyproject.toml’ dependencies…) you
should probably specify one of the following:

   - If your project is a library, add a dependency on ‘psycopg’.  This
     will make sure that your library will have the ‘psycopg’ package
     with the right interface and leaves the possibility of choosing a
     specific implementation to the end user of your library.

   - If your project is a final application (e.g.  a service running on
     a server) you can require a specific implementation, for instance
     ‘psycopg[c]’, after you have made sure that the prerequisites are
     met (e.g.  the depending libraries and tools are installed in the
     host machine).

In both cases you can specify which version of Psycopg to use using
requirement specifiers(1).

If you want to make sure that a specific implementation is used you can
specify the ‘PSYCOPG_IMPL’ environment variable: importing the library
will fail if the implementation specified is not available.  See *note
pq module implementations: 26.

   ---------- Footnotes ----------

   (1) https://pip.pypa.io/en/stable/reference/requirement-specifiers/


File: psycopg.info,  Node: Basic module usage,  Next: Passing parameters to SQL queries,  Prev: Installation,  Up: Getting started with Psycopg 3

1.1.2 Basic module usage
------------------------

The basic Psycopg usage is common to all the database adapters
implementing the DB-API(1) protocol.  Other database adapters, such as
the builtin sqlite3(2) or psycopg2(3), have roughly the same pattern of
interaction.

* Menu:

* Main objects in Psycopg 3::
* Shortcuts::
* Connection context::
* Adapting psycopg to your program::
* Connection logging::

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0249/

   (2) https://docs.python.org/3/library/sqlite3.html#module-sqlite3

   (3) https://www.psycopg.org/docs/module.html#module-psycopg2


File: psycopg.info,  Node: Main objects in Psycopg 3,  Next: Shortcuts,  Up: Basic module usage

1.1.2.1 Main objects in Psycopg 3
.................................

Here is an interactive session showing some of the basic commands:

     # Note: the module name is psycopg, not psycopg3
     import psycopg

     # Connect to an existing database
     with psycopg.connect("dbname=test user=postgres") as conn:

         # Open a cursor to perform database operations
         with conn.cursor() as cur:

             # Execute a command: this creates a new table
             cur.execute("""
                 CREATE TABLE test (
                     id serial PRIMARY KEY,
                     num integer,
                     data text)
                 """)

             # Pass data to fill a query placeholders and let Psycopg perform
             # the correct conversion (no SQL injections!)
             cur.execute(
                 "INSERT INTO test (num, data) VALUES (%s, %s)",
                 (100, "abc'def"))

             # Query the database and obtain data as Python objects.
             cur.execute("SELECT * FROM test")
             cur.fetchone()
             # will return (1, 100, "abc'def")

             # You can use `cur.fetchmany()`, `cur.fetchall()` to return a list
             # of several records, or even iterate on the cursor
             for record in cur:
                 print(record)

             # Make the changes to the database persistent
             conn.commit()

In the example you can see some of the main objects and methods and how
they relate to each other:

   - The function *note connect(): 33. creates a new database session
     and returns a new *note Connection: 34. instance.  *note
     AsyncConnection.connect(): 35. creates an asyncio(1) connection
     instead.

   - The *note Connection: 34. class encapsulates a database session.
     It allows to:

        - create new *note Cursor: 36. instances using the *note
          cursor(): 37. method to execute database commands and queries,

        - terminate transactions using the methods *note commit(): 38.
          or *note rollback(): 39.

   - The class *note Cursor: 36. allows interaction with the database:

        - send commands to the database using methods such as *note
          execute(): 3a. and *note executemany(): 3b,

        - retrieve data from the database, iterating on the cursor or
          using methods such as *note fetchone(): 3c, *note fetchmany():
          3d, *note fetchall(): 3e.

   - Using these objects as context managers (i.e.  using ‘with’) will
     make sure to close them and free their resources at the end of the
     block (notice that *note this is different from psycopg2: 3f.).

See also
........

A few important topics you will have to deal with are:

   - *note Passing parameters to SQL queries: 40.

   - *note Adapting basic Python types: 41.

   - *note Transactions management: 42.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/asyncio.html#module-asyncio


File: psycopg.info,  Node: Shortcuts,  Next: Connection context,  Prev: Main objects in Psycopg 3,  Up: Basic module usage

1.1.2.2 Shortcuts
.................

The pattern above is familiar to ‘psycopg2’ users.  However, Psycopg 3
also exposes a few simple extensions which make the above pattern
leaner:

   - the *note Connection: 34. objects exposes an *note execute(): 44.
     method, equivalent to creating a cursor, calling its *note
     execute(): 3a. method, and returning it.

          # In Psycopg 2
          cur = conn.cursor()
          cur.execute(...)

          # In Psycopg 3
          cur = conn.execute(...)

   - The *note Cursor.execute(): 3a. method returns ‘self’.  This means
     that you can chain a fetch operation, such as *note fetchone(): 3c,
     to the ‘execute()’ call:

          # In Psycopg 2
          cur.execute(...)
          record = cur.fetchone()

          cur.execute(...)
          for record in cur:
              ...

          # In Psycopg 3
          record = cur.execute(...).fetchone()

          for record in cur.execute(...):
              ...

Using them together, in simple cases, you can go from creating a
connection to using a result in a single expression:

     print(psycopg.connect(DSN).execute("SELECT now()").fetchone()[0])
     # 2042-07-12 18:15:10.706497+01:00


File: psycopg.info,  Node: Connection context,  Next: Adapting psycopg to your program,  Prev: Shortcuts,  Up: Basic module usage

1.1.2.3 Connection context
..........................

Psycopg 3 *note Connection: 34. can be used as a context manager:

     with psycopg.connect() as conn:
         ... # use the connection

     # the connection is now closed

When the block is exited, if there is a transaction open, it will be
committed.  If an exception is raised within the block the transaction
is rolled back.  In both cases the connection is closed.  It is roughly
the equivalent of:

     conn = psycopg.connect()
     try:
         ... # use the connection
     except BaseException:
         conn.rollback()
     else:
         conn.commit()
     finally:
         conn.close()

     Note: This behaviour is not what ‘psycopg2’ does: in ‘psycopg2’
     there is no final close()(1) and the connection can be used in
     several ‘with’ statements to manage different transactions.  This
     behaviour has been considered non-standard and surprising so it has
     been replaced by the more explicit *note transaction(): 47. block.

Note that, while the above pattern is what most people would use, *note
connect(): 48. doesn’t enter a block itself, but returns an “un-entered”
connection, so that it is still possible to use a connection regardless
of the code scope and the developer is free to use (and responsible for
calling) *note commit(): 38, *note rollback(): 39, *note close(): 49. as
and where needed.

     Warning: If a connection is just left to go out of scope, the way
     it will behave with or without the use of a ‘with’ block is
     different:

        - if the connection is used without a ‘with’ block, the server
          will find a connection closed INTRANS and roll back the
          current transaction;

        - if the connection is used with a ‘with’ block, there will be
          an explicit COMMIT and the operations will be finalised.

     You should use a ‘with’ block when your intention is just to
     execute a set of operations and then committing the result, which
     is the most usual thing to do with a connection.  If your
     connection life cycle and transaction pattern is different, and
     want more control on it, the use without ‘with’ might be more
     convenient.

     See *note Transactions management: 42. for more information.

*note AsyncConnection: 4a. can be also used as context manager, using
‘async with’, but be careful about its quirkiness: see *note with async
connections: 4b. for details.

   ---------- Footnotes ----------

   (1) https://www.psycopg.org/docs/usage.html#with


File: psycopg.info,  Node: Adapting psycopg to your program,  Next: Connection logging,  Prev: Connection context,  Up: Basic module usage

1.1.2.4 Adapting psycopg to your program
........................................

The above *note pattern of use: 1d. only shows the default behaviour of
the adapter.  Psycopg can be customised in several ways, to allow the
smoothest integration between your Python program and your PostgreSQL
database:

   - If your program is concurrent and based on asyncio(1) instead of on
     threads/processes, you can use *note async connections and cursors:
     d.

   - If you want to customise the objects that the cursor returns,
     instead of receiving tuples, you can specify your *note row
     factories: 4d.

   - If you want to customise how Python values and PostgreSQL types are
     mapped into each other, beside the *note basic type mapping: 41,
     you can *note configure your types: 4e.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/asyncio.html#module-asyncio


File: psycopg.info,  Node: Connection logging,  Prev: Adapting psycopg to your program,  Up: Basic module usage

1.1.2.5 Connection logging
..........................

Psycopg uses the logging(1) module to report the operations happening at
connection time.  If you experience slowness or random failures on
connection you can set the ‘psycopg’ logger at ‘DEBUG’ level to read the
operations performed.

A very simple example of logging configuration may be the following:

     import logging
     import psycopg

     logger = logging.getLogger()
     logging.basicConfig(level=logging.DEBUG, format="%(asctime)s %(levelname)s %(message)s")

     logging.getLogger("psycopg").setLevel(logging.DEBUG)

     psycopg.connect("host=192.0.2.1,localhost connect_timeout=10")

In this example Psycopg will first try to connect to a non responsive
server, only stopping after hitting the timeout, and will move on to a
working server.  The resulting log might look like:

     2045-05-10 11:45:54,364 DEBUG connection attempt: host: '192.0.2.1', port: None, hostaddr: '192.0.2.1'
     2045-05-10 11:45:54,365 DEBUG connection started: <psycopg_c.pq.PGconn [STARTED] at 0x79dff6d26160>
     2045-05-10 11:45:54,365 DEBUG connection polled: <psycopg_c.pq.PGconn [MADE] at 0x79dff6d26160>
     2045-05-10 11:46:04,392 DEBUG connection failed: host: '192.0.2.1', port: None, hostaddr: '192.0.2.1': connection timeout expired
     2045-05-10 11:46:04,392 DEBUG connection attempt: host: 'localhost', port: None, hostaddr: '127.0.0.1'
     2045-05-10 11:46:04,393 DEBUG connection started: <psycopg_c.pq.PGconn [STARTED] at 0x79dff6d26160>
     2045-05-10 11:46:04,394 DEBUG connection polled: <psycopg_c.pq.PGconn [MADE] at 0x79dff6d26160>
     2045-05-10 11:46:04,394 DEBUG connection polled: <psycopg_c.pq.PGconn [SSL_STARTUP] at 0x79dff6d26160>
     2045-05-10 11:46:04,411 DEBUG connection polled: <psycopg_c.pq.PGconn [SSL_STARTUP] at 0x79dff6d26160>
     2045-05-10 11:46:04,413 DEBUG connection polled: <psycopg_c.pq.PGconn [SSL_STARTUP] at 0x79dff6d26160>
     2045-05-10 11:46:04,423 DEBUG connection polled: <psycopg_c.pq.PGconn [MADE] at 0x79dff6d26160>
     2045-05-10 11:46:04,424 DEBUG connection polled: <psycopg_c.pq.PGconn [AWAITING_RESPONSE] at 0x79dff6d26160>
     2045-05-10 11:46:04,426 DEBUG connection polled: <psycopg_c.pq.PGconn [IDLE] (host=localhost database=piro) at 0x79dff6d26160>
     2045-05-10 11:46:04,426 DEBUG connection succeeded: host: 'localhost', port: None, hostaddr: '127.0.0.1'

Please note that a connection attempt might try to reach different
servers: either explicitly because the connection string specifies
multiple hosts(2), or implicitly, because the DNS resolves an host name
to multiple IPs.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/logging.html#module-logging

   (2) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-MULTIPLE-HOSTS


File: psycopg.info,  Node: Passing parameters to SQL queries,  Next: Adapting basic Python types,  Prev: Basic module usage,  Up: Getting started with Psycopg 3

1.1.3 Passing parameters to SQL queries
---------------------------------------

Most of the times, writing a program you will have to mix bits of SQL
statements with values provided by the rest of the program:

     SELECT some, fields FROM some_table WHERE id = ...

‘id’ equals what?  Probably you will have a Python value you are looking
for.

* Menu:

* execute() arguments: execute arguments.
* Danger; SQL injection: Danger SQL injection.
* Binary parameters and results::


File: psycopg.info,  Node: execute arguments,  Next: Danger SQL injection,  Up: Passing parameters to SQL queries

1.1.3.1 ‘execute()’ arguments
.............................

Passing parameters to a SQL statement happens in functions such as *note
Cursor.execute(): 3a. by using ‘%s’ placeholders in the SQL statement,
and passing a sequence of values as the second argument of the function.
For example the Python function call:

     cur.execute("""
         INSERT INTO some_table (id, created_at, last_name)
         VALUES (%s, %s, %s);
         """,
         (10, datetime.date(2020, 11, 18), "O'Reilly"))

is 'roughly' equivalent to the SQL command:

     INSERT INTO some_table (id, created_at, last_name)
     VALUES (10, '2020-11-18', 'O''Reilly');

Note that the parameters will not be really merged to the query: query
and the parameters are sent to the server separately: see *note
Server-side binding: 11. for details.

Named arguments are supported too using ‘%(NAME)s’ placeholders in the
query and specifying the values into a mapping.  Using named arguments
allows to specify the values in any order and to repeat the same value
in several places in the query:

     cur.execute("""
         INSERT INTO some_table (id, created_at, updated_at, last_name)
         VALUES (%(id)s, %(created)s, %(created)s, %(name)s);
         """,
         {'id': 10, 'name': "O'Reilly", 'created': datetime.date(2020, 11, 18)})

Using characters ‘%’, ‘(’, ‘)’ in the argument names is not supported.

When parameters are used, in order to include a literal ‘%’ in the query
you can use the ‘%%’ string:

     cur.execute("SELECT (%s % 2) = 0 AS even", (10,))       # WRONG
     cur.execute("SELECT (%s %% 2) = 0 AS even", (10,))      # correct

While the mechanism resembles regular Python strings manipulation, there
are a few subtle differences you should care about when passing
parameters to a query.

   - The Python string operator ‘%’ 'must not be used': the ‘execute()’
     method accepts a tuple or dictionary of values as second parameter.
     *note Never use % or + to merge values into queries: 55.:

          cur.execute("INSERT INTO numbers VALUES (%s, %s)" % (10, 20)) # WRONG
          cur.execute("INSERT INTO numbers VALUES (%s, %s)", (10, 20))  # correct
   - For positional variables binding, 'the second argument must always
     be a sequence', even if it contains a single variable (remember
     that Python requires a comma to create a single element tuple):

          cur.execute("INSERT INTO foo VALUES (%s)", "bar")    # WRONG
          cur.execute("INSERT INTO foo VALUES (%s)", ("bar"))  # WRONG
          cur.execute("INSERT INTO foo VALUES (%s)", ("bar",)) # correct
          cur.execute("INSERT INTO foo VALUES (%s)", ["bar"])  # correct

   - The placeholder 'must not be quoted':

          cur.execute("INSERT INTO numbers VALUES ('%s')", ("Hello",)) # WRONG
          cur.execute("INSERT INTO numbers VALUES (%s)", ("Hello",))   # correct

   - The variables placeholder 'must always be a' ‘%s’, even if a
     different placeholder (such as a ‘%d’ for integers or ‘%f’ for
     floats) may look more appropriate for the type.  You may find other
     placeholders used in Psycopg queries (‘%b’ and ‘%t’) but they are
     not related to the type of the argument: see *note Binary
     parameters and results: 14. if you want to read more:

          cur.execute("INSERT INTO numbers VALUES (%d)", (10,))   # WRONG
          cur.execute("INSERT INTO numbers VALUES (%s)", (10,))   # correct

   - Only query values should be bound via this method: it shouldn’t be
     used to merge table or field names to the query.  If you need to
     generate SQL queries dynamically (for instance choosing a table
     name at runtime) you can use the functionalities provided in the
     *note psycopg.sql: 9. module:

          cur.execute("INSERT INTO %s VALUES (%s)", ('numbers', 10))  # WRONG
          cur.execute(                                                # correct
              SQL("INSERT INTO {} VALUES (%s)").format(Identifier('numbers')),
              (10,))


File: psycopg.info,  Node: Danger SQL injection,  Next: Binary parameters and results,  Prev: execute arguments,  Up: Passing parameters to SQL queries

1.1.3.2 Danger: SQL injection
.............................

The SQL representation of many data types is often different from their
Python string representation.  The typical example is with single quotes
in strings: in SQL single quotes are used as string literal delimiters,
so the ones appearing inside the string itself must be escaped, whereas
in Python single quotes can be left unescaped if the string is delimited
by double quotes.

Because of the difference, sometimes subtle, between the data types
representations, a naïve approach to query strings composition, such as
using Python strings concatenation, is a recipe for 'terrible' problems:

     SQL = "INSERT INTO authors (name) VALUES ('%s')" # NEVER DO THIS
     data = ("O'Reilly", )
     cur.execute(SQL % data) # THIS WILL FAIL MISERABLY
     # SyntaxError: syntax error at or near "Reilly"

If the variables containing the data to send to the database come from
an untrusted source (such as data coming from a form on a web site) an
attacker could easily craft a malformed string, either gaining access to
unauthorized data or performing destructive operations on the database.
This form of attack is called SQL injection(1) and is known to be one of
the most widespread forms of attack on database systems.  Before
continuing, please print this page(2) as a memo and hang it onto your
desk.

Psycopg can *note automatically convert Python objects to SQL values:
41.: using this feature your code will be more robust and reliable.  We
must stress this point:

     Warning: 

        - Don’t manually merge values to a query: hackers from a foreign
          country will break into your computer and steal not only your
          disks, but also your cds, leaving you only with the three most
          embarrassing records you ever bought.  On cassette tapes.

        - If you use the ‘%’ operator to merge values to a query, con
          artists will seduce your cat, who will run away taking your
          credit card and your sunglasses with them.

        - If you use ‘+’ to merge a textual value to a string, bad guys
          in balaclava will find their way to your fridge, drink all
          your beer, and leave your toilet seat up and your toilet paper
          in the wrong orientation.

        - You don’t want to manually merge values to a query: *note use
          the provided methods: 40. instead.

The correct way to pass variables in a SQL command is using the second
argument of the *note Cursor.execute(): 3a. method:

     SQL = "INSERT INTO authors (name) VALUES (%s)"  # Note: no quotes
     data = ("O'Reilly", )
     cur.execute(SQL, data)  # Note: no % operator

     Note: Python static code checkers are not quite there yet, but, in
     the future, it will be possible to check your code for improper use
     of string expressions in queries.  See *note Checking literal
     strings in queries: 58. for details.

See also
........

Now that you know how to pass parameters to queries, you can take a look
at *note how Psycopg converts data types: 41.

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/SQL_injection

   (2) https://xkcd.com/327/


File: psycopg.info,  Node: Binary parameters and results,  Prev: Danger SQL injection,  Up: Passing parameters to SQL queries

1.1.3.3 Binary parameters and results
.....................................

PostgreSQL has two different ways to transmit data between client and
server: *note TEXT: 5a, always available, and *note BINARY: 5b,
available most of the times but not always.  Usually the binary format
is more efficient to use.

Psycopg can support both formats for each data type.  Whenever a value
is passed to a query using the normal ‘%s’ placeholder, the best format
available is chosen (often, but not always, the binary format is picked
as the best choice).

If you have a reason to select explicitly the binary format or the text
format for a value you can use respectively a ‘%b’ placeholder or a ‘%t’
placeholder instead of the normal ‘%s’.  *note execute(): 3a. will fail
if a *note Dumper: 5c. for the right data type and format is not
available.

The same two formats, text or binary, are used by PostgreSQL to return
data from a query to the client.  Unlike with parameters, where you can
choose the format value-by-value, all the columns returned by a query
will have the same format.  Every type returned by the query should have
a *note Loader: 5d. configured, otherwise the data will be returned as
unparsed ‘str’ (for text results) or buffer (for binary results).

     Note: The pg_type(1) table defines which format is supported for
     each PostgreSQL data type.  Text input/output is managed by the
     functions declared in the ‘typinput’ and ‘typoutput’ fields (always
     present), binary input/output is managed by the ‘typsend’ and
     ‘typreceive’ (which are optional).

Because not every PostgreSQL type supports binary output, by default,
the data will be returned in text format.  In order to return data in
binary format you can create the cursor using *note Connection.cursor:
37.‘(binary=True)’ or execute the query using *note Cursor.execute:
3a.‘(binary=True)’.  A case in which requesting binary results is a
clear winner is when you have large binary data in the database, such as
images:

     cur.execute(
         "SELECT image_data FROM images WHERE id = %s", [image_id], binary=True)
     data = cur.fetchone()[0]

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/catalog-pg-type.html


File: psycopg.info,  Node: Adapting basic Python types,  Next: Adapting other PostgreSQL types,  Prev: Passing parameters to SQL queries,  Up: Getting started with Psycopg 3

1.1.4 Adapting basic Python types
---------------------------------

Many standard Python types are adapted into SQL and returned as Python
objects when a query is executed.

Converting the following data types between Python and PostgreSQL works
out-of-the-box and doesn’t require any configuration.  In case you need
to customise the conversion you should take a look at *note Data
adaptation configuration: 4e.

* Menu:

* Booleans adaptation::
* Numbers adaptation::
* Strings adaptation::
* Binary adaptation::
* Date/time types adaptation::
* JSON adaptation::
* Lists adaptation::
* UUID adaptation::
* Network data types adaptation::
* Enum adaptation::


File: psycopg.info,  Node: Booleans adaptation,  Next: Numbers adaptation,  Up: Adapting basic Python types

1.1.4.1 Booleans adaptation
...........................

Python bool(1) values ‘True’ and ‘False’ are converted to the equivalent
PostgreSQL boolean type(2):

     >>> cur.execute("SELECT %s, %s", (True, False))
     # equivalent to "SELECT true, false"

Changed in version 3.2: numpy.bool_(3) values can be dumped too.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#bool

   (2) https://www.postgresql.org/docs/current/datatype-boolean.html

   (3) 
https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.bool_


File: psycopg.info,  Node: Numbers adaptation,  Next: Strings adaptation,  Prev: Booleans adaptation,  Up: Adapting basic Python types

1.1.4.2 Numbers adaptation
..........................

See also
........

   - PostgreSQL numeric types(1)

   - Python int(2) values can be converted to PostgreSQL ‘smallint’,
     ‘integer’, ‘bigint’, or ‘numeric’, according to their numeric
     value.  Psycopg will choose the smallest data type available,
     because PostgreSQL can automatically cast a type up (e.g.  passing
     a ‘smallint’ where PostgreSQL expect an ‘integer’ is gladly
     accepted) but will not cast down automatically (e.g.  if a function
     has an ‘integer’ argument, passing it a ‘bigint’ value will fail,
     even if the value is 1).

   - Python float(3) values are converted to PostgreSQL ‘float8’.

   - Python Decimal(4) values are converted to PostgreSQL ‘numeric’.

On the way back, smaller types (‘int2’, ‘int4’, ‘float4’) are promoted
to the larger Python counterpart.

     Note: Sometimes you may prefer to receive ‘numeric’ data as ‘float’
     instead, for performance reason or ease of manipulation: you can
     configure an adapter to *note cast PostgreSQL numeric to Python
     float: 64.  This of course may imply a loss of precision.

Changed in version 3.2: NumPy integer(5) and floating point(6) values
can be dumped too.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/static/datatype-numeric.html

   (2) https://docs.python.org/3/library/functions.html#int

   (3) https://docs.python.org/3/library/functions.html#float

   (4) https://docs.python.org/3/library/decimal.html#decimal.Decimal

   (5) 
https://numpy.org/doc/stable/reference/arrays.scalars.html#integer-types

   (6) 
https://numpy.org/doc/stable/reference/arrays.scalars.html#floating-point-types


File: psycopg.info,  Node: Strings adaptation,  Next: Binary adaptation,  Prev: Numbers adaptation,  Up: Adapting basic Python types

1.1.4.3 Strings adaptation
..........................

See also
........

   - PostgreSQL character types(1)

Python str(2) are converted to PostgreSQL string syntax, and PostgreSQL
types such as ‘text’ and ‘varchar’ are converted back to Python ‘str’:

     conn = psycopg.connect()
     conn.execute(
         "INSERT INTO menu (id, entry) VALUES (%s, %s)",
         (1, "Crème Brûlée at 4.99€"))
     conn.execute("SELECT entry FROM menu WHERE id = 1").fetchone()[0]
     'Crème Brûlée at 4.99€'

PostgreSQL databases have an encoding(3), and the session has an
encoding(4) too, exposed in the ‘Connection.info.’*note encoding: 67.
attribute.  If your database and connection are in UTF-8 encoding you
will likely have no problem, otherwise you will have to make sure that
your application only deals with the non-ASCII chars that the database
can handle; failing to do so may result in encoding/decoding errors:

     # The encoding is set at connection time according to the db configuration
     conn.info.encoding
     'utf-8'

     # The Latin-9 encoding can manage some European accented letters
     # and the Euro symbol
     conn.execute("SET client_encoding TO LATIN9")
     conn.execute("SELECT entry FROM menu WHERE id = 1").fetchone()[0]
     'Crème Brûlée at 4.99€'

     # The Latin-1 encoding doesn't have a representation for the Euro symbol
     conn.execute("SET client_encoding TO LATIN1")
     conn.execute("SELECT entry FROM menu WHERE id = 1").fetchone()[0]
     # Traceback (most recent call last)
     # ...
     # UntranslatableCharacter: character with byte sequence 0xe2 0x82 0xac
     # in encoding "UTF8" has no equivalent in encoding "LATIN1"

In rare cases you may have strings with unexpected encodings in the
database.  Using the ‘SQL_ASCII’ client encoding will disable decoding
of the data coming from the database, which will be returned as
bytes(5):

     conn.execute("SET client_encoding TO SQL_ASCII")
     conn.execute("SELECT entry FROM menu WHERE id = 1").fetchone()[0]
     b'Cr\xc3\xa8me Br\xc3\xbbl\xc3\xa9e at 4.99\xe2\x82\xac'

Alternatively you can cast the unknown encoding data to ‘bytea’ to
retrieve it as bytes, leaving other strings unaltered: see *note Binary
adaptation: 68.

Note that PostgreSQL text cannot contain the ‘0x00’ byte.  If you need
to store Python strings that may contain binary zeros you should use a
‘bytea’ field.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/datatype-character.html

   (2) https://docs.python.org/3/library/stdtypes.html#str

   (3) https://www.postgresql.org/docs/current/sql-createdatabase.html

   (4) https://www.postgresql.org/docs/current/multibyte.html

   (5) https://docs.python.org/3/library/stdtypes.html#bytes


File: psycopg.info,  Node: Binary adaptation,  Next: Date/time types adaptation,  Prev: Strings adaptation,  Up: Adapting basic Python types

1.1.4.4 Binary adaptation
.........................

Python types representing binary objects (bytes(1), bytearray(2),
memoryview(3)) are converted by default to ‘bytea’ fields.  By default
data received is returned as ‘bytes’.

If you are storing large binary data in bytea fields (such as binary
documents or images) you should probably use the binary format to pass
and return values, otherwise binary data will undergo ASCII escaping(4),
taking some CPU time and more bandwidth.  See *note Binary parameters
and results: 14. for details.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#bytes

   (2) https://docs.python.org/3/library/stdtypes.html#bytearray

   (3) https://docs.python.org/3/library/stdtypes.html#memoryview

   (4) https://www.postgresql.org/docs/current/datatype-binary.html


File: psycopg.info,  Node: Date/time types adaptation,  Next: JSON adaptation,  Prev: Binary adaptation,  Up: Adapting basic Python types

1.1.4.5 Date/time types adaptation
..................................

See also
........

   - PostgreSQL date/time types(1)

   - Python date(2) objects are converted to PostgreSQL ‘date’.

   - Python datetime(3) objects are converted to PostgreSQL ‘timestamp’
     (if they don’t have a ‘tzinfo’ set) or ‘timestamptz’ (if they do).

   - Python time(4) objects are converted to PostgreSQL ‘time’ (if they
     don’t have a ‘tzinfo’ set) or ‘timetz’ (if they do).

   - Python timedelta(5) objects are converted to PostgreSQL ‘interval’.

PostgreSQL ‘timestamptz’ values are returned with a timezone set to the
connection TimeZone setting(6), which is available as a Python
ZoneInfo(7) object in the ‘Connection.info’.*note timezone: 6c.
attribute:

     >>> conn.info.timezone
     zoneinfo.ZoneInfo(key='Europe/London')

     >>> conn.execute("select '2048-07-08 12:00'::timestamptz").fetchone()[0]
     datetime.datetime(2048, 7, 8, 12, 0, tzinfo=zoneinfo.ZoneInfo(key='Europe/London'))

     Note: PostgreSQL ‘timestamptz’ doesn’t store “a timestamp with a
     timezone attached”: it stores a timestamp always in UTC, which is
     converted, on output, to the connection TimeZone setting:

          >>> conn.execute("SET TIMEZONE to 'Europe/Rome'")  # UTC+2 in summer

          >>> conn.execute("SELECT '2042-07-01 12:00Z'::timestamptz").fetchone()[0]  # UTC input
          datetime.datetime(2042, 7, 1, 14, 0, tzinfo=zoneinfo.ZoneInfo(key='Europe/Rome'))

     Check out the PostgreSQL documentation about timezones(8) for all
     the details.

     Warning: Times with timezone are silly objects, because you cannot
     know the offset of a timezone with daylight saving time rules
     without knowing the date too.

     Although silly, times with timezone are supported both by Python
     and by PostgreSQL. However they are only supported with fixed
     offset timezones: Postgres ‘timetz’ values loaded from the database
     will result in Python ‘time’ objects with ‘tzinfo’ attributes
     specified as fixed offset, for instance by a timezone(9) value:

          >>> conn.execute("SET TIMEZONE to 'Europe/Rome'")

          # UTC+1 in winter
          >>> conn.execute("SELECT '2042-01-01 12:00Z'::timestamptz::timetz").fetchone()[0]
          datetime.time(13, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

          # UTC+2 in summer
          >>> conn.execute("SELECT '2042-07-01 12:00Z'::timestamptz::timetz").fetchone()[0]
          datetime.time(14, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200)))

     Dumping Python ‘time’ objects is only supported with fixed offset
     ‘tzinfo’, such as the ones returned by Postgres, or by whatever
     tzinfo(10) implementation resulting in the time’s utcoffset(11)
     returning a value.

* Menu:

* Dates and times limits in Python::
* DateStyle and IntervalStyle limits::

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/datatype-datetime.html

   (2) https://docs.python.org/3/library/datetime.html#datetime.date

   (3) https://docs.python.org/3/library/datetime.html#datetime.datetime

   (4) https://docs.python.org/3/library/datetime.html#datetime.time

   (5) 
https://docs.python.org/3/library/datetime.html#datetime.timedelta

   (6) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-TIMEZONE

   (7) https://docs.python.org/3/library/zoneinfo.html#zoneinfo.ZoneInfo

   (8) 
https://www.postgresql.org/docs/current/datatype-datetime.html#DATATYPE-TIMEZONES

   (9) https://docs.python.org/3/library/datetime.html#datetime.timezone

   (10) https://docs.python.org/3/library/datetime.html#datetime.tzinfo

   (11) 
https://docs.python.org/3/library/datetime.html#datetime.time.utcoffset


File: psycopg.info,  Node: Dates and times limits in Python,  Next: DateStyle and IntervalStyle limits,  Up: Date/time types adaptation

1.1.4.6 Dates and times limits in Python
........................................

PostgreSQL date and time objects can represent values that cannot be
represented by the Python datetime(1) objects:

   - dates and timestamps after the year 9999, the special value
     “infinity”;

   - dates and timestamps before the year 1, the special value
     “-infinity”;

   - the time 24:00:00.

Loading these values will raise a *note DataError: 6f.

If you need to handle these values you can define your own mapping (for
instance mapping every value greater than datetime.date.max(2) to
‘date.max’, or the time 24:00 to 00:00) and write a subclass of the
default loaders implementing the added capability; please see *note this
example: 70. for a reference.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/datetime.html#module-datetime

   (2) https://docs.python.org/3/library/datetime.html#datetime.date.max


File: psycopg.info,  Node: DateStyle and IntervalStyle limits,  Prev: Dates and times limits in Python,  Up: Date/time types adaptation

1.1.4.7 DateStyle and IntervalStyle limits
..........................................

Loading ‘timestamp with time zone’ in text format is only supported if
the connection DateStyle(1) is set to ‘ISO’ format; time and time zone
representation in other formats is ambiguous.

Furthermore, at the time of writing, the only supported value for
IntervalStyle(2) is ‘postgres’; loading ‘interval’ data in text format
with a different setting is not supported.

If your server is configured with different settings by default, you can
obtain a connection in a supported style using the ‘options’ connection
parameter; for example:

     >>> conn = psycopg.connect(options="-c datestyle=ISO,YMD")
     >>> conn.execute("show datestyle").fetchone()[0]
     # 'ISO, YMD'

These GUC parameters only affects loading in text format; loading
timestamps or intervals in *note binary format: 14. is not affected by
DateStyle or IntervalStyle.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DATESTYLE

   (2) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-INTERVALSTYLE


File: psycopg.info,  Node: JSON adaptation,  Next: Lists adaptation,  Prev: Date/time types adaptation,  Up: Adapting basic Python types

1.1.4.8 JSON adaptation
.......................

Psycopg can map between Python objects and PostgreSQL json/jsonb
types(1), allowing to customise the load and dump function used.

Because several Python objects could be considered JSON (dicts, lists,
scalars, even date/time if using a dumps function customised to use
them), Psycopg requires you to wrap the object to dump as JSON into a
wrapper: either *note psycopg.types.json.Json: 75. or *note Jsonb: 76.

     from psycopg.types.json import Jsonb

     thing = {"foo": ["bar", 42]}
     conn.execute("INSERT INTO mytable VALUES (%s)", [Jsonb(thing)])

By default Psycopg uses the standard library json.dumps(2) and
json.loads(3) functions to serialize and de-serialize Python objects to
JSON. If you want to customise how serialization happens, for instance
changing serialization parameters or using a different JSON library, you
can specify your own functions using the *note
psycopg.types.json.set_json_dumps(): 77. and *note set_json_loads(): 78.
functions, to apply either globally or to a specific context (connection
or cursor).

     from functools import partial
     from psycopg.types.json import Jsonb, set_json_dumps, set_json_loads
     import ujson

     # Use a faster dump function
     set_json_dumps(ujson.dumps)

     # Return floating point values as Decimal, just in one connection
     set_json_loads(partial(json.loads, parse_float=Decimal), conn)

     conn.execute("SELECT %s", [Jsonb({"value": 123.45})]).fetchone()[0]
     # {'value': Decimal('123.45')}

If you need an even more specific dump customisation only for certain
objects (including different configurations in the same query) you can
specify a ‘dumps’ parameter in the *note Json: 75./*note Jsonb: 76.
wrapper, which will take precedence over what is specified by
‘set_json_dumps()’.

     from uuid import UUID, uuid4

     class UUIDEncoder(json.JSONEncoder):
         """A JSON encoder which can dump UUID."""
         def default(self, obj):
             if isinstance(obj, UUID):
                 return str(obj)
             return json.JSONEncoder.default(self, obj)

     uuid_dumps = partial(json.dumps, cls=UUIDEncoder)
     obj = {"uuid": uuid4()}
     cnn.execute("INSERT INTO objs VALUES %s", [Json(obj, dumps=uuid_dumps)])
     # will insert: {'uuid': '0a40799d-3980-4c65-8315-2956b18ab0e1'}

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/datatype-json.html

   (2) https://docs.python.org/3/library/json.html#json.dumps

   (3) https://docs.python.org/3/library/json.html#json.loads


File: psycopg.info,  Node: Lists adaptation,  Next: UUID adaptation,  Prev: JSON adaptation,  Up: Adapting basic Python types

1.1.4.9 Lists adaptation
........................

Python list(1) objects are adapted to PostgreSQL arrays(2) and back.
Only lists containing objects of the same type can be dumped to
PostgreSQL (but the list may contain ‘None’ elements).

     Note: If you have a list of values which you want to use with the
     ‘IN’ operator… don’t.  It won’t work (neither with a list nor with
     a tuple):

          >>> conn.execute("SELECT * FROM mytable WHERE id IN %s", [[10,20,30]])
          Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
          psycopg.errors.SyntaxError: syntax error at or near "$1"
          LINE 1: SELECT * FROM mytable WHERE id IN $1
                                                    ^

     What you want to do instead is to use the '= ANY()' expression(3)
     and pass the values as a list (not a tuple).

          >>> conn.execute("SELECT * FROM mytable WHERE id = ANY(%s)", [[10,20,30]])

     This has also the advantage of working with an empty list, whereas
     ‘IN ()’ is not valid SQL.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#list

   (2) https://www.postgresql.org/docs/current/arrays.html

   (3) 
https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.30.16


File: psycopg.info,  Node: UUID adaptation,  Next: Network data types adaptation,  Prev: Lists adaptation,  Up: Adapting basic Python types

1.1.4.10 UUID adaptation
........................

Python uuid.UUID(1) objects are adapted to PostgreSQL UUID type(2) and
back:

     >>> conn.execute("select gen_random_uuid()").fetchone()[0]
     UUID('97f0dd62-3bd2-459e-89b8-a5e36ea3c16c')

     >>> from uuid import uuid4
     >>> conn.execute("select gen_random_uuid() = %s", [uuid4()]).fetchone()[0]
     False  # long shot

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/uuid.html#uuid.UUID

   (2) https://www.postgresql.org/docs/current/datatype-uuid.html


File: psycopg.info,  Node: Network data types adaptation,  Next: Enum adaptation,  Prev: UUID adaptation,  Up: Adapting basic Python types

1.1.4.11 Network data types adaptation
......................................

Objects from the ipaddress(1) module are converted to PostgreSQL network
address types(2):

   - IPv4Address(3), IPv4Interface(4) objects are converted to the
     PostgreSQL ‘inet’ type.  On the way back, ‘inet’ values indicating
     a single address are converted to ‘IPv4Address’, otherwise they are
     converted to ‘IPv4Interface’

   - IPv4Network(5) objects are converted to the ‘cidr’ type and back.

   - IPv6Address(6), IPv6Interface(7), IPv6Network(8) objects follow the
     same rules, with IPv6 ‘inet’ and ‘cidr’ values.

     >>> conn.execute("select '192.168.0.1'::inet, '192.168.0.1/24'::inet").fetchone()
     (IPv4Address('192.168.0.1'), IPv4Interface('192.168.0.1/24'))

     >>> conn.execute("select '::ffff:1.2.3.0/120'::cidr").fetchone()[0]
     IPv6Network('::ffff:102:300/120')

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/ipaddress.html#module-ipaddress

   (2) 
https://www.postgresql.org/docs/current/datatype-net-types.html#DATATYPE-CIDR

   (3) 
https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Address

   (4) 
https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Interface

   (5) 
https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network

   (6) 
https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Address

   (7) 
https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Interface

   (8) 
https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Network


File: psycopg.info,  Node: Enum adaptation,  Prev: Network data types adaptation,  Up: Adapting basic Python types

1.1.4.12 Enum adaptation
........................

Added in version 3.1.

Psycopg can adapt Python Enum(1) subclasses into PostgreSQL enum types
(created with the CREATE TYPE ...  AS ENUM (...)(2)  command).

In order to set up a bidirectional enum mapping, you should get
information about the PostgreSQL enum using the *note EnumInfo: 81.
class and register it using *note register_enum(): 82.  The behaviour of
unregistered and registered enums is different.

   - If the enum is not registered with ‘register_enum()’:

        - Pure ‘Enum’ classes are dumped as normal strings, using their
          member names as value.  The unknown oid is used, so PostgreSQL
          should be able to use this string in most contexts (such as an
          enum or a text field).

          Changed in version 3.1: In previous version dumping pure enums
          is not supported and raise a “cannot adapt” error.

        - Mix-in enums are dumped according to their mix-in type
          (because a ‘class MyIntEnum(int, Enum)’ is more specifically
          an ‘int’ than an ‘Enum’, so it’s dumped by default according
          to ‘int’ rules).

        - PostgreSQL enums are loaded as Python strings.  If you want to
          load arrays of such enums you will have to find their OIDs
          using *note types.TypeInfo.fetch(): 83. and register them
          using *note register(): 84.

   - If the enum is registered (using *note EnumInfo: 81.‘.fetch()’ and
     *note register_enum(): 82.):

        - Enums classes, both pure and mixed-in, are dumped by name.

        - The registered PostgreSQL enum is loaded back as the
          registered Python enum members.

 -- Class: psycopg.types.enum.EnumInfo (name: str, oid: int, array_oid:
          int, labels: Sequence[str])

     Manage information about an enum type.

     ‘EnumInfo’ is a subclass of *note TypeInfo: 85.: refer to the
     latter’s documentation for generic usage, especially the *note
     fetch(): 83. method.

      -- Attribute: labels

          After *note fetch(): 83, it contains the labels defined in the
          PostgreSQL enum type.

      -- Attribute: enum

          After *note register_enum(): 82. is called, it will contain
          the Python type mapping to the registered enum.

 -- Function: psycopg.types.enum.register_enum (info: EnumInfo, context:
          AdaptContext | None = None, enum: type[E] | None = None, *,
          mapping: EnumMapping[E] = None) -> None

     Register the adapters to load and dump a enum type.


     Parameters:

        * ‘info’ – The object with the information about the enum to
          register.

        * ‘context’ – The context where to register the adapters.  If
          ‘None’, register it globally.

        * ‘enum’ – Python enum type matching to the PostgreSQL one.  If
          ‘None’, a new enum will be generated and exposed as *note
          EnumInfo.enum: 87.

        * ‘mapping’ – Override the mapping between ‘enum’ members and
          ‘info’ labels.

     After registering, fetching data of the registered enum will cast
     PostgreSQL enum labels into corresponding Python enum members.

     If no ‘enum’ is specified, a new ‘Enum’ is created based on
     PostgreSQL enum labels.

Example:

     >>> from enum import Enum, auto
     >>> from psycopg.types.enum import EnumInfo, register_enum

     >>> class UserRole(Enum):
     ...     ADMIN = auto()
     ...     EDITOR = auto()
     ...     GUEST = auto()

     >>> conn.execute("CREATE TYPE user_role AS ENUM ('ADMIN', 'EDITOR', 'GUEST')")

     >>> info = EnumInfo.fetch(conn, "user_role")
     >>> register_enum(info, conn, UserRole)

     >>> some_editor = info.enum.EDITOR
     >>> some_editor
     <UserRole.EDITOR: 2>

     >>> conn.execute(
     ...     "SELECT pg_typeof(%(editor)s), %(editor)s",
     ...     {"editor": some_editor}
     ... ).fetchone()
     ('user_role', <UserRole.EDITOR: 2>)

     >>> conn.execute(
     ...     "SELECT ARRAY[%s, %s]",
     ...     [UserRole.ADMIN, UserRole.GUEST]
     ... ).fetchone()
     [<UserRole.ADMIN: 1>, <UserRole.GUEST: 3>]

If the Python and the PostgreSQL enum don’t match 1:1 (for instance if
members have a different name, or if more than one Python enum should
map to the same PostgreSQL enum, or vice versa), you can specify the
exceptions using the ‘mapping’ parameter.

‘mapping’ should be a dictionary with Python enum members as keys and
the matching PostgreSQL enum labels as values, or a list of ‘(member,
label)’ pairs with the same meaning (useful when some members are
repeated).  Order matters: if an element on either side is specified
more than once, the last pair in the sequence will take precedence:

     # Legacy roles, defined in medieval times.
     >>> conn.execute(
     ...     "CREATE TYPE abbey_role AS ENUM ('ABBOT', 'SCRIBE', 'MONK', 'GUEST')")

     >>> info = EnumInfo.fetch(conn, "abbey_role")
     >>> register_enum(info, conn, UserRole, mapping=[
     ...     (UserRole.ADMIN, "ABBOT"),
     ...     (UserRole.EDITOR, "SCRIBE"),
     ...     (UserRole.EDITOR, "MONK")])

     >>> conn.execute("SELECT '{ABBOT,SCRIBE,MONK,GUEST}'::abbey_role[]").fetchone()[0]
     [<UserRole.ADMIN: 1>,
      <UserRole.EDITOR: 2>,
      <UserRole.EDITOR: 2>,
      <UserRole.GUEST: 3>]

     >>> conn.execute("SELECT %s::text[]", [list(UserRole)]).fetchone()[0]
     ['ABBOT', 'MONK', 'GUEST']

A particularly useful case is when the PostgreSQL labels match the
'values' of a ‘str’-based Enum.  In this case it is possible to use
something like ‘{m: m.value for m in enum}’ as mapping:

     >>> class LowercaseRole(str, Enum):
     ...     ADMIN = "admin"
     ...     EDITOR = "editor"
     ...     GUEST = "guest"

     >>> conn.execute(
     ...     "CREATE TYPE lowercase_role AS ENUM ('admin', 'editor', 'guest')")

     >>> info = EnumInfo.fetch(conn, "lowercase_role")
     >>> register_enum(
     ...     info, conn, LowercaseRole, mapping={m: m.value for m in LowercaseRole})

     >>> conn.execute("SELECT 'editor'::lowercase_role").fetchone()[0]
     <LowercaseRole.EDITOR: 'editor'>

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/enum.html#enum.Enum

   (2) https://www.postgresql.org/docs/current/static/datatype-enum.html


File: psycopg.info,  Node: Adapting other PostgreSQL types,  Next: Transactions management,  Prev: Adapting basic Python types,  Up: Getting started with Psycopg 3

1.1.5 Adapting other PostgreSQL types
-------------------------------------

PostgreSQL offers other data types which don’t map to native Python
types.  Psycopg offers wrappers and conversion functions to allow their
use.

* Menu:

* Composite types casting::
* Range adaptation::
* Multirange adaptation::
* Hstore adaptation::
* Geometry adaptation using Shapely::


File: psycopg.info,  Node: Composite types casting,  Next: Range adaptation,  Up: Adapting other PostgreSQL types

1.1.5.1 Composite types casting
...............................

Psycopg can adapt PostgreSQL composite types (either created with the
CREATE TYPE(1) command or implicitly defined after a table row type) to
and from Python tuples, namedtuple(2), or any other suitable object
configured.

Before using a composite type it is necessary to get information about
it using the *note CompositeInfo: 8d. class and to register it using
*note register_composite(): 8e.

 -- Class: psycopg.types.composite.CompositeInfo (name: str, oid: int,
          array_oid: int, *, regtype: str = '', field_names:
          Sequence[str], field_types: Sequence[int])

     Manage information about a composite type.

     ‘CompositeInfo’ is a *note TypeInfo: 85. subclass: check its
     documentation for the generic usage, especially the *note fetch():
     83. method.

      -- Attribute: python_type

          After *note register_composite(): 8e. is called, it will
          contain the python type mapping to the registered composite.

 -- Function: psycopg.types.composite.register_composite (info:
          CompositeInfo, context: AdaptContext | None = None, factory:
          Callable[[...], Any] | None = None) -> None

     Register the adapters to load and dump a composite type.


     Parameters:

        * ‘info’ – The object with the information about the composite
          to register.

        * ‘context’ – The context where to register the adapters.  If
          ‘None’, register it globally.

        * ‘factory’ – Callable to convert the sequence of attributes
          read from the composite into a Python object.

          Note: Registering the adapters doesn’t affect objects already
          created, even if they are children of the registered context.
          For instance, registering the adapter globally doesn’t affect
          already existing connections.

     After registering, fetching data of the registered composite will
     invoke ‘factory’ to create corresponding Python objects.

     If no factory is specified, a ‘namedtuple’ is created and used to
     return data.

     If the ‘factory’ is a type (and not a generic callable), then
     dumpers for that type are created and registered too, so that
     passing objects of that type to a query will adapt them to the
     registered type.

Example:

     >>> from psycopg.types.composite import CompositeInfo, register_composite

     >>> conn.execute("CREATE TYPE card AS (value int, suit text)")

     >>> info = CompositeInfo.fetch(conn, "card")
     >>> register_composite(info, conn)

     >>> my_card = info.python_type(8, "hearts")
     >>> my_card
     card(value=8, suit='hearts')

     >>> conn.execute(
     ...     "SELECT pg_typeof(%(card)s), (%(card)s).suit", {"card": my_card}
     ...     ).fetchone()
     ('card', 'hearts')

     >>> conn.execute("SELECT (%s, %s)::card", [1, "spades"]).fetchone()[0]
     card(value=1, suit='spades')

Nested composite types are handled as expected, provided that the type
of the composite components are registered as well:

     >>> conn.execute("CREATE TYPE card_back AS (face card, back text)")

     >>> info2 = CompositeInfo.fetch(conn, "card_back")
     >>> register_composite(info2, conn)

     >>> conn.execute("SELECT ((8, 'hearts'), 'blue')::card_back").fetchone()[0]
     card_back(face=card(value=8, suit='hearts'), back='blue')

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/static/sql-createtype.html

   (2) 
https://docs.python.org/3/library/collections.html#collections.namedtuple


File: psycopg.info,  Node: Range adaptation,  Next: Multirange adaptation,  Prev: Composite types casting,  Up: Adapting other PostgreSQL types

1.1.5.2 Range adaptation
........................

PostgreSQL range types(1) are a family of data types representing a
range of values between two elements.  The type of the element is called
the range 'subtype'.  PostgreSQL offers a few built-in range types and
allows the definition of custom ones.

All the PostgreSQL range types are loaded as the *note Range: 92. Python
type, which is a Generic(2) type and can hold bounds of different types.

 -- Class: psycopg.types.range.Range (lower: T | None = None, upper: T |
          None = None, bounds: str = '[)', empty: bool = False)

     Python representation for a PostgreSQL range type.


     Parameters:

        * ‘lower’ – lower bound for the range.  ‘None’ means unbound

        * ‘upper’ – upper bound for the range.  ‘None’ means unbound

        * ‘bounds’ – one of the literal strings ‘()’, ‘[)’, ‘(]’, ‘[]’,
          representing whether the lower or upper bounds are included

        * ‘empty’ – if ‘True’, the range is empty

     This Python type is only used to pass and retrieve range values to
     and from PostgreSQL and doesn’t attempt to replicate the PostgreSQL
     range features: it doesn’t perform normalization and doesn’t
     implement all the operators(3) supported by the database.

     PostgreSQL will perform normalisation on ‘Range’ objects used as
     query parameters, so, when they are fetched back, they will be
     found in the normal form (for instance ranges on integers will have
     ‘[)’ bounds).

     ‘Range’ objects are immutable, hashable, and support the ‘in’
     operator (checking if an element is within the range).  They can be
     tested for equivalence.  Empty ranges evaluate to ‘False’ in a
     boolean context, nonempty ones evaluate to ‘True’.

     ‘Range’ objects have the following attributes:

      -- Attribute: isempty

          ‘True’ if the range is empty.

      -- Attribute: lower

          The lower bound of the range.  ‘None’ if empty or unbound.

      -- Attribute: upper

          The upper bound of the range.  ‘None’ if empty or unbound.

      -- Attribute: lower_inc

          ‘True’ if the lower bound is included in the range.

      -- Attribute: upper_inc

          ‘True’ if the upper bound is included in the range.

      -- Attribute: lower_inf

          ‘True’ if the range doesn’t have a lower bound.

      -- Attribute: upper_inf

          ‘True’ if the range doesn’t have an upper bound.

The built-in range objects are adapted automatically: if a ‘Range’
objects contains date(4) bounds, it is dumped using the ‘daterange’ OID,
and of course ‘daterange’ values are loaded back as ‘Range[date]’.

If you create your own range type you can use *note RangeInfo: 9a. and
*note register_range(): 9b. to associate the range type with its subtype
and make it work like the builtin ones.

 -- Class: psycopg.types.range.RangeInfo (name: str, oid: int,
          array_oid: int, *, regtype: str = '', subtype_oid: int)

     Manage information about a range type.

     ‘RangeInfo’ is a *note TypeInfo: 85. subclass: check its
     documentation for generic details, especially the *note fetch():
     83. method.

 -- Function: psycopg.types.range.register_range (info: RangeInfo,
          context: AdaptContext | None = None) -> None

     Register the adapters to load and dump a range type.


     Parameters:

        * ‘info’ – The object with the information about the range to
          register.

        * ‘context’ – The context where to register the adapters.  If
          ‘None’, register it globally.

     Register loaders so that loading data of this type will result in a
     *note Range: 92. with bounds parsed as the right subtype.

          Note: Registering the adapters doesn’t affect objects already
          created, even if they are children of the registered context.
          For instance, registering the adapter globally doesn’t affect
          already existing connections.

Example:

     >>> from psycopg.types.range import Range, RangeInfo, register_range

     >>> conn.execute("CREATE TYPE strrange AS RANGE (SUBTYPE = text)")
     >>> info = RangeInfo.fetch(conn, "strrange")
     >>> register_range(info, conn)

     >>> conn.execute("SELECT pg_typeof(%s)", [Range("a", "z")]).fetchone()[0]
     'strrange'

     >>> conn.execute("SELECT '[a,z]'::strrange").fetchone()[0]
     Range('a', 'z', '[]')

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/rangetypes.html

   (2) https://docs.python.org/3/library/typing.html#typing.Generic

   (3) 
https://www.postgresql.org/docs/current/static/functions-range.html#RANGE-OPERATORS-TABLE

   (4) https://docs.python.org/3/library/datetime.html#datetime.date


File: psycopg.info,  Node: Multirange adaptation,  Next: Hstore adaptation,  Prev: Range adaptation,  Up: Adapting other PostgreSQL types

1.1.5.3 Multirange adaptation
.............................

Since PostgreSQL 14, every range type is associated with a
multirange(1), a type representing a disjoint set of ranges.  A
multirange is automatically available for every range, built-in and
user-defined.

All the PostgreSQL range types are loaded as the *note Multirange: 9e.
Python type, which is a mutable sequence of *note Range: 92. elements.

 -- Class: psycopg.types.multirange.Multirange (items:
          Iterable[Range[T]] = ())

     Python representation for a PostgreSQL multirange type.


     Parameters: ‘items’ – Sequence of ranges to initialise the object.

     This Python type is only used to pass and retrieve multirange
     values to and from PostgreSQL and doesn’t attempt to replicate the
     PostgreSQL multirange features: overlapping items are not merged,
     empty ranges are not discarded, the items are not ordered, the
     behaviour of multirange operators(2) is not replicated in Python.

     PostgreSQL will perform normalisation on ‘Multirange’ objects used
     as query parameters, so, when they are fetched back, they will be
     found ordered, with overlapping ranges merged, etc.

     ‘Multirange’ objects are a MutableSequence(3) and are totally
     ordered: they behave pretty much like a list of ‘Range’.  Like
     Range, they are Generic(4) on the subtype of their range, so you
     can declare a variable to be ‘Multirange[date]’ and mypy will
     complain if you try to add it a ‘Range[Decimal]’.

Like for *note Range: 92, built-in multirange objects are adapted
automatically: if a ‘Multirange’ object contains ‘Range’ with date(5)
bounds, it is dumped using the ‘datemultirange’ OID, and
‘datemultirange’ values are loaded back as ‘Multirange[date]’.

If you have created your own range type you can use *note
MultirangeInfo: 9f. and *note register_multirange(): a0. to associate
the resulting multirange type with its subtype and make it work like the
builtin ones.

 -- Class: psycopg.types.multirange.MultirangeInfo (name: str, oid: int,
          array_oid: int, *, regtype: str = '', range_oid: int,
          subtype_oid: int)

     Manage information about a multirange type.

     ‘MultirangeInfo’ is a *note TypeInfo: 85. subclass: check its
     documentation for generic details, especially the *note fetch():
     83. method.

 -- Function: psycopg.types.multirange.register_multirange (info:
          MultirangeInfo, context: AdaptContext | None = None) -> None

     Register the adapters to load and dump a multirange type.


     Parameters:

        * ‘info’ – The object with the information about the range to
          register.

        * ‘context’ – The context where to register the adapters.  If
          ‘None’, register it globally.

     Register loaders so that loading data of this type will result in a
     ‘Range’ with bounds parsed as the right subtype.

          Note: Registering the adapters doesn’t affect objects already
          created, even if they are children of the registered context.
          For instance, registering the adapter globally doesn’t affect
          already existing connections.

Example:

     >>> from psycopg.types.multirange import \
     ...     Multirange, MultirangeInfo, register_multirange
     >>> from psycopg.types.range import Range

     >>> conn.execute("CREATE TYPE strrange AS RANGE (SUBTYPE = text)")
     >>> info = MultirangeInfo.fetch(conn, "strmultirange")
     >>> register_multirange(info, conn)

     >>> rec = conn.execute(
     ...     "SELECT pg_typeof(%(mr)s), %(mr)s",
     ...     {"mr": Multirange([Range("a", "q"), Range("l", "z")])}).fetchone()

     >>> rec[0]
     'strmultirange'
     >>> rec[1]
     Multirange([Range('a', 'z', '[)')])

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/rangetypes.html

   (2) 
https://www.postgresql.org/docs/current/static/functions-range.html#MULTIRANGE-OPERATORS-TABLE

   (3) 
https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence

   (4) https://docs.python.org/3/library/typing.html#typing.Generic

   (5) https://docs.python.org/3/library/datetime.html#datetime.date


File: psycopg.info,  Node: Hstore adaptation,  Next: Geometry adaptation using Shapely,  Prev: Multirange adaptation,  Up: Adapting other PostgreSQL types

1.1.5.4 Hstore adaptation
.........................

The hstore(1) data type is a key-value store embedded in PostgreSQL. It
supports GiST or GIN indexes allowing search by keys or key/value pairs
as well as regular BTree indexes for equality, uniqueness etc.

Psycopg can convert Python ‘dict’ objects to and from ‘hstore’
structures.  Only dictionaries with string keys and values are
supported.  ‘None’ is also allowed as value but not as a key.

In order to use the ‘hstore’ data type it is necessary to load it in a
database using:

     =# CREATE EXTENSION hstore;

Because ‘hstore’ is distributed as a contrib module, its oid is not well
known, so it is necessary to use ‘TypeInfo’.*note fetch(): 83. to query
the database and get its oid.  The resulting object can be passed to
*note register_hstore(): a3. to configure dumping ‘dict’ to ‘hstore’ and
parsing ‘hstore’ back to ‘dict’, in the context where the adapter is
registered.

 -- Function: psycopg.types.hstore.register_hstore (info: TypeInfo,
          context: AdaptContext | None = None) -> None

     Register the adapters to load and dump hstore.


     Parameters:

        * ‘info’ – The object with the information about the hstore
          type.

        * ‘context’ – The context where to register the adapters.  If
          ‘None’, register it globally.

          Note: Registering the adapters doesn’t affect objects already
          created, even if they are children of the registered context.
          For instance, registering the adapter globally doesn’t affect
          already existing connections.

Example:

     >>> from psycopg.types import TypeInfo
     >>> from psycopg.types.hstore import register_hstore

     >>> info = TypeInfo.fetch(conn, "hstore")
     >>> register_hstore(info, conn)

     >>> conn.execute("SELECT pg_typeof(%s)", [{"a": "b"}]).fetchone()[0]
     'hstore'

     >>> conn.execute("SELECT 'foo => bar'::hstore").fetchone()[0]
     {'foo': 'bar'}

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/static/hstore.html


File: psycopg.info,  Node: Geometry adaptation using Shapely,  Prev: Hstore adaptation,  Up: Adapting other PostgreSQL types

1.1.5.5 Geometry adaptation using Shapely
.........................................

When using the PostGIS(1) extension, it can be useful to retrieve
geometry(2) values and have them automatically converted to Shapely(3)
instances.  Likewise, you may want to store such instances in the
database and have the conversion happen automatically.

     Warning: Psycopg doesn’t have a dependency on the ‘shapely’
     package: you should install the library as an additional dependency
     of your project.

     Warning: This module is experimental and might be changed in the
     future according to users’ feedback.

Since PostgGIS is an extension, the ‘geometry’ type oid is not well
known, so it is necessary to use ‘TypeInfo’.*note fetch(): 83. to query
the database and find it.  The resulting object can be passed to *note
register_shapely(): a6. to configure dumping shape(4) instances to
‘geometry’ columns and parsing ‘geometry’ data back to ‘shape’
instances, in the context where the adapters are registered.

 -- Function: psycopg.types.shapely.register_shapely ()

     Register Shapely dumper and loaders.

     After invoking this function on an adapter, the queries retrieving
     PostGIS geometry objects will return Shapely’s shape object
     instances both in text and binary mode.

     Similarly, shape objects can be sent to the database.

     This requires the Shapely library to be installed.


     Parameters:

        * ‘info’ – The object with the information about the geometry
          type.

        * ‘context’ – The context where to register the adapters.  If
          ‘None’, register it globally.

          Note: Registering the adapters doesn’t affect objects already
          created, even if they are children of the registered context.
          For instance, registering the adapter globally doesn’t affect
          already existing connections.

Example:

     >>> from psycopg.types import TypeInfo
     >>> from psycopg.types.shapely import register_shapely
     >>> from shapely.geometry import Point

     >>> info = TypeInfo.fetch(conn, "geometry")
     >>> register_shapely(info, conn)

     >>> conn.execute("SELECT pg_typeof(%s)", [Point(1.2, 3.4)]).fetchone()[0]
     'geometry'

     >>> conn.execute("""
     ... SELECT ST_GeomFromGeoJSON('{
     ...     "type":"Point",
     ...     "coordinates":[-48.23456,20.12345]}')
     ... """).fetchone()[0]
     <shapely.geometry.multipolygon.MultiPolygon object at 0x7fb131f3cd90>

Notice that, if the geometry adapters are registered on a specific
object (a connection or cursor), other connections and cursors will be
unaffected:

     >>> conn2 = psycopg.connect(CONN_STR)
     >>> conn2.execute("""
     ... SELECT ST_GeomFromGeoJSON('{
     ...     "type":"Point",
     ...     "coordinates":[-48.23456,20.12345]}')
     ... """).fetchone()[0]
     '0101000020E61000009279E40F061E48C0F2B0506B9A1F3440'

   ---------- Footnotes ----------

   (1) https://postgis.net/

   (2) https://postgis.net/docs/geometry.html

   (3) https://github.com/Toblerity/Shapely

   (4) 
https://shapely.readthedocs.io/en/stable/manual.html#shapely.geometry.shape


File: psycopg.info,  Node: Transactions management,  Next: Using COPY TO and COPY FROM,  Prev: Adapting other PostgreSQL types,  Up: Getting started with Psycopg 3

1.1.6 Transactions management
-----------------------------

Psycopg has a behaviour that may seem surprising compared to ‘psql’: by
default, any database operation will start a new transaction.  As a
consequence, changes made by any cursor of the connection will not be
visible until *note Connection.commit(): 38. is called, and will be
discarded by *note Connection.rollback(): 39.  The following operation
on the same connection will start a new transaction.

If a database operation fails, the server will refuse further commands,
until a ‘rollback()’ is called.

If the connection is closed with a transaction open, no COMMIT command
is sent to the server, which will then discard the connection.  Certain
middleware (such as PgBouncer) will also discard a connection left in
transaction state, so, if possible you will want to commit or rollback a
connection before finishing working with it.

An example of what will happen, the first time you will use Psycopg (and
to be disappointed by it), is likely:

     conn = psycopg.connect()

     # Creating a cursor doesn't start a transaction or affect the connection
     # in any way.
     cur = conn.cursor()

     cur.execute("SELECT count(*) FROM my_table")
     # This function call executes:
     # - BEGIN
     # - SELECT count(*) FROM my_table
     # So now a transaction has started.

     # If your program spends a long time in this state, the server will keep
     # a connection "idle in transaction", which is likely something undesired

     cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
     # This statement is executed inside the transaction

     conn.close()
     # No COMMIT was sent: the INSERT was discarded.

There are a few things going wrong here, let’s see how they can be
improved.

One obvious problem after the run above is that, firing up ‘psql’, you
will see no new record in the table ‘data’.  One way to fix the problem
is to call ‘conn.commit()’ before closing the connection.  Thankfully,
if you use the *note connection context: 46, Psycopg will commit the
connection at the end of the block (or roll it back if the block is
exited with an exception):

The code modified using a connection context will result in the
following sequence of database statements:

     with psycopg.connect() as conn:

         cur = conn.cursor()

         cur.execute("SELECT count(*) FROM my_table")
         # This function call executes:
         # - BEGIN
         # - SELECT count(*) FROM my_table
         # So now a transaction has started.

         cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
         # This statement is executed inside the transaction

     # No exception at the end of the block:
     # COMMIT is executed.

This way we don’t have to remember to call neither ‘close()’ nor
‘commit()’ and the database operations actually have a persistent
effect.  The code might still do something you don’t expect: keep a
transaction from the first operation to the connection closure.  You can
have a finer control over the transactions using an *note autocommit
transaction: a9. and/or *note transaction contexts: aa.

     Warning: By default even a simple ‘SELECT’ will start a
     transaction: in long-running programs, if no further action is
     taken, the session will remain 'idle in transaction', an
     undesirable condition for several reasons (locks are held by the
     session, tables bloat…).  For long lived scripts, either make sure
     to terminate a transaction as soon as possible or use an *note
     autocommit: ab. connection.

     Hint: If a database operation fails with an error message such as
     'InFailedSqlTransaction: current transaction is aborted, commands
     ignored until end of transaction block', it means that 'a previous
     operation failed' and the database session is in a state of error.
     You need to call *note rollback(): 39. if you want to keep on using
     the same connection.

* Menu:

* Autocommit transactions::
* Transaction contexts::
* Transaction characteristics::
* Two-Phase Commit protocol support::


File: psycopg.info,  Node: Autocommit transactions,  Next: Transaction contexts,  Up: Transactions management

1.1.6.1 Autocommit transactions
...............................

The manual commit requirement can be suspended using *note autocommit:
ab, either as connection attribute or as *note connect(): 33. parameter.
This may be required to run operations that cannot be executed inside a
transaction, such as ‘CREATE DATABASE’, ‘VACUUM’, ‘CALL’ on stored
procedures(1) using transaction control.

With an autocommit transaction, the above sequence of operation results
in:

     with psycopg.connect(autocommit=True) as conn:

         cur = conn.cursor()

         cur.execute("SELECT count(*) FROM my_table")
         # This function call now only executes:
         # - SELECT count(*) FROM my_table
         # and no transaction starts.

         cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
         # The result of this statement is persisted immediately by the database

     # The connection is closed at the end of the block but, because it is not
     # in a transaction state, no COMMIT is executed.

An autocommit transaction behaves more as someone coming from ‘psql’
would expect.  This has a beneficial performance effect, because less
queries are sent and less operations are performed by the database.  The
statements, however, are not executed in an atomic transaction; if you
need to execute certain operations inside a transaction, you can achieve
that with an autocommit connection too, using an explicit *note
transaction block: aa.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/xproc.html


File: psycopg.info,  Node: Transaction contexts,  Next: Transaction characteristics,  Prev: Autocommit transactions,  Up: Transactions management

1.1.6.2 Transaction contexts
............................

A more transparent way to make sure that transactions are finalised at
the right time is to use ‘with’ *note Connection.transaction(): 47. to
create a transaction context.  When the context is entered, a
transaction is started; when leaving the context the transaction is
committed, or it is rolled back if an exception is raised inside the
block.

Continuing the example above, if you want to use an autocommit
connection but still wrap selected groups of commands inside an atomic
transaction, you can use a ‘transaction()’ context:

     with psycopg.connect(autocommit=True) as conn:

         cur = conn.cursor()

         cur.execute("SELECT count(*) FROM my_table")
         # The connection is autocommit, so no BEGIN executed.

         with conn.transaction():
             # BEGIN is executed, a transaction started

             cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))
             cur.execute("INSERT INTO times VALUES (now())")
             # These two operation run atomically in the same transaction

         # COMMIT is executed at the end of the block.
         # The connection is in idle state again.

     # The connection is closed at the end of the block.

Note that connection blocks can also be used with non-autocommit
connections: in this case you still need to pay attention to eventual
transactions started automatically.  If an operation starts an implicit
transaction, a ‘transaction()’ block will only manage *note a savepoint
sub-transaction: ae, leaving the caller to deal with the main
transaction, as explained in *note Transactions management: 42.:

     conn = psycopg.connect()

     cur = conn.cursor()

     cur.execute("SELECT count(*) FROM my_table")
     # This function call executes:
     # - BEGIN
     # - SELECT count(*) FROM my_table
     # So now a transaction has started.

     with conn.transaction():
         # The block starts with a transaction already open, so it will execute
         # - SAVEPOINT

         cur.execute("INSERT INTO data VALUES (%s)", ("Hello",))

     # The block was executing a sub-transaction so on exit it will only run:
     # - RELEASE SAVEPOINT
     # The transaction is still on.

     conn.close()
     # No COMMIT was sent: the INSERT was discarded.

If a ‘transaction()’ block starts when no transaction is active then it
will manage a proper transaction.  In essence, a transaction context
tries to leave a connection in the state it found it, and leaves you to
deal with the wider context.

     Hint: The interaction between non-autocommit transactions and
     transaction contexts is probably surprising.  Although the
     non-autocommit default is what’s demanded by the DBAPI, the
     personal preference of several experienced developers is to:

        - use a connection block: ‘with psycopg.connect(...) as conn’;

        - use an autocommit connection, either passing ‘autocommit=True’
          as ‘connect()’ parameter or setting the attribute
          ‘conn.autocommit = True’;

        - use ‘with conn.transaction()’ blocks to manage transactions
          only where needed.

* Menu:

* Nested transactions::


File: psycopg.info,  Node: Nested transactions,  Up: Transaction contexts

1.1.6.3 Nested transactions
...........................

Transaction blocks can be also nested (internal transaction blocks are
implemented using SAVEPOINT(1)): an exception raised inside an inner
block has a chance of being handled and not completely fail outer
operations.  The following is an example where a series of operations
interact with the database: operations are allowed to fail; at the end
we also want to store the number of operations successfully processed.

     with conn.transaction() as tx1:
         num_ok = 0
         for operation in operations:
             try:
                 with conn.transaction() as tx2:
                     unreliable_operation(conn, operation)
             except Exception:
                 logger.exception(f"{operation} failed")
             else:
                 num_ok += 1

         save_number_of_successes(conn, num_ok)

If ‘unreliable_operation()’ causes an error, including an operation
causing a database error, all its changes will be reverted.  The
exception bubbles up outside the block: in the example it is intercepted
by the ‘try’ so that the loop can complete.  The outermost block is
unaffected (unless other errors happen there).

You can also write code to explicitly roll back any currently active
transaction block, by raising the *note Rollback: b0. exception.  The
exception “jumps” to the end of a transaction block, rolling back its
transaction but allowing the program execution to continue from there.
By default the exception rolls back the innermost transaction block, but
any current block can be specified as the target.  In the following
example, a hypothetical ‘CancelCommand’ may stop the processing and
cancel any operation previously performed, but not entirely committed
yet.

     from psycopg import Rollback

     with conn.transaction() as outer_tx:
         for command in commands():
             with conn.transaction() as inner_tx:
                 if isinstance(command, CancelCommand):
                     raise Rollback(outer_tx)
                 process_command(command)

     # If `Rollback` is raised, it would propagate only up to this block,
     # and the program would continue from here with no exception.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/sql-savepoint.html


File: psycopg.info,  Node: Transaction characteristics,  Next: Two-Phase Commit protocol support,  Prev: Transaction contexts,  Up: Transactions management

1.1.6.4 Transaction characteristics
...................................

You can set transaction parameters(1) for the transactions that Psycopg
handles.  They affect the transactions started implicitly by
non-autocommit transactions and the ones started explicitly by *note
Connection.transaction(): 47. for both autocommit and non-autocommit
transactions.

     Warning: Transaction parameters *note don’t affect autocommit
     connections: b3, unless a ‘transaction()’ block is explicitly used.

Leaving these parameters as ‘None’ will use the server’s default
behaviour (which is controlled by server settings such as
default_transaction_isolation(2)).

In order to set these parameters you can use the connection attributes
*note isolation_level: b4, *note read_only: b5, *note deferrable: b6.
For async connections you must use the equivalent *note
set_isolation_level(): b7. method and similar.  The parameters can only
be changed if there isn’t a transaction already active on the
connection.

Added in version 3.2: Added methods equivalent to setting the properties
(such as *note set_isolation_level(): b8.) on sync connections too.

     Warning: Applications running at *note REPEATABLE_READ: b9. or
     *note SERIALIZABLE: ba. isolation level are exposed to
     serialization failures.  In certain concurrent update cases(3),
     PostgreSQL will raise an exception looking like:

          psycopg2.errors.SerializationFailure: could not serialize access
          due to concurrent update

     In this case the application must be prepared to repeat the
     operation that caused the exception.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/sql-set-transaction.html

   (2) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-ISOLATION

   (3) 
https://www.postgresql.org/docs/current/transaction-iso.html#XACT-REPEATABLE-READ


File: psycopg.info,  Node: Two-Phase Commit protocol support,  Prev: Transaction characteristics,  Up: Transactions management

1.1.6.5 Two-Phase Commit protocol support
.........................................

Added in version 3.1.

Psycopg exposes the two-phase commit features available in PostgreSQL
implementing the two-phase commit extensions(1) proposed by the DBAPI.

The DBAPI model of two-phase commit is inspired by the XA
specification(2), according to which transaction IDs are formed from
three components:

   - a format ID (non-negative 32 bit integer)

   - a global transaction ID (string not longer than 64 bytes)

   - a branch qualifier (string not longer than 64 bytes)

For a particular global transaction, the first two components will be
the same for all the resources.  Every resource will be assigned a
different branch qualifier.

According to the DBAPI specification, a transaction ID is created using
the *note Connection.xid(): bd. method.  Once you have a transaction id,
a distributed transaction can be started with *note
Connection.tpc_begin(): be, prepared using *note tpc_prepare(): bf. and
completed using *note tpc_commit(): c0. or *note tpc_rollback(): c1.
Transaction IDs can also be retrieved from the database using *note
tpc_recover(): c2. and completed using the above ‘tpc_commit()’ and
‘tpc_rollback()’.

PostgreSQL doesn’t follow the XA standard though, and the ID for a
PostgreSQL prepared transaction can be any string up to 200 characters
long.  Psycopg’s *note Xid: c3. objects can represent both XA-style
transactions IDs (such as the ones created by the ‘xid()’ method) and
PostgreSQL transaction IDs identified by an unparsed string.

The format in which the Xids are converted into strings passed to the
database is the same employed by the PostgreSQL JDBC driver(3): this
should allow interoperation between tools written in Python and in Java.
For example a recovery tool written in Python would be able to recognize
the components of transactions produced by a Java program.

For further details see the documentation for the *note Two-Phase Commit
support methods: c4.

   ---------- Footnotes ----------

   (1) 
https://www.python.org/dev/peps/pep-0249/#optional-two-phase-commit-extensions

   (2) https://publications.opengroup.org/c193

   (3) https://jdbc.postgresql.org/


File: psycopg.info,  Node: Using COPY TO and COPY FROM,  Next: Differences from psycopg2,  Prev: Transactions management,  Up: Getting started with Psycopg 3

1.1.7 Using COPY TO and COPY FROM
---------------------------------

Psycopg allows to operate with PostgreSQL COPY protocol(1).  ‘COPY’ is
one of the most efficient ways to load data into the database (and to
modify it, with some SQL creativity).

Copy is supported using the *note Cursor.copy(): c8. method, passing it
a query of the form ‘COPY ... FROM STDIN’ or ‘COPY ... TO STDOUT’, and
managing the resulting *note Copy: c9. object in a ‘with’ block:

     with cursor.copy("COPY table_name (col1, col2) FROM STDIN") as copy:
         # pass data to the 'copy' object using write()/write_row()

You can compose a COPY statement dynamically by using objects from the
*note psycopg.sql: 9. module:

     with cursor.copy(
         sql.SQL("COPY {} TO STDOUT").format(sql.Identifier("table_name"))
     ) as copy:
         # read data from the 'copy' object using read()/read_row()

Changed in version 3.1: You can also pass parameters to ‘copy()’, like
in *note execute(): 3a.:

     with cur.copy("COPY (SELECT * FROM table_name LIMIT %s) TO STDOUT", (3,)) as copy:
         # expect no more than three records

The connection is subject to the usual transaction behaviour, so, unless
the connection is in autocommit, at the end of the COPY operation you
will still have to commit the pending changes and you can still roll
them back.  See *note Transactions management: 42. for details.

* Menu:

* Writing data row-by-row::
* Reading data row-by-row::
* Copying block-by-block::
* Binary copy::
* Asynchronous copy support::
* Example; copying a table across servers: Example copying a table across servers.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/sql-copy.html


File: psycopg.info,  Node: Writing data row-by-row,  Next: Reading data row-by-row,  Up: Using COPY TO and COPY FROM

1.1.7.1 Writing data row-by-row
...............................

Using a copy operation you can load data into the database from any
Python iterable (a list of tuples, or any iterable of sequences): the
Python values are adapted as they would be in normal querying.  To
perform such operation use a ‘COPY ... FROM STDIN’ with *note
Cursor.copy(): c8. and use *note write_row(): cc. on the resulting
object in a ‘with’ block.  On exiting the block the operation will be
concluded:

     records = [(10, 20, "hello"), (40, None, "world")]

     with cursor.copy("COPY sample (col1, col2, col3) FROM STDIN") as copy:
         for record in records:
             copy.write_row(record)

If an exception is raised inside the block, the operation is interrupted
and the records inserted so far are discarded.

In order to read or write from ‘Copy’ row-by-row you must not specify
‘COPY’ options such as ‘FORMAT CSV’, ‘DELIMITER’, ‘NULL’: please leave
these details alone, thank you :)


File: psycopg.info,  Node: Reading data row-by-row,  Next: Copying block-by-block,  Prev: Writing data row-by-row,  Up: Using COPY TO and COPY FROM

1.1.7.2 Reading data row-by-row
...............................

You can also do the opposite, reading rows out of a ‘COPY ... TO STDOUT’
operation, by iterating on *note rows(): cf.  However this is not
something you may want to do normally: usually the normal query process
will be easier to use.

PostgreSQL, currently, doesn’t give complete type information on ‘COPY
TO’, so the rows returned will have unparsed data, as strings or bytes,
according to the format.

     with cur.copy("COPY (VALUES (10::int, current_date)) TO STDOUT") as copy:
         for row in copy.rows():
             print(row)  # return unparsed data: ('10', '2046-12-24')

You can improve the results by using *note set_types(): d0. before
reading, but you have to specify them yourself.

     with cur.copy("COPY (VALUES (10::int, current_date)) TO STDOUT") as copy:
         copy.set_types(["int4", "date"])
         for row in copy.rows():
             print(row)  # (10, datetime.date(2046, 12, 24))


File: psycopg.info,  Node: Copying block-by-block,  Next: Binary copy,  Prev: Reading data row-by-row,  Up: Using COPY TO and COPY FROM

1.1.7.3 Copying block-by-block
..............................

If data is already formatted in a way suitable for copy (for instance
because it is coming from a file resulting from a previous ‘COPY TO’
operation) it can be loaded into the database using *note Copy.write():
d3. instead.

     with open("data", "r") as f:
         with cursor.copy("COPY data FROM STDIN") as copy:
             while data := f.read(BLOCK_SIZE):
                 copy.write(data)

In this case you can use any ‘COPY’ option and format, as long as the
input data is compatible with what the operation in ‘copy()’ expects.
Data can be passed as ‘str’, if the copy is in ‘FORMAT TEXT’, or as
‘bytes’, which works with both ‘FORMAT TEXT’ and ‘FORMAT BINARY’.

In order to produce data in ‘COPY’ format you can use a ‘COPY ... TO
STDOUT’ statement and iterate over the resulting *note Copy: c9. object,
which will produce a stream of ‘bytes’ objects:

     with open("data.out", "wb") as f:
         with cursor.copy("COPY table_name TO STDOUT") as copy:
             for data in copy:
                 f.write(data)


File: psycopg.info,  Node: Binary copy,  Next: Asynchronous copy support,  Prev: Copying block-by-block,  Up: Using COPY TO and COPY FROM

1.1.7.4 Binary copy
...................

Binary copy is supported by specifying ‘FORMAT BINARY’ in the ‘COPY’
statement.  In order to import binary data using *note write_row(): cc,
all the types passed to the database must have a binary dumper
registered; this is not necessary if the data is copied *note
block-by-block: d1. using *note write(): d3.

     Warning: PostgreSQL is particularly finicky when loading data in
     binary mode and will apply 'no cast rules'.  This means, for
     example, that passing the value 100 to an ‘integer’ column 'will
     fail', because Psycopg will pass it as a ‘smallint’ value, and the
     server will reject it because its size doesn’t match what expected.

     You can work around the problem using the *note set_types(): d0.
     method of the ‘Copy’ object and specifying carefully the types to
     load.

See also
........

See *note Binary parameters and results: 14. for further info about
binary querying.


File: psycopg.info,  Node: Asynchronous copy support,  Next: Example copying a table across servers,  Prev: Binary copy,  Up: Using COPY TO and COPY FROM

1.1.7.5 Asynchronous copy support
.................................

Asynchronous operations are supported using the same patterns as above,
using the objects obtained by an *note AsyncConnection: 4a.  For
instance, if ‘f’ is an object supporting an asynchronous ‘read()’ method
returning ‘COPY’ data, a fully-async copy operation could be:

     async with cursor.copy("COPY data FROM STDIN") as copy:
         while data := await f.read():
             await copy.write(data)

The *note AsyncCopy: d8. object documentation describes the signature of
the asynchronous methods and the differences from its sync *note Copy:
c9. counterpart.

See also
........

See *note Asynchronous operations: d. for further info about using async
objects.


File: psycopg.info,  Node: Example copying a table across servers,  Prev: Asynchronous copy support,  Up: Using COPY TO and COPY FROM

1.1.7.6 Example: copying a table across servers
...............................................

In order to copy a table, or a portion of a table, across servers, you
can use two COPY operations on two different connections, reading from
the first and writing to the second.

     with psycopg.connect(dsn_src) as conn1, psycopg.connect(dsn_tgt) as conn2:
         with conn1.cursor().copy("COPY src TO STDOUT (FORMAT BINARY)") as copy1:
             with conn2.cursor().copy("COPY tgt FROM STDIN (FORMAT BINARY)") as copy2:
                 for data in copy1:
                     copy2.write(data)

Using ‘FORMAT BINARY’ usually gives a performance boost, but it only
works if the source and target schema are 'perfectly identical'.  If the
tables are only 'compatible' (for example, if you are copying an
‘integer’ field into a ‘bigint’ destination field) you should omit the
‘BINARY’ option and perform a text-based copy.  See *note Binary copy:
d5. for details.

The same pattern can be adapted to use *note async objects: d. in order
to perform an *note async copy: d7.


File: psycopg.info,  Node: Differences from psycopg2,  Prev: Using COPY TO and COPY FROM,  Up: Getting started with Psycopg 3

1.1.8 Differences from ‘psycopg2’
---------------------------------

Psycopg 3 uses the common DBAPI structure of many other database
adapters and tries to behave as close as possible to ‘psycopg2’.  There
are however a few differences to be aware of.

     Tip: Most of the times, the workarounds suggested here will work
     with both Psycopg 2 and 3, which could be useful if you are porting
     a program or writing a program that should work with both Psycopg 2
     and 3.

* Menu:

* Server-side binding::
* Extended query Protocol::
* Multiple statements in the same query::
* Multiple results returned from multiple statements::
* Different cast rules::
* You cannot use IN %s with a tuple::
* You cannot use IS %s::
* Cursors subclasses::
* Different adaptation system::
* Copy is no longer file-based::
* with connection::
* callproc() is gone: callproc is gone.
* client_encoding is gone::
* Transaction characteristics attributes don’t affect autocommit sessions::
* No default infinity dates handling::
* What’s new in Psycopg 3::


File: psycopg.info,  Node: Server-side binding,  Next: Extended query Protocol,  Up: Differences from psycopg2

1.1.8.1 Server-side binding
...........................

Psycopg 3 sends the query and the parameters to the server separately,
instead of merging them on the client side.  Server-side binding works
for normal ‘SELECT’ and data manipulation statements (‘INSERT’,
‘UPDATE’, ‘DELETE’), but it doesn’t work with many other statements.
For instance, it doesn’t work with ‘SET’ or with ‘NOTIFY’:

     >>> conn.execute("SET TimeZone TO %s", ["UTC"])
     Traceback (most recent call last):
     ...
     psycopg.errors.SyntaxError: syntax error at or near "$1"
     LINE 1: SET TimeZone TO $1
                             ^

     >>> conn.execute("NOTIFY %s, %s", ["chan", 42])
     Traceback (most recent call last):
     ...
     psycopg.errors.SyntaxError: syntax error at or near "$1"
     LINE 1: NOTIFY $1, $2
                    ^

and with any data definition statement:

     >>> conn.execute("CREATE TABLE foo (id int DEFAULT %s)", [42])
     Traceback (most recent call last):
     ...
     psycopg.errors.UndefinedParameter: there is no parameter $1
     LINE 1: CREATE TABLE foo (id int DEFAULT $1)
                                              ^

Sometimes, PostgreSQL offers an alternative: for instance the
set_config()(1) function can be used instead of the ‘SET’ statement, the
pg_notify()(2) function can be used instead of ‘NOTIFY’:

     >>> conn.execute("SELECT set_config('TimeZone', %s, false)", ["UTC"])

     >>> conn.execute("SELECT pg_notify(%s, %s)", ["chan", "42"])

If this is not possible, you must merge the query and the parameter on
the client side.  You can do so using the *note psycopg.sql: 9. objects:

     >>> from psycopg import sql

     >>> cur.execute(sql.SQL("CREATE TABLE foo (id int DEFAULT {})").format(42))

or creating a *note client-side binding cursor: dd. such as *note
ClientCursor: de.:

     >>> cur = ClientCursor(conn)
     >>> cur.execute("CREATE TABLE foo (id int DEFAULT %s)", [42])

If you need ‘ClientCursor’ often, you can set the *note
Connection.cursor_factory: df. to have them created by default by *note
Connection.cursor(): 37.  This way, Psycopg 3 will behave largely the
same way of Psycopg 2.

Note that, both server-side and client-side, you can only specify
'values' as parameters (i.e.  'the strings that go in single quotes').
If you need to parametrize different parts of a statement (such as a
table name), you must use the *note psycopg.sql: 9. module:

     >>> from psycopg import sql

     # This will quote the user and the password using the right quotes
     # e.g.: ALTER USER "foo" SET PASSWORD 'bar'
     >>> conn.execute(
     ...     sql.SQL("ALTER USER {} SET PASSWORD {}")
     ...     .format(sql.Identifier(username), password))

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-SET

   (2) 
https://www.postgresql.org/docs/current/sql-notify.html#id-1.9.3.157.7.5


File: psycopg.info,  Node: Extended query Protocol,  Next: Multiple statements in the same query,  Prev: Server-side binding,  Up: Differences from psycopg2

1.1.8.2 Extended query Protocol
...............................

In order to use *note Server-side binding: 11, psycopg normally uses the
extended query protocol(1) to communicate with the backend.

In certain context outside pure PostgreSQL, the extended query protocol
is not supported, for instance to query the PgBouncer admin console(2).
In this case you should probably use a *note ClientCursor: de.  See
*note Simple query protocol: e2. for details.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY

   (2) https://www.pgbouncer.org/usage.html#admin-console


File: psycopg.info,  Node: Multiple statements in the same query,  Next: Multiple results returned from multiple statements,  Prev: Extended query Protocol,  Up: Differences from psycopg2

1.1.8.3 Multiple statements in the same query
.............................................

As a consequence of using *note server-side bindings: 11, when
parameters are used, it is not possible to execute several statements in
the same ‘execute()’ call, separating them by semicolon:

     >>> conn.execute(
     ...     "INSERT INTO foo VALUES (%s); INSERT INTO foo VALUES (%s)",
     ...     (10, 20))
     Traceback (most recent call last):
     ...
     psycopg.errors.SyntaxError: cannot insert multiple commands into a prepared statement

One obvious way to work around the problem is to use several ‘execute()’
calls.

'There is no such limitation if no parameters are used'.  As a
consequence, you can compose a multiple query on the client side and run
them all in the same ‘execute()’ call, using the *note psycopg.sql: 9.
objects:

     >>> from psycopg import sql
     >>> conn.execute(
     ...     sql.SQL("INSERT INTO foo VALUES ({}); INSERT INTO foo values ({})"
     ...     .format(10, 20))

or a *note client-side binding cursor: dd.:

     >>> cur = psycopg.ClientCursor(conn)
     >>> cur.execute(
     ...     "INSERT INTO foo VALUES (%s); INSERT INTO foo VALUES (%s)",
     ...     (10, 20))

     Warning: If a statement must be executed outside a transaction
     (such as ‘CREATE DATABASE’), it cannot be executed in batch with
     other statements, even if the connection is in autocommit mode:

          >>> conn.autocommit = True
          >>> conn.execute("CREATE DATABASE foo; SELECT 1")
          Traceback (most recent call last):
          ...
          psycopg.errors.ActiveSqlTransaction: CREATE DATABASE cannot run inside a transaction block

     This happens because PostgreSQL itself will wrap multiple
     statements in a transaction.  Note that you will experience a
     different behaviour in ‘psql’ (‘psql’ will split the queries on
     semicolons and send them to the server separately).

     This is not new in Psycopg 3: the same limitation is present in
     ‘psycopg2’ too.


File: psycopg.info,  Node: Multiple results returned from multiple statements,  Next: Different cast rules,  Prev: Multiple statements in the same query,  Up: Differences from psycopg2

1.1.8.4 Multiple results returned from multiple statements
..........................................................

If more than one statement returning results is executed in psycopg2,
only the result of the last statement is returned:

     >>> cur_pg2.execute("SELECT 1; SELECT 2")
     >>> cur_pg2.fetchone()
     (2,)

In Psycopg 3 instead, all the results are available.  After running the
query, the first result will be readily available in the cursor and can
be consumed using the usual ‘fetch*()’ methods.  In order to access the
following results, you can use the *note Cursor.nextset(): e7. method:

     >>> cur_pg3.execute("SELECT 1; SELECT 2")
     >>> cur_pg3.fetchone()
     (1,)

     >>> cur_pg3.nextset()
     True
     >>> cur_pg3.fetchone()
     (2,)

     >>> cur_pg3.nextset()
     None  # no more results

Remember though that you cannot use server-side bindings to *note
execute more than one statement in the same query: e3, if you are
passing parameters to the query.


File: psycopg.info,  Node: Different cast rules,  Next: You cannot use IN %s with a tuple,  Prev: Multiple results returned from multiple statements,  Up: Differences from psycopg2

1.1.8.5 Different cast rules
............................

In rare cases, especially around variadic functions, PostgreSQL might
fail to find a function candidate for the given data types:

     >>> conn.execute("SELECT json_build_array(%s, %s)", ["foo", "bar"])
     Traceback (most recent call last):
     ...
     psycopg.errors.IndeterminateDatatype: could not determine data type of parameter $1

This can be worked around specifying the argument types explicitly via a
cast:

     >>> conn.execute("SELECT json_build_array(%s::text, %s::text)", ["foo", "bar"])


File: psycopg.info,  Node: You cannot use IN %s with a tuple,  Next: You cannot use IS %s,  Prev: Different cast rules,  Up: Differences from psycopg2

1.1.8.6 You cannot use ‘IN %s’ with a tuple
...........................................

‘IN’ cannot be used with a tuple as single parameter, as was possible
with ‘psycopg2’:

     >>> conn.execute("SELECT * FROM foo WHERE id IN %s", [(10,20,30)])
     Traceback (most recent call last):
     ...
     psycopg.errors.SyntaxError: syntax error at or near "$1"
     LINE 1: SELECT * FROM foo WHERE id IN $1
                                           ^

What you can do is to use the = ANY()(1) construct and pass the
candidate values as a list instead of a tuple, which will be adapted to
a PostgreSQL array:

     >>> conn.execute("SELECT * FROM foo WHERE id = ANY(%s)", [[10,20,30]])

Note that ‘ANY()’ can be used with ‘psycopg2’ too, and has the advantage
of accepting an empty list of values too as argument, which is not
supported by the ‘IN’ operator instead.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.30.16


File: psycopg.info,  Node: You cannot use IS %s,  Next: Cursors subclasses,  Prev: You cannot use IN %s with a tuple,  Up: Differences from psycopg2

1.1.8.7 You cannot use ‘IS %s’
..............................

You cannot use ‘IS %s’ or ‘IS NOT %s’:

     >>> conn.execute("SELECT * FROM foo WHERE field IS %s", [None])
     Traceback (most recent call last):
     ...
     psycopg.errors.SyntaxError: syntax error at or near "$1"
     LINE 1: SELECT * FROM foo WHERE field IS $1
                                          ^

This is probably caused by the fact that ‘IS’ is not a binary predicate
in PostgreSQL; rather, ‘IS NULL’ and ‘IS NOT NULL’ are unary predicates
and you cannot use ‘IS’ with anything else on the right hand side.
Testing in psql:

     =# SELECT 10 IS 10;
     ERROR:  syntax error at or near "10"
     LINE 1: SELECT 10 IS 10;
                          ^

What you can do is to use IS [NOT] DISTINCT FROM(1) predicate instead:
‘IS NOT DISTINCT FROM %s’ can be used in place of ‘IS %s’ (please pay
attention to the awkwardly reversed ‘NOT’):

     >>> conn.execute("SELECT * FROM foo WHERE field IS NOT DISTINCT FROM %s", [None])

Analogously you can use ‘IS DISTINCT FROM %s’ as a parametric version of
‘IS NOT %s’.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/functions-comparison.html


File: psycopg.info,  Node: Cursors subclasses,  Next: Different adaptation system,  Prev: You cannot use IS %s,  Up: Differences from psycopg2

1.1.8.8 Cursors subclasses
..........................

In ‘psycopg2’, a few cursor subclasses allowed to return data in
different form than tuples.  In Psycopg 3 the same can be achieved by
setting a *note row factory: 4d.:

   - instead of RealDictCursor(1) you can use *note dict_row: f0.;

   - instead of NamedTupleCursor(2) you can use *note namedtuple_row:
     f1.

Other row factories are available in the *note psycopg.rows: 8. module.
There isn’t an object behaving like DictCursor(3) (whose results are
indexable both by column position and by column name).

     from psycopg.rows import dict_row, namedtuple_row

     # By default, every cursor will return dicts.
     conn = psycopg.connect(DSN, row_factory=dict_row)

     # You can set a row factory on a single cursor too.
     cur = conn.cursor(row_factory=namedtuple_row)

   ---------- Footnotes ----------

   (1) 
https://www.psycopg.org/docs/extras.html#psycopg2.extras.RealDictCursor

   (2) 
https://www.psycopg.org/docs/extras.html#psycopg2.extras.NamedTupleCursor

   (3) 
https://www.psycopg.org/docs/extras.html#psycopg2.extras.DictCursor


File: psycopg.info,  Node: Different adaptation system,  Next: Copy is no longer file-based,  Prev: Cursors subclasses,  Up: Differences from psycopg2

1.1.8.9 Different adaptation system
...................................

The adaptation system has been completely rewritten, in order to address
server-side parameters adaptation, but also to consider performance,
flexibility, ease of customization.

The default behaviour with builtin data should be *note what you would
expect: 41.  If you have customised the way to adapt data, or if you are
managing your own extension types, you should look at the *note new
adaptation system: 4e.

See also
........

   - *note Adapting basic Python types: 41. for the basic behaviour.

   - *note Data adaptation configuration: 4e. for more advanced use.


File: psycopg.info,  Node: Copy is no longer file-based,  Next: with connection,  Prev: Different adaptation system,  Up: Differences from psycopg2

1.1.8.10 Copy is no longer file-based
.....................................

‘psycopg2’ exposes a few copy methods(1) to interact with PostgreSQL
‘COPY’.  Their file-based interface doesn’t make it easy to load
dynamically-generated data into a database.

There is now a single *note copy(): c8. method, which is similar to
‘psycopg2’ ‘copy_expert()’ in accepting a free-form ‘COPY’ command and
returns an object to read/write data, block-wise or record-wise.  The
different usage pattern also enables ‘COPY’ to be used in async
interactions.

See also
........

See *note Using COPY TO and COPY FROM: e. for the details.

   ---------- Footnotes ----------

   (1) https://www.psycopg.org/docs/usage.html#copy


File: psycopg.info,  Node: with connection,  Next: callproc is gone,  Prev: Copy is no longer file-based,  Up: Differences from psycopg2

1.1.8.11 ‘with’ connection
..........................

In ‘psycopg2’, using the syntax with connection(1), only the transaction
is closed, not the connection.  This behaviour is surprising for people
used to several other Python classes wrapping resources, such as files.

In Psycopg 3, using *note with connection: 46. will close the connection
at the end of the ‘with’ block, making handling the connection resources
more familiar.

In order to manage transactions as blocks you can use the *note
Connection.transaction(): 47. method, which allows for finer control,
for instance to use nested transactions.

See also
........

See *note Transaction contexts: aa. for details.

   ---------- Footnotes ----------

   (1) https://www.psycopg.org/docs/usage.html#with


File: psycopg.info,  Node: callproc is gone,  Next: client_encoding is gone,  Prev: with connection,  Up: Differences from psycopg2

1.1.8.12 ‘callproc()’ is gone
.............................

‘cursor.callproc()’ is not implemented.  The method has a simplistic
semantic which doesn’t account for PostgreSQL positional parameters,
procedures, set-returning functions… Use a normal *note execute(): 3a.
with ‘SELECT function_name(...)’ or ‘CALL procedure_name(...)’ instead.


File: psycopg.info,  Node: client_encoding is gone,  Next: Transaction characteristics attributes don’t affect autocommit sessions,  Prev: callproc is gone,  Up: Differences from psycopg2

1.1.8.13 ‘client_encoding’ is gone
..................................

Psycopg automatically uses the database client encoding to decode data
to Unicode strings.  Use *note ConnectionInfo.encoding: 67. if you need
to read the encoding.  You can select an encoding at connection time
using the ‘client_encoding’ connection parameter and you can change the
encoding of a connection by running a ‘SET client_encoding’ statement…
But why would you?


File: psycopg.info,  Node: Transaction characteristics attributes don’t affect autocommit sessions,  Next: No default infinity dates handling,  Prev: client_encoding is gone,  Up: Differences from psycopg2

1.1.8.14 Transaction characteristics attributes don’t affect autocommit sessions
................................................................................

*note Transactions characteristics attributes: b2. such as *note
read_only: b5. don’t affect automatically autocommit sessions: they only
affect the implicit transactions started by non-autocommit sessions and
the transactions created by the *note transaction(): 47. block (for both
autocommit and non-autocommit connections).

If you want to put an autocommit transaction in read-only mode, please
use the default_transaction_read_only(1) GUC, for instance executing the
statement ‘SET default_transaction_read_only TO true’.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-READ-ONLY


File: psycopg.info,  Node: No default infinity dates handling,  Next: What’s new in Psycopg 3,  Prev: Transaction characteristics attributes don’t affect autocommit sessions,  Up: Differences from psycopg2

1.1.8.15 No default infinity dates handling
...........................................

PostgreSQL can represent a much wider range of dates and timestamps than
Python.  While Python dates are limited to the years between 1 and 9999
(represented by constants such as datetime.date.min(1) and max(2)),
PostgreSQL dates extend to BC dates and past the year 10K. Furthermore
PostgreSQL can also represent symbolic dates “infinity”, in both
directions.

In psycopg2, by default, infinity dates and timestamps map to
'date.max'(3) and similar constants.  This has the problem of creating a
non-bijective mapping (two Postgres dates, infinity and 9999-12-31, both
map to the same Python date).  There is also the perversity that valid
Postgres dates, greater than Python ‘date.max’ but arguably lesser than
infinity, will still overflow.

In Psycopg 3, every date greater than year 9999 will overflow, including
infinity.  If you would like to customize this mapping (for instance
flattening every date past Y10K on ‘date.max’) you can subclass and
adapt the appropriate loaders: take a look at *note this example: 70. to
see how.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/datetime.html#datetime.date.min

   (2) https://docs.python.org/3/library/datetime.html#datetime.date.max

   (3) https://www.psycopg.org/docs/usage.html#infinite-dates-handling


File: psycopg.info,  Node: What’s new in Psycopg 3,  Prev: No default infinity dates handling,  Up: Differences from psycopg2

1.1.8.16 What’s new in Psycopg 3
................................

   - *note Asynchronous support: d.

   - *note Server-side parameters binding: 11.

   - *note Prepared statements: 12.

   - *note Binary communication: 14.

   - *note Python-based COPY support: e.

   - *note Support for static typing: 10.

   - *note A redesigned connection pool: f.

   - *note Direct access to the libpq functionalities: 15.


File: psycopg.info,  Node: More advanced topics,  Next: Psycopg 3 API,  Prev: Getting started with Psycopg 3,  Up: Documentation

1.2 More advanced topics
========================

Once you have familiarised yourself with the *note Psycopg basic
operations: 1a, you can take a look at the chapter of this section for
more advanced usages.

* Menu:

* Concurrent operations::
* Static Typing::
* Row factories::
* Connection pools::
* Cursor types::
* Data adaptation configuration::
* Prepared statements::
* Pipeline mode support::


File: psycopg.info,  Node: Concurrent operations,  Next: Static Typing,  Up: More advanced topics

1.2.1 Concurrent operations
---------------------------

Psycopg allows to write 'concurrent' code, executing more than one
operation at time.

   - *note Connection: 34. objects 'are thread-safe': more than one
     thread at time can use the same connection.  Different thread can
     use the same connection by creating different cursors.

   - *note Cursor: 36. objects 'are not thread-safe', and are not
     designed to be used by several threads at the same time.  However,
     cursors are lightweight objects: different threads can create each
     one its own cursor to use independently from other threads.

     Note: All the cursors that share the same connection 'will also
     share the same transaction'.  This means that, if a thread starts a
     transaction, every cursor on the same connection will execute their
     queries in the same transaction and, if one thread causes a
     database server error, all the other cursors will be in error state
     until transaction rollback.

     It also means that every cursor will see changes made in the same
     session by other cursors, even if the transaction is still
     uncommitted.  This effect might be desirable or not, and is
     something to consider when deciding whether to share a connection
     or not.

     Hint: Should you use many cursors or many connections?

     Query execution and results retrieval on a connection is
     serialized: only one cursor at time will be able to run a query on
     the same connection (the ‘Connection’ object will coordinate
     different cursors’ access).  If your program runs a mix of database
     and non-database operations in several threads, then these threads
     might be able to share the same connection.  However, if you expect
     to execute massively parallel operations on the database, it might
     be useful to use more than one connection at time, rather than many
     cursors on the same connection (or a mix of both).

     Using several connections, however, has an impact on the server’s
     performance and usually the number of connections that a server can
     handle is limited by grumpy sysadmins with long beards and a strict
     control on the max_connections(1) server setting.

     If you want to use more than one connection at time, but still
     avoid to create too many connections and starve the server, you
     might want to use a *note connection pool: f.

     Warning: 'Connections are not process-safe' and cannot be shared
     across processes, for instance using the facilities of the
     multiprocessing(2) module.

     If you are using Psycopg in a forking framework (for instance in a
     web server that implements concurrency using multiprocessing), you
     should make sure that the database connections are created after
     the worker process is forked.  Failing to do so you will probably
     find the connection in broken state.

* Menu:

* Asynchronous operations::
* with async connections::
* Interrupting async operations::
* Gevent support::
* Server messages::
* Asynchronous notifications::
* Detecting disconnections::

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/runtime-config-connection.html#GUC-MAX-CONNECTIONS

   (2) 
https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing


File: psycopg.info,  Node: Asynchronous operations,  Next: with async connections,  Up: Concurrent operations

1.2.1.1 Asynchronous operations
...............................

Psycopg *note Connection: 34. and *note Cursor: 36. have counterparts
*note AsyncConnection: 4a. and *note AsyncCursor: 107. supporting an
asyncio(1) interface.

The design of the asynchronous objects is pretty much the same of the
sync ones: in order to use them you will only have to scatter the
‘await’ keyword here and there.

     async with await psycopg.AsyncConnection.connect(
             "dbname=test user=postgres") as aconn:
         async with aconn.cursor() as acur:
             await acur.execute(
                 "INSERT INTO test (num, data) VALUES (%s, %s)",
                 (100, "abc'def"))
             await acur.execute("SELECT * FROM test")
             await acur.fetchone()
             # will return (1, 100, "abc'def")
             async for record in acur:
                 print(record)

An ‘AsyncConnection’ can be used by several asyncio.Task(2) at the same
time.  However, as with threads, all the *note AsyncCursor: 107. on the
same connection will share the same session and will have their access
to the connection serialized.

Changed in version 3.1: *note AsyncConnection.connect(): 35. performs
DNS name resolution in a non-blocking way.

     Warning: Before version 3.1, *note AsyncConnection.connect(): 35.
     may still block on DNS name resolution.  To avoid that you should
     set the hostaddr connection parameter(3), or use the *note
     resolve_hostaddr_async(): 108. to do it automatically.

     Warning: On Windows, Psycopg is not compatible with the default
     ProactorEventLoop(4).  Please use a different loop, for instance
     the SelectorEventLoop(5).  See asyncio documentation(6) for
     details.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/asyncio.html#module-asyncio

   (2) https://docs.python.org/3/library/asyncio-task.html#asyncio.Task

   (3) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS

   (4) 
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.ProactorEventLoop

   (5) 
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.SelectorEventLoop

   (6) 
https://docs.python.org/3.14/library/asyncio-eventloop.html#asyncio.SelectorEventLoop


File: psycopg.info,  Node: with async connections,  Next: Interrupting async operations,  Prev: Asynchronous operations,  Up: Concurrent operations

1.2.1.2 ‘with’ async connections
................................

As seen in *note the basic usage: 1d, connections and cursors can act as
context managers, so you can run:

     with psycopg.connect("dbname=test user=postgres") as conn:
         with conn.cursor() as cur:
             cur.execute(...)
         # the cursor is closed upon leaving the context
     # the transaction is committed, the connection closed

For asynchronous connections it’s 'almost' what you’d expect, but not
quite.  Please note that *note connect(): 33. and *note cursor(): 37.
'don’t return a context': they are both factory methods which return 'an
object which can be used as a context'.  That’s because there are
several use cases where it’s useful to handle the objects manually and
only ‘close()’ them when required.

As a consequence you cannot use ‘async with connect()’: you have to do
it in two steps instead, as in

     aconn = await psycopg.AsyncConnection.connect()
     async with aconn:
         async with aconn.cursor() as cur:
             await cur.execute(...)

which can be condensed into ‘async with await’:

     async with await psycopg.AsyncConnection.connect() as aconn:
         async with aconn.cursor() as cur:
             await cur.execute(...)

…but no less than that: you still need to do the double async thing.

Note that the *note AsyncConnection.cursor(): 10a. function is not an
‘async’ function (it never performs I/O), so you don’t need an ‘await’
on it; as a consequence you can use the normal ‘async with’ context
manager.


File: psycopg.info,  Node: Interrupting async operations,  Next: Gevent support,  Prev: with async connections,  Up: Concurrent operations

1.2.1.3 Interrupting async operations
.....................................

If a long running operation is interrupted by a Ctrl-C on a normal
connection running in the main thread, the operation will be cancelled
and the connection will be put in error state, from which can be
recovered with a normal *note rollback(): 39.

An async connection provides similar behavior in that if the async task
is cancelled, any operation on the connection will similarly be
cancelled.  This can happen either indirectly via Ctrl-C or similar
signal, or directly by cancelling the Python Task via the normal way.
Psycopg will ask the PostgreSQL postmaster to cancel the operation when
it encounters the standard Python CancelledError(1).

Remember that cancelling the Python Task does not guarantee that the
operation will not complete, even if the task ultimately exits
prematurely due to CancelledError.  If you need to know the ultimate
outcome of the statement, then consider calling *note
Connection.cancel(): 10d. as an alternative to cancelling the task.

Previous versions of Psycopg recommended setting up signal handlers to
manually cancel connections.  This should no longer be necessary.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/asyncio-task.html#task-cancellation


File: psycopg.info,  Node: Gevent support,  Next: Server messages,  Prev: Interrupting async operations,  Up: Concurrent operations

1.2.1.4 Gevent support
......................

Psycopg 3 supports gevent(1) out of the box.  If the select(2) module is
found patched by functions such as gevent.monkey.patch_select()(3) or
patch_all()(4), psycopg will behave in a collaborative way.

Unlike with ‘psycopg2’, using the ‘psycogreen’ module is not required.

     Warning: gevent support was initially accidental, and was
     accidentally broken in psycopg 3.1.4.

     gevent is officially supported only starting from psycopg 3.1.14.

   ---------- Footnotes ----------

   (1) https://www.gevent.org/

   (2) https://docs.python.org/3/library/select.html#module-select

   (3) 
http://www.gevent.org/api/gevent.monkey.html#gevent.monkey.patch_select

   (4) 
http://www.gevent.org/api/gevent.monkey.html#gevent.monkey.patch_all


File: psycopg.info,  Node: Server messages,  Next: Asynchronous notifications,  Prev: Gevent support,  Up: Concurrent operations

1.2.1.5 Server messages
.......................

PostgreSQL can send, together with the query results, informative
messages(1) about the operation just performed, such as warnings or
debug information.  Notices may be raised even if the operations are
successful and don’t indicate an error.  You are probably familiar with
some of them, because they are reported by ‘psql’:

     $ psql
     =# ROLLBACK;
     WARNING:  there is no transaction in progress
     ROLLBACK

Messages can be also sent by the PL/pgSQL 'RAISE' statement(2) (at a
level lower than EXCEPTION, otherwise the appropriate *note
DatabaseError: 112. will be raised).  The level of the messages received
can be controlled using the client_min_messages(3) setting.

By default, the messages received are ignored.  If you want to process
them on the client you can use the *note
Connection.add_notice_handler(): 113. function to register a function
that will be invoked whenever a message is received.  The message is
passed to the callback as a *note Diagnostic: 114. instance, containing
all the information passed by the server, such as the message text and
the severity.  The object is the same found on the *note diag: 115.
attribute of the errors raised by the server:

     >>> import psycopg

     >>> def log_notice(diag):
     ...     print(f"The server says: {diag.severity} - {diag.message_primary}")

     >>> conn = psycopg.connect(autocommit=True)
     >>> conn.add_notice_handler(log_notice)

     >>> cur = conn.execute("ROLLBACK")
     The server says: WARNING - there is no transaction in progress
     >>> print(cur.statusmessage)
     ROLLBACK

     Warning: The ‘Diagnostic’ object received by the callback should
     not be used after the callback function terminates, because its
     data is deallocated after the callbacks have been processed.  If
     you need to use the information later please extract the attributes
     requested and forward them instead of forwarding the whole
     ‘Diagnostic’ object.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/runtime-config-logging.html#RUNTIME-CONFIG-SEVERITY-LEVELS

   (2) 
https://www.postgresql.org/docs/current/plpgsql-errors-and-messages.html

   (3) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-CLIENT-MIN-MESSAGES


File: psycopg.info,  Node: Asynchronous notifications,  Next: Detecting disconnections,  Prev: Server messages,  Up: Concurrent operations

1.2.1.6 Asynchronous notifications
..................................

Psycopg allows asynchronous interaction with other database sessions
using the facilities offered by PostgreSQL commands LISTEN(1) and
NOTIFY(2).  Please refer to the PostgreSQL documentation for examples
about how to use this form of communication.

Because of the way transactions interact with notifications (see
NOTIFY(3) documentation), you should keep the connection in *note
autocommit: ab. mode if you wish to receive or send notifications in a
timely manner.

     Note: You don’t need an *note AsyncConnection: 4a. to handle
     notifications: a normal blocking *note Connection: 34. is perfectly
     valid.

Notifications are received as instances of the *note Notify: 118.
object.  You can receive notifications using either the *note notifies
generator: 119. or a *note notifies handler: 11a.

     Warning: You should use only one of the two methods to receive
     notifications.

     Since Psycopg 3.2.10 using the generator and handlers at the same
     time raises a runtime warning.

* Menu:

* Notifies generator::
* Notifies handlers::

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/sql-listen.html

   (2) https://www.postgresql.org/docs/current/sql-notify.html

   (3) https://www.postgresql.org/docs/current/sql-notify.html


File: psycopg.info,  Node: Notifies generator,  Next: Notifies handlers,  Up: Asynchronous notifications

1.2.1.7 Notifies generator
..........................

If you are reserving a connection only to receive notifications, the
simplest way to receive them is to consume the *note
Connection.notifies(): 11c. generator.  The generator can be stopped
using its ‘close()’ method, or using the parameters ‘timeout’ or
‘stop_after’ to receive notifications only for a certain time or up to a
certain number.

The following example will print notifications and stop when one
containing the ‘"stop"’ message is received.

     import psycopg
     conn = psycopg.connect("", autocommit=True)
     conn.execute("LISTEN mychan")
     gen = conn.notifies()
     for notify in gen:
         print(notify)
         if notify.payload == "stop":
             gen.close()
     print("there, I stopped")

If you run some ‘NOTIFY’ in a ‘psql’ session:

     =# NOTIFY mychan, 'hello';
     NOTIFY
     =# NOTIFY mychan, 'hey';
     NOTIFY
     =# NOTIFY mychan, 'stop';
     NOTIFY

You may get output from the Python process such as:

     Notify(channel='mychan', payload='hello', pid=961823)
     Notify(channel='mychan', payload='hey', pid=961823)
     Notify(channel='mychan', payload='stop', pid=961823)
     there, I stopped

     Warning: The behaviour of the notifies generator has changed
     slightly as problems were found:

        - Before Psycopg 3.2.4, notification received between calling
          ‘LISTEN’ and starting the generator were lost.

        - Since *note Psycopg 3.2.4: 11d. such notifications are
          captured and yielded by the generator once it is started.
          However this introduced a leak (ticket #1091(1)) and, if the
          generator is not regularly used, some memory is allocated
          indefinitely.

        - Since *note Psycopg 3.2.10: 11e. if a handler is registered
          then notifications are not captured when the generator is not
          running.  So the behaviour is similar to pre-3.2.4 but 'only
          if a handler is registered too'.  Therefore, using handlers
          and generators together starts seeming a bad idea, hence it is
          since deprecated.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1091


File: psycopg.info,  Node: Notifies handlers,  Prev: Notifies generator,  Up: Asynchronous notifications

1.2.1.8 Notifies handlers
.........................

Alternatively, you can use *note add_notify_handler(): 120. to register
a callback function, which will be invoked whenever a notification is
received, during the normal query processing; you will be then able to
use the connection normally.  Please note that in this case
notifications will not be received immediately, but only during a
connection operation, such as a query.

     conn.add_notify_handler(lambda n: print(f"got this: {n}"))

     # meanwhile in psql...
     # =# NOTIFY mychan, 'hey';
     # NOTIFY

     print(conn.execute("SELECT 1").fetchone())
     # got this: Notify(channel='mychan', payload='hey', pid=961823)
     # (1,)


File: psycopg.info,  Node: Detecting disconnections,  Prev: Asynchronous notifications,  Up: Concurrent operations

1.2.1.9 Detecting disconnections
................................

Sometimes it is useful to detect immediately when the connection with
the database is lost.  One brutal way to do so is to poll a connection
in a loop running an endless stream of ‘SELECT 1’… 'Don’t' do so:
polling is 'so' out of fashion.  Besides, it is inefficient (unless what
you really want is a client-server generator of ones), it generates
useless traffic and will only detect a disconnection with an average
delay of half the polling time.

A more efficient and timely way to detect a server disconnection is to
create an additional connection and wait for a notification from the OS
that this connection has something to say: only then you can run some
checks.  You can dedicate a thread (or an asyncio task) to wait on this
connection: such thread will perform no activity until awaken by the OS.

In a normal (non asyncio) program you can use the selectors(1) module.
Because the ‘Connection’ implements a *note fileno(): 123. method you
can just register it as a file-like object.  You can run such code in a
dedicated thread (and using a dedicated connection) if the rest of the
program happens to have something else to do too.

     import selectors

     sel = selectors.DefaultSelector()
     sel.register(conn, selectors.EVENT_READ)
     while True:
         if not sel.select(timeout=60.0):
             continue  # No FD activity detected in one minute

         # Activity detected. Is the connection still ok?
         try:
             conn.execute("SELECT 1")
         except psycopg.OperationalError:
             # You were disconnected: do something useful such as panicking
             logger.error("we lost our database!")
             sys.exit(1)

In an asyncio(2) program you can dedicate a Task(3) instead and do
something similar using add_reader(4):

     import asyncio

     ev = asyncio.Event()
     loop = asyncio.get_event_loop()
     loop.add_reader(conn.fileno(), ev.set)

     while True:
         try:
             await asyncio.wait_for(ev.wait(), 60.0)
         except asyncio.TimeoutError:
             continue  # No FD activity detected in one minute

         # Activity detected. Is the connection still ok?
         try:
             await conn.execute("SELECT 1")
         except psycopg.OperationalError:
             # Guess what happened
             ...

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/selectors.html#module-selectors

   (2) https://docs.python.org/3/library/asyncio.html#module-asyncio

   (3) https://docs.python.org/3/library/asyncio-task.html#asyncio.Task

   (4) 
https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.add_reader


File: psycopg.info,  Node: Static Typing,  Next: Row factories,  Prev: Concurrent operations,  Up: More advanced topics

1.2.2 Static Typing
-------------------

Psycopg source code is annotated according to PEP 0484(1) type hints and
is checked using the current version of Mypy(2) in ‘--strict’ mode.

If your application is checked using Mypy too you can make use of
Psycopg types to validate the correct use of Psycopg objects and of the
data returned by the database.

* Menu:

* Generic types::
* Type of rows returned::
* Generic pool types::
* Example; returning records as Pydantic models: Example returning records as Pydantic models.
* Checking literal strings in queries::

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/

   (2) http://mypy-lang.org/


File: psycopg.info,  Node: Generic types,  Next: Type of rows returned,  Up: Static Typing

1.2.2.1 Generic types
.....................

Psycopg *note Connection: 34. and *note Cursor: 36. objects are
Generic(1) objects and support a ‘Row’ parameter which is the type of
the records returned.  The parameter can be configured by passing a
‘row_factory’ parameter to the constructor or to the *note cursor(): 37.
method.

By default, methods producing records such as *note Cursor.fetchall():
3e. return normal tuples of unknown size and content.  As such, the
*note connect(): 48. function returns an object of type
‘psycopg.Connection[tuple[Any, ...]]’ and *note Connection.cursor(): 37.
returns an object of type ‘psycopg.Cursor[tuple[Any, ...]]’.  If you are
writing generic plumbing code it might be practical to use annotations
such as ‘Connection[Any]’ and ‘Cursor[Any]’.

     conn = psycopg.connect() # type is psycopg.Connection[tuple[Any, ...]]

     cur = conn.cursor()      # type is psycopg.Cursor[tuple[Any, ...]]

     rec = cur.fetchone()     # type is tuple[Any, ...] | None

     recs = cur.fetchall()    # type is List[tuple[Any, ...]]

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Generic


File: psycopg.info,  Node: Type of rows returned,  Next: Generic pool types,  Prev: Generic types,  Up: Static Typing

1.2.2.2 Type of rows returned
.............................

If you want to use connections and cursors returning your data as
different types, for instance as dictionaries, you can use the
‘row_factory’ argument of the *note connect(): 33. and the *note
cursor(): 37. method, which will control what type of record is returned
by the fetch methods of the cursors and annotate the returned objects
accordingly.  See *note Row factories: 4d. for more details.

     dconn = psycopg.connect(row_factory=dict_row)
     # dconn type is psycopg.Connection[dict[str, Any]]

     dcur = conn.cursor(row_factory=dict_row)
     dcur = dconn.cursor()
     # dcur type is psycopg.Cursor[dict[str, Any]] in both cases

     drec = dcur.fetchone()
     # drec type is dict[str, Any] | None


File: psycopg.info,  Node: Generic pool types,  Next: Example returning records as Pydantic models,  Prev: Type of rows returned,  Up: Static Typing

1.2.2.3 Generic pool types
..........................

Added in version 3.2.

The *note ConnectionPool: 12c. class and similar are generic on their
‘connection_class’ argument.  The *note connection(): 12d. method is
annotated as returning a connection of that type, and the record
returned will follow the rule as in *note Type of rows returned: 128.

Note that, at the moment, if you use a generic class as
‘connection_class’, you will need to specify a ‘row_factory’
consistently in the ‘kwargs’, otherwise the typing system and the
runtime will not agree.

     from psycopg import Connection
     from psycopg.rows import DictRow, dict_row

     with ConnectionPool(
         connection_class=Connection[DictRow],   # provides type hinting
         kwargs={"row_factory": dict_row},       # works at runtime
     ) as pool:
         # reveal_type(pool): ConnectionPool[Connection[dict[str, Any]]]

         with pool.connection() as conn:
             # reveal_type(conn): Connection[dict[str, Any]]

             row = conn.execute("SELECT now()").fetchone()
             # reveal_type(row): dict[str, Any] | None

             print(row)  # {"now": datetime.datetime(...)}

If a non-generic ‘Connection’ subclass is used (one whose returned row
type is not parametric) then it’s not necessary to specify ‘kwargs’:

     class MyConnection(Connection[DictRow]):
         def __init__(self, *args, **kwargs):
             kwargs["row_factory"] = dict_row
             super().__init__(*args, **kwargs)

     with ConnectionPool(connection_class=MyConnection) as pool:
         # reveal_type(pool): ConnectionPool[MyConnection]

         with pool.connection() as conn:
             # reveal_type(conn): MyConnection

             row = conn.execute("SELECT now()").fetchone()
             # reveal_type(row): dict[str, Any] | None

             print(row)  # {"now": datetime.datetime(...)}


File: psycopg.info,  Node: Example returning records as Pydantic models,  Next: Checking literal strings in queries,  Prev: Generic pool types,  Up: Static Typing

1.2.2.4 Example: returning records as Pydantic models
.....................................................

Using Pydantic(1) it is possible to enforce static typing at runtime.
Using a Pydantic model factory the code can be checked statically using
Mypy and querying the database will raise an exception if the rows
returned is not compatible with the model.

The following example can be checked with ‘mypy --strict’ without
reporting any issue.  Pydantic will also raise a runtime error in case
the ‘Person’ is used with a query that returns incompatible data.

     from datetime import date
     from typing import Optional

     import psycopg
     from psycopg.rows import class_row
     from pydantic import BaseModel

     class Person(BaseModel):
         id: int
         first_name: str
         last_name: str
         dob: Optional[date]

     def fetch_person(id: int) -> Person:
         with psycopg.connect() as conn:
             with conn.cursor(row_factory=class_row(Person)) as cur:
                 cur.execute(
                     """
                     SELECT id, first_name, last_name, dob
                     FROM (VALUES
                         (1, 'John', 'Doe', '2000-01-01'::date),
                         (2, 'Jane', 'White', NULL)
                     ) AS data (id, first_name, last_name, dob)
                     WHERE id = %(id)s;
                     """,
                     {"id": id},
                 )
                 obj = cur.fetchone()

                 # reveal_type(obj) would return 'Optional[Person]' here

                 if not obj:
                     raise KeyError(f"person {id} not found")

                 # reveal_type(obj) would return 'Person' here

                 return obj

     for id in [1, 2]:
         p = fetch_person(id)
         if p.dob:
             print(f"{p.first_name} was born in {p.dob.year}")
         else:
             print(f"Who knows when {p.first_name} was born")

   ---------- Footnotes ----------

   (1) https://pydantic-docs.helpmanual.io/


File: psycopg.info,  Node: Checking literal strings in queries,  Prev: Example returning records as Pydantic models,  Up: Static Typing

1.2.2.5 Checking literal strings in queries
...........................................

The *note execute(): 3a. method and similar should only receive a
literal string as input, according to PEP 675(1).  This means that the
query should come from a literal string in your code, not from an
arbitrary string expression.

For instance, passing an argument to the query should be done via the
second argument to ‘execute()’, not by string composition:

     def get_record(conn: psycopg.Connection[Any], id: int) -> Any:
         cur = conn.execute("SELECT * FROM my_table WHERE id = %s" % id)  # BAD!
         return cur.fetchone()

     # the function should be implemented as:

     def get_record(conn: psycopg.Connection[Any], id: int) -> Any:
         cur = conn.execute("select * FROM my_table WHERE id = %s", (id,))
         return cur.fetchone()

If you are composing a query dynamically you should use the *note
sql.SQL: 131. object and similar to escape safely table and field names.
The parameter of the ‘SQL()’ object should be a literal string:

     def count_records(conn: psycopg.Connection[Any], table: str) -> int:
         query = "SELECT count(*) FROM %s" % table  # BAD!
         return conn.execute(query).fetchone()[0]

     # the function should be implemented as:

     def count_records(conn: psycopg.Connection[Any], table: str) -> int:
         query = sql.SQL("SELECT count(*) FROM {}").format(sql.Identifier(table))
         return conn.execute(query).fetchone()[0]

At the time of writing, no Python static analyzer implements this check
(mypy doesn't implement it(2), Pyre(3) does, but doesn't work with
psycopg yet(4)).  Once the type checkers support will be complete, the
above bad statements should be reported as errors.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0675/

   (2) https://github.com/python/mypy/issues/12554

   (3) https://pyre-check.org/

   (4) https://github.com/facebook/pyre-check/issues/636


File: psycopg.info,  Node: Row factories,  Next: Connection pools,  Prev: Static Typing,  Up: More advanced topics

1.2.3 Row factories
-------------------

Cursor’s ‘fetch*’ methods, by default, return the records received from
the database as tuples.  This can be changed to better suit the needs of
the programmer by using custom 'row factories'.

The module *note psycopg.rows: 8. exposes several row factories ready to
be used.  For instance, if you want to return your records as
dictionaries, you can use *note dict_row: f0.:

     >>> from psycopg.rows import dict_row

     >>> conn = psycopg.connect(DSN, row_factory=dict_row)

     >>> conn.execute("select 'John Doe' as name, 33 as age").fetchone()
     {'name': 'John Doe', 'age': 33}

The ‘row_factory’ parameter is supported by the *note connect(): 33.
method and the *note cursor(): 37. method.  Later usage of ‘row_factory’
overrides a previous one.  It is also possible to change the *note
Connection.row_factory: 135. or *note Cursor.row_factory: 136.
attributes to change what they return:

     >>> cur = conn.cursor(row_factory=dict_row)
     >>> cur.execute("select 'John Doe' as name, 33 as age").fetchone()
     {'name': 'John Doe', 'age': 33}

     >>> from psycopg.rows import namedtuple_row
     >>> cur.row_factory = namedtuple_row
     >>> cur.execute("select 'John Doe' as name, 33 as age").fetchone()
     Row(name='John Doe', age=33)

If you want to return objects of your choice you can use a row factory
'generator', for instance *note class_row: 137. or *note args_row: 138,
or you can *note write your own row factory: 139.:

     >>> from dataclasses import dataclass

     >>> @dataclass
     ... class Person:
     ...     name: str
     ...     age: int
     ...     weight: Optional[int] = None

     >>> from psycopg.rows import class_row
     >>> cur = conn.cursor(row_factory=class_row(Person))
     >>> cur.execute("select 'John Doe' as name, 33 as age").fetchone()
     Person(name='John Doe', age=33, weight=None)

     Note: The choice of a ‘row_factory’ in a ‘Connection’ or a ‘Cursor’
     constructor affects how the object is annotated for static type
     checking.

     For instance, declaring a ‘row_factory=dict_row’ will result in the
     cursors’ ‘executeany()’ annotated as returning ‘list[dict[str,
     Any]]’ instead of ‘list[tuple[Any, ...]]’.

     Please check *note Static Typing: 10. for more details.

* Menu:

* Creating new row factories::


File: psycopg.info,  Node: Creating new row factories,  Up: Row factories

1.2.3.1 Creating new row factories
..................................

A 'row factory' is a callable that accepts a *note Cursor: 36. object
and returns another callable, a 'row maker', which takes raw data (as a
sequence of values) and returns the desired object.

The role of the row factory is to inspect a query result (it is called
after a query is executed and properties such as *note description: 13b.
and *note pgresult: 13c. are available on the cursor) and to prepare a
callable which is efficient to call repeatedly (because, for instance,
the names of the columns are extracted, sanitised, and stored in local
variables).

Formally, these objects are represented by the *note RowFactory: 13d.
and *note RowMaker: 13e. protocols.

‘RowFactory’ objects can be implemented as a class, for instance:

     from typing import Any, Sequence
     from psycopg import Cursor

     class DictRowFactory:
         def __init__(self, cursor: Cursor[Any]):
             self.fields = [c.name for c in cursor.description]

         def __call__(self, values: Sequence[Any]) -> dict[str, Any]:
             return dict(zip(self.fields, values))

or as nested functions:

     def dict_row_factory(cursor: Cursor[Any]) -> RowMaker[dict[str, Any]]:
         fields = [c.name for c in cursor.description]

         def make_row(values: Sequence[Any]) -> dict[str, Any]:
             return dict(zip(fields, values))

         return make_row

These can then be used by specifying a ‘row_factory’ argument in *note
Connection.connect(): 33, *note Connection.cursor(): 37, or by setting
the *note Connection.row_factory: 135. attribute.

     conn = psycopg.connect(row_factory=DictRowFactory)
     cur = conn.execute("SELECT first_name, last_name, age FROM persons")
     person = cur.fetchone()
     print(f"{person['first_name']} {person['last_name']}")


File: psycopg.info,  Node: Connection pools,  Next: Cursor types,  Prev: Row factories,  Up: More advanced topics

1.2.4 Connection pools
----------------------

A connection pool(1) is an object managing a set of connections and
allowing their use in functions needing one.  Because the time to
establish a new connection can be relatively long, keeping connections
open can reduce latency.

This page explains a few basic concepts of Psycopg connection pool’s
behaviour.  Please refer to the *note ConnectionPool: 12c. object API
for details about the pool operations.

     Note: The connection pool objects are distributed in a package
     separate from the main *note psycopg: 0. package: use ‘pip install
     "psycopg[pool]"’ or ‘pip install psycopg_pool’ to make the *note
     psycopg_pool: b. package available.  See *note Installing the
     connection pool: 2e.

* Menu:

* Basic connection pool usage::
* Pool startup check::
* Connections life cycle::
* Other ways to create a pool::
* Null connection pools::
* Pool connection and sizing::
* Connection quality::
* Pool operations logging::
* Pool stats::

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Connection_pool


File: psycopg.info,  Node: Basic connection pool usage,  Next: Pool startup check,  Up: Connection pools

1.2.4.1 Basic connection pool usage
...................................

A *note ConnectionPool: 12c. object can be used to request connections
from multiple concurrent threads.  A simple and safe way to use it is as
a 'context manager'.  Within the ‘with’ block, you can request the pool
a connection using the *note connection(): 12d. method, and use it as a
context manager too:

     with ConnectionPool(...) as pool:
         with pool.connection() as conn:
             conn.execute("SELECT something FROM somewhere ...")

             with conn.cursor() as cur:
                 cur.execute("SELECT something else...")

         # At the end of the `connection()` context, the transaction is committed
         # or rolled back, and the connection returned to the pool

     # At the end of the pool context, all the resources used by the pool are released

The ‘connection()’ context behaves like the *note Connection: 34. object
context: at the end of the block, if there is a transaction open, it
will be committed if the context is exited normally, or rolled back if
the context is exited with an exception.  See *note Transaction
contexts: aa. for details.

The pool manages a certain amount of connections (between ‘min_size’ and
‘max_size’).  If the pool has a connection ready in its state, it is
served immediately to the ‘connection()’ caller, otherwise the caller is
put in a queue and is served a connection as soon as it’s available.

If instead of threads your application uses async code you can use the
*note AsyncConnectionPool: 142. instead and use the ‘async’ and ‘await’
keywords with the methods requiring them:

     async with AsyncConnectionPool(...) as pool:
         async with pool.connection() as conn:
             await conn.execute("SELECT something FROM somewhere ...")

             async with conn.cursor() as cur:
                 await cur.execute("SELECT something else...")


File: psycopg.info,  Node: Pool startup check,  Next: Connections life cycle,  Prev: Basic connection pool usage,  Up: Connection pools

1.2.4.2 Pool startup check
..........................

After a pool is open, it can accept new clients even if it doesn’t have
‘min_size’ connections ready yet.  However, if the application is
misconfigured and cannot connect to the database server, the clients
will block until failing with a *note PoolTimeout: 144.

If you want to make sure early in the application lifetime that the
environment is well configured, you can use the *note wait(): 145.
method after opening the pool, which will block until ‘min_size’
connections have been acquired, or fail with a ‘PoolTimeout’ if it
doesn’t happen in time:

     with ConnectionPool(...) as pool:
         pool.wait()
         use_the(pool)


File: psycopg.info,  Node: Connections life cycle,  Next: Other ways to create a pool,  Prev: Pool startup check,  Up: Connection pools

1.2.4.3 Connections life cycle
..............................

When the pool needs a new connection (because it was just opened, or
because an existing connection was closed, or because a spike of
activity requires new connections), it uses a background pool worker to
prepare it in the background:

   - the worker creates a connection according to the parameters
     ‘conninfo’, ‘kwargs’, and ‘connection_class’ passed to *note
     ConnectionPool: 12c. constructor, calling something similar to
     ‘CONNECTION_CLASS(CONNINFO, **KWARGS)’;

   - if a ‘configure’ callback was provided, it is called with the new
     connection as parameter.  This can be used, for instance, to
     configure the connection adapters.

Once the connection is prepared, it is stored in the pool state, or it
is passed to a client if someone is already in the requests queue.

When a client asks for a connection (typically entering a *note
connection(): 12d. context):

   - if there is a connection available in the pool, it is served to the
     client immediately;

   - if no connection is available, the client is put in a queue, and
     will be served a connection once one becomes available (because
     returned by another client or because a new one is created);

   - if a ‘check’ callback was provided, it is called on the connection
     before passing the connection to the client.  If the check fails, a
     new connection will be obtained.

When a client has finished to use the connection (typically at the end
of the context stared by *note connection(): 12d.):

   - if there is a transaction open, the transaction is committed (if
     the block is exited normally) or rolled back (if it is exited with
     an exception);

   - if a ‘reset’ callback was provided, the connection is passed to it,
     to allow application-specific cleanup if needed;

   - if, along this process, the connection is found in broken state, or
     if it passed the ‘max_lifetime’ configured at pool creation, it is
     discarded and a new connection is requested to a worker;

   - the connection is finally returned to the pool, or, if there are
     clients in the queue, to the first client waiting.


File: psycopg.info,  Node: Other ways to create a pool,  Next: Null connection pools,  Prev: Connections life cycle,  Up: Connection pools

1.2.4.4 Other ways to create a pool
...................................

Using the pool as a context manager is not mandatory: pools can be
created and used without using the context pattern.  However, using the
context is the safest way to manage its resources.

When the pool is created, if its ‘open’ parameter is ‘True’, the
connection process starts immediately.  In a simple program you might
create a pool as a global object and use it from the rest of your code:

     # module db.py in your program
     from psycopg_pool import ConnectionPool

     pool = ConnectionPool(..., open=True, ...)
     # the pool starts connecting immediately.

     # in another module
     from .db import pool

     def my_function():
         with pool.connection() as conn:
             conn.execute(...)

Using this pattern, the pool will start the connection process already
at import time.  If that’s too early, and you want to delay opening
connections until the application is ready, you can specify to create a
closed pool and call the *note open(): 148. method.

If you are not using the pool as context manager, you are advised to
call the *note close(): 149. method on program exit: on some Python
versions this might cause a program exit delay.  How to ensure it
depends on the way you are writing your program.  One simple method is
to use the atexit(1) module:

     atexit.register(pool.close)

Other frameworks might provide suitable hooks.  For example, in FastAPI,
you can use a lifespan(2) function:

     pool = AsyncConnectionPool(..., open=False, ...)

     @asynccontextmanager
     async def lifespan(instance: FastAPI):
         await pool.open()
         yield
         await pool.close()

     app = FastAPI(lifespan=lifespan)

     Warning: The current default for the ‘open’ parameter is ‘True’.
     However this proved to be not the best idea and, in future
     releases, the default might be changed to ‘False’.  As a
     consequence, if you rely on the pool to be opened on creation, you
     should specify ‘open=True’ explicitly.

     Warning: Opening an async pool in the constructor is deprecated and
     will be removed in the future.  When using *note
     AsyncConnectionPool: 142. you should call ‘await pool.open()’ or
     ‘async with ... as pool’ explicitly.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/atexit.html#module-atexit

   (2) https://fastapi.tiangolo.com/advanced/events/#lifespan


File: psycopg.info,  Node: Null connection pools,  Next: Pool connection and sizing,  Prev: Other ways to create a pool,  Up: Connection pools

1.2.4.5 Null connection pools
.............................

Added in version 3.1.

Sometimes you may want leave the choice of using or not using a
connection pool as a configuration parameter of your application.  For
instance, you might want to use a pool if you are deploying a “large
instance” of your application and can dedicate it a handful of
connections; conversely you might not want to use it if you deploy the
application in several instances, behind a load balancer, and/or using
an external connection pool process such as PgBouncer.

Switching between using or not using a pool requires some code change,
because the *note ConnectionPool: 12c. API is different from the normal
*note connect(): 48. function and because the pool can perform
additional connection configuration (in the ‘configure’ parameter) that,
if the pool is removed, should be performed in some different code path
of your application.

The ‘psycopg_pool’ 3.1 package introduces the *note NullConnectionPool:
14c. class.  This class has the same interface, and largely the same
behaviour, of the ‘ConnectionPool’, but doesn’t create any connection
beforehand.  When a connection is returned, unless there are other
clients already waiting, it is closed immediately and not kept in the
pool state.

A null pool is not only a configuration convenience, but can also be
used to regulate the access to the server by a client program.  If
‘max_size’ is set to a value greater than 0, the pool will make sure
that no more than ‘max_size’ connections are created at any given time.
If more clients ask for further connections, they will be queued and
served a connection as soon as a previous client has finished using it,
like for the basic pool.  Other mechanisms to throttle client requests
(such as ‘timeout’ or ‘max_waiting’) are respected too.

     Note: Queued clients will be handed an already established
     connection, as soon as a previous client has finished using it (and
     after the pool has returned it to idle state and called ‘reset()’
     on it, if necessary).

Because normally (i.e.  unless queued) every client will be served a new
connection, the time to obtain the connection is paid by the waiting
client; background workers are not normally involved in obtaining new
connections.


File: psycopg.info,  Node: Pool connection and sizing,  Next: Connection quality,  Prev: Null connection pools,  Up: Connection pools

1.2.4.6 Pool connection and sizing
..................................

A pool can have a fixed size (specifying no ‘max_size’ or ‘max_size’ =
‘min_size’) or a dynamic size (when ‘max_size’ > ‘min_size’).  In both
cases, as soon as the pool is created, it will try to acquire ‘min_size’
connections in the background.

If an attempt to create a connection fails, a new attempt will be made
soon after, using an exponential backoff to increase the time between
attempts, until a maximum of ‘reconnect_timeout’ is reached.  When that
happens, the pool will call the ‘reconnect_failed()’ function, if
provided to the pool, and just start a new connection attempt.  You can
use this function either to send alerts or to interrupt the program and
allow the rest of your infrastructure to restart it.

If more than ‘min_size’ connections are requested concurrently, new ones
are created, up to ‘max_size’.  Note that the connections are always
created by the background workers, not by the thread asking for the
connection: if a client requests a new connection, and a previous client
terminates its job before the new connection is ready, the waiting
client will be served the existing connection.  This is especially
useful in scenarios where the time to establish a connection dominates
the time for which the connection is used (see this analysis(1), for
instance).

If a pool grows above ‘min_size’, but its usage decreases afterwards, a
number of connections are eventually closed: one every time a connection
is unused after the ‘max_idle’ time specified in the pool constructor.

* Menu:

* What’s the right size for the pool?::

   ---------- Footnotes ----------

   (1) 
https://github.com/brettwooldridge/HikariCP/blob/dev/documents/Welcome-To-The-Jungle.md


File: psycopg.info,  Node: What’s the right size for the pool?,  Up: Pool connection and sizing

1.2.4.7 What’s the right size for the pool?
...........................................

Big question.  Who knows.  However, probably not as large as you
imagine.  Please take a look at this analysis(1) for some ideas.

Something useful you can do is probably to use the *note get_stats():
14f. method and monitor the behaviour of your program to tune the
configuration parameters.  The size of the pool can also be changed at
runtime using the *note resize(): 150. method.

   ---------- Footnotes ----------

   (1) 
https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing


File: psycopg.info,  Node: Connection quality,  Next: Pool operations logging,  Prev: Pool connection and sizing,  Up: Connection pools

1.2.4.8 Connection quality
..........................

Added in version 3.2.

The pool doesn’t actively check the state of the connections held in its
state.  This means that, if communication with the server is lost, or if
a connection is closed for other reasons (such as a server configured
with an idle_session_timeout(1) killing connections that haven’t been
used for some time), the application might be served a connection in
broken state.

If you want to configure the pool to check the state of the connection,
and make sure that the application always receives a working connection,
you can configure a ‘check’ callback.  The callback can perform some
operation to verify the quality of the connection and, if it completes
without raising exception, the connection is passed to the client.
This, of course, will imply some network time that the pool client will
have to pay.

A simple implementation is available as the static method *note
ConnectionPool.check_connection: 152, which can be used as:

     with ConnectionPool(
         ..., check=ConnectionPool.check_connection, ...
     ) as pool:
         ...

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-IDLE-SESSION-TIMEOUT


File: psycopg.info,  Node: Pool operations logging,  Next: Pool stats,  Prev: Connection quality,  Up: Connection pools

1.2.4.9 Pool operations logging
...............................

The pool uses the logging(1) module to log some key operations to the
‘psycopg.pool’ logger.  If you are trying to debug the pool behaviour
you may try to log at least the ‘INFO’ operations on that logger.

For example, the script:

     import time
     import logging
     from concurrent.futures import ThreadPoolExecutor, as_completed
     from psycopg_pool import ConnectionPool

     logging.basicConfig(
         level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s: %(message)s"
     )
     logging.getLogger("psycopg.pool").setLevel(logging.INFO)

     pool = ConnectionPool(min_size=2)
     pool.wait()
     logging.info("pool ready")

     def square(n):
         with pool.connection() as conn:
             time.sleep(1)
             rec = conn.execute("SELECT %s * %s", (n, n)).fetchone()
             logging.info(f"The square of {n} is {rec[0]}.")

     with ThreadPoolExecutor(max_workers=4) as executor:
         futures = [executor.submit(square, n) for n in range(4)]
         for future in as_completed(futures):
             future.result()

might print something like:

     2023-09-20 11:02:39,718 INFO psycopg.pool: waiting for pool 'pool-1' initialization
     2023-09-20 11:02:39,720 INFO psycopg.pool: adding new connection to the pool
     2023-09-20 11:02:39,720 INFO psycopg.pool: adding new connection to the pool
     2023-09-20 11:02:39,720 INFO psycopg.pool: pool 'pool-1' is ready to use
     2023-09-20 11:02:39,720 INFO root: pool ready
     2023-09-20 11:02:39,721 INFO psycopg.pool: connection requested from 'pool-1'
     2023-09-20 11:02:39,721 INFO psycopg.pool: connection given by 'pool-1'
     2023-09-20 11:02:39,721 INFO psycopg.pool: connection requested from 'pool-1'
     2023-09-20 11:02:39,721 INFO psycopg.pool: connection given by 'pool-1'
     2023-09-20 11:02:39,721 INFO psycopg.pool: connection requested from 'pool-1'
     2023-09-20 11:02:39,722 INFO psycopg.pool: connection requested from 'pool-1'
     2023-09-20 11:02:40,724 INFO root: The square of 0 is 0.
     2023-09-20 11:02:40,724 INFO root: The square of 1 is 1.
     2023-09-20 11:02:40,725 INFO psycopg.pool: returning connection to 'pool-1'
     2023-09-20 11:02:40,725 INFO psycopg.pool: connection given by 'pool-1'
     2023-09-20 11:02:40,725 INFO psycopg.pool: returning connection to 'pool-1'
     2023-09-20 11:02:40,726 INFO psycopg.pool: connection given by 'pool-1'
     2023-09-20 11:02:41,728 INFO root: The square of 3 is 9.
     2023-09-20 11:02:41,729 INFO root: The square of 2 is 4.
     2023-09-20 11:02:41,729 INFO psycopg.pool: returning connection to 'pool-1'
     2023-09-20 11:02:41,730 INFO psycopg.pool: returning connection to 'pool-1'

Please do not rely on the messages generated to remain unchanged across
versions: they don’t constitute a stable interface.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/logging.html#module-logging


File: psycopg.info,  Node: Pool stats,  Prev: Pool operations logging,  Up: Connection pools

1.2.4.10 Pool stats
...................

The pool can return information about its usage using the methods *note
get_stats(): 14f. or *note pop_stats(): 157.  Both methods return the
same values, but the latter reset the counters after its use.  The
values can be sent to a monitoring system such as Graphite(1) or
Prometheus(2).

The following values should be provided, but please don’t consider them
as a rigid interface: it is possible that they might change in the
future.  Keys whose value is 0 may not be returned.

Metric                      Meaning
                            
--------------------------------------------------------------------------------------
‘pool_min’                  Current value for *note min_size: 158.
                            
‘pool_max’                  Current value for *note max_size: 159.
                            
‘pool_size’                 Number of connections currently managed by the pool (in
                            the pool, given to clients, being prepared)
                            
‘pool_available’            Number of connections currently idle in the pool
                            
‘requests_waiting’          Number of requests currently waiting in a queue to
                            receive a connection
                            
‘usage_ms’                  Total usage time of the connections outside the pool
                            
‘requests_num’              Number of connections requested to the pool
                            
‘requests_queued’           Number of requests queued because a connection wasn’t
                            immediately available in the pool
                            
‘requests_wait_ms’          Total time in the queue for the clients waiting
                            
‘requests_errors’           Number of connection requests resulting in an error
                            (timeouts, queue full…)
                            
‘returns_bad’               Number of connections returned to the pool in a bad
                            state
                            
‘connections_num’           Number of connection attempts made by the pool to the
                            server
                            
‘connections_ms’            Total time spent to establish connections with the
                            server
                            
‘connections_errors’        Number of failed connection attempts
                            
‘connections_lost’          Number of connections lost identified by
                            *note check(): 15a. or by the ‘check’ callback
                            

   ---------- Footnotes ----------

   (1) https://graphiteapp.org/

   (2) https://prometheus.io/


File: psycopg.info,  Node: Cursor types,  Next: Data adaptation configuration,  Prev: Connection pools,  Up: More advanced topics

1.2.5 Cursor types
------------------

Cursors are objects used to send commands to a PostgreSQL connection and
to manage the results returned by it.  They are normally created by the
connection’s *note cursor(): 37. method.

Psycopg can manage different kinds of “cursors”, the objects used to
send queries and retrieve results from the server.  They differ from
each other in aspects such as:

   - Are the parameters bound on the client or on the server?  *note
     Server-side binding: 11. can offer better performance (for instance
     allowing to use prepared statements) and reduced memory footprint,
     but may require stricter query definition and certain queries that
     work in ‘psycopg2’ might need to be adapted.

   - Is the query result stored on the client or on the server?
     Server-side cursors allow partial retrieval of large datasets, but
     they might offer less performance in everyday usage.

   - Are queries manipulated by Python (to handle placeholders in ‘%s’
     and ‘%(name)s’ Python-style) or sent as they are to the PostgreSQL
     server (which only supports ‘$1’, ‘$2’ parameters)?

Psycopg exposes the following classes to implement the different
strategies.  All the classes are exposed by the main ‘psycopg’ package.
Every class has also an ‘Async’-prefixed counterparts, designed to be
used in conjunction with *note AsyncConnection: 4a. in asyncio(1)
programs.

Class                 Binding         Storage         Placeholders             See also
                                                                               
----------------------------------------------------------------------------------------------------------------------
*note Cursor: 36.     server-side     client-side     ‘%s’, ‘%(name)s’         *note Client-side cursors: 15e.
                                                                               
*note ClientCursor: de.client-side    client-side     ‘%s’, ‘%(name)s’         *note Client-side-binding cursors: dd.
                                                                               
*note ServerCursor: 15f.server-side   server-side     ‘%s’, ‘%(name)s’         *note Server-side cursors: 160.
                                                                               
*note RawCursor: 161. server-side     client-side     ‘$1’                     *note Raw query cursors: 162.
                                                                               
*note RawServerCursor: 163.server-sideserver-side     ‘$1’                     *note Raw query cursors: 162.
                                                                               

If not specified by a *note cursor_factory: df, *note cursor(): 37. will
usually produce *note Cursor: 36. objects.

* Menu:

* Client-side cursors::
* Client-side-binding cursors::
* Server-side cursors::
* Raw query cursors::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/asyncio.html#module-asyncio


File: psycopg.info,  Node: Client-side cursors,  Next: Client-side-binding cursors,  Up: Cursor types

1.2.5.1 Client-side cursors
...........................

Client-side cursors are what Psycopg uses in its normal querying
process.  They are implemented by the *note Cursor: 36. and *note
AsyncCursor: 107. classes.  In such querying pattern, after a cursor
sends a query to the server (usually calling *note execute(): 3a.), the
server replies transferring to the client the whole set of results
requested, which is stored in the state of the same cursor and from
where it can be read from Python code (using methods such as *note
fetchone(): 3c. and siblings).

This querying process is very scalable because, after a query result has
been transmitted to the client, the server doesn’t keep any state.
Because the results are already in the client memory, iterating its rows
is very quick.

The downside of this querying method is that the entire result has to be
transmitted completely to the client (with a time proportional to its
size) and the client needs enough memory to hold it, so it is only
suitable for reasonably small result sets.


File: psycopg.info,  Node: Client-side-binding cursors,  Next: Server-side cursors,  Prev: Client-side cursors,  Up: Cursor types

1.2.5.2 Client-side-binding cursors
...................................

Added in version 3.1.

The previously described *note client-side cursors: 15e. send the query
and the parameters separately to the server.  This is the most efficient
way to process parametrised queries and allows to build several features
and optimizations.  However, not all types of queries can be bound
server-side; in particular no Data Definition Language query can.  See
*note Server-side binding: 11. for the description of these problems.

The *note ClientCursor: de. (and its *note AsyncClientCursor: 166. async
counterpart) merge the query on the client and send the query and the
parameters merged together to the server.  This allows to parametrize
any type of PostgreSQL statement, not only queries (‘SELECT’) and Data
Manipulation statements (‘INSERT’, ‘UPDATE’, ‘DELETE’).

Using ‘ClientCursor’, Psycopg 3 behaviour will be more similar to
psycopg2(1) (which only implements client-side binding) and could be
useful to port Psycopg 2 programs more easily to Psycopg 3.  The objects
in the *note sql: 9. module allow for greater flexibility (for instance
to parametrize a table name too, not only values); however, for simple
cases, a ‘ClientCursor’ could be the right object.

In order to obtain ‘ClientCursor’ from a connection, you can set its
*note cursor_factory: df. (at init time or changing its attribute
afterwards):

     from psycopg import connect, ClientCursor

     conn = psycopg.connect(DSN, cursor_factory=ClientCursor)
     cur = conn.cursor()
     # <psycopg.ClientCursor [no result] [IDLE] (database=piro) at 0x7fd977ae2880>

If you need to create a one-off client-side-binding cursor out of a
normal connection, you can just use the *note ClientCursor: de. class
passing the connection as argument.

     conn = psycopg.connect(DSN)
     cur = psycopg.ClientCursor(conn)

     Warning: Client-side cursors don’t support *note binary parameters
     and return values: 14. and don’t support *note prepared statements:
     12.

     Tip: The best use for client-side binding cursors is probably to
     port large Psycopg 2 code to Psycopg 3, especially for programs
     making wide use of Data Definition Language statements.

     The *note psycopg.sql: 9. module allows for more generic
     client-side query composition, to mix client- and server-side
     parameters binding, and allows to parametrize tables and fields
     names too, or entirely generic SQL snippets.

* Menu:

* Simple query protocol::

   ---------- Footnotes ----------

   (1) https://www.psycopg.org/docs/module.html#module-psycopg2


File: psycopg.info,  Node: Simple query protocol,  Up: Client-side-binding cursors

1.2.5.3 Simple query protocol
.............................

Using the ‘ClientCursor’ should ensure that psycopg will always use the
simple query protocol(1) for querying.  In most cases, the choice of the
fronted/backend protocol used is transparent on PostgreSQL. However, in
some case using the simple query protocol is mandatory.  This is the
case querying the PgBouncer admin console(2) for instance, which doesn’t
support the extended query protocol.

     from psycopg import connect, ClientCursor

     conn = psycopg.connect(ADMIN_DSN, cursor_factory=ClientCursor)
     cur = conn.cursor()
     cur.execute("SHOW STATS")
     cur.fetchall()

Changed in version 3.1.20: While querying using the ‘ClientCursor’ works
well with PgBouncer, the connection’s COMMIT and ROLLBACK commands are
only ensured to be executed using the simple query protocol starting
from Psycopg 3.1.20.

In previous versions you should use an autocommit connection in order to
query the PgBouncer admin console:

     from psycopg import connect, ClientCursor

     conn = psycopg.connect(ADMIN_DSN, cursor_factory=ClientCursor, autocommit=True)
     ...

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-SIMPLE-QUERY

   (2) https://www.pgbouncer.org/usage.html#admin-console


File: psycopg.info,  Node: Server-side cursors,  Next: Raw query cursors,  Prev: Client-side-binding cursors,  Up: Cursor types

1.2.5.4 Server-side cursors
...........................

PostgreSQL has its own concept of 'cursor' too (sometimes also called
'portal').  When a database cursor is created, the query is not
necessarily completely processed: the server might be able to produce
results only as they are needed.  Only the results requested are
transmitted to the client: if the query result is very large but the
client only needs the first few records it is possible to transmit only
them.

The downside is that the server needs to keep track of the partially
processed results, so it uses more memory and resources on the server.

Psycopg allows the use of server-side cursors using the classes *note
ServerCursor: 15f. and *note AsyncServerCursor: 169.  They are usually
created by passing the ‘name’ parameter to the *note cursor(): 37.
method (reason for which, in ‘psycopg2’, they are usually called 'named
cursors').  The use of these classes is similar to their client-side
counterparts: their interface is the same, but behind the scene they
send commands to control the state of the cursor on the server (for
instance when fetching new records or when moving using *note scroll():
16a.).

Using a server-side cursor it is possible to process datasets larger
than what would fit in the client’s memory.  However for small queries
they are less efficient because it takes more commands to receive their
result, so you should use them only if you need to process huge results
or if only a partial result is needed.

See also
........

Server-side cursors are created and managed by *note ServerCursor: 15f.
using SQL commands such as DECLARE(1), FETCH(2), MOVE(3). The PostgreSQL
documentation gives a good idea of what is possible to do with them.

* Menu:

* “Stealing” an existing cursor::

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/sql-declare.html

   (2) https://www.postgresql.org/docs/current/sql-fetch.html

   (3) https://www.postgresql.org/docs/current/sql-move.html


File: psycopg.info,  Node: “Stealing” an existing cursor,  Up: Server-side cursors

1.2.5.5 “Stealing” an existing cursor
.....................................

A Psycopg *note ServerCursor: 15f. can be also used to consume a cursor
which was created in other ways than the ‘DECLARE’ that *note
ServerCursor.execute(): 16d. runs behind the scene.

For instance if you have a PL/pgSQL function returning a cursor(1):

     CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS $$
     BEGIN
         OPEN $1 FOR SELECT col FROM test;
         RETURN $1;
     END;
     $$ LANGUAGE plpgsql;

you can run a one-off command in the same connection to call it (e.g.
using *note Connection.execute(): 44.) in order to create the cursor on
the server:

     conn.execute("SELECT reffunc('curname')")

after which you can create a server-side cursor declared by the same
name, and directly call the fetch methods, skipping the *note execute():
16d. call:

     cur = conn.cursor('curname')
     # no cur.execute()
     for record in cur:  # or cur.fetchone(), cur.fetchmany()...
         # do something with record

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/plpgsql-cursors.html


File: psycopg.info,  Node: Raw query cursors,  Prev: Server-side cursors,  Up: Cursor types

1.2.5.6 Raw query cursors
.........................

Added in version 3.2.

The *note RawCursor: 161. and *note AsyncRawCursor: 16f. classes allow
users to use PostgreSQL native placeholders (‘$1’, ‘$2’, etc.)  in their
queries instead of the standard ‘%s’ placeholder.  This can be useful
when it’s desirable to pass the query unmodified to PostgreSQL and rely
on PostgreSQL’s placeholder functionality, such as when dealing with a
very complex query containing ‘%s’ inside strings, dollar-quoted strings
or elsewhere.

One important note is that raw query cursors only accept positional
arguments in the form of a list or tuple.  This means you cannot use
named arguments (i.e., dictionaries).

‘RawCursor’ behaves like *note Cursor: 36, in returning the complete
result from the server to the client.  The *note RawServerCursor: 163.
and *note AsyncRawServerCursor: 170. implement *note Server-side
cursors: 160. with raw PostgreSQL placeholders.

There are two ways to use raw query cursors:

  1. Using the cursor factory:

     from psycopg import connect, RawCursor

     with connect(dsn, cursor_factory=RawCursor) as conn:
         with conn.cursor() as cur:
             cur.execute("SELECT $1, $2", [1, "Hello"])
             assert cur.fetchone() == (1, "Hello")

  2. Instantiating a cursor:

     from psycopg import connect, RawCursor

     with connect(dsn) as conn:
         with RawCursor(conn) as cur:
             cur.execute("SELECT $1, $2", [1, "Hello"])
             assert cur.fetchone() == (1, "Hello")


File: psycopg.info,  Node: Data adaptation configuration,  Next: Prepared statements,  Prev: Cursor types,  Up: More advanced topics

1.2.6 Data adaptation configuration
-----------------------------------

The adaptation system is at the core of Psycopg and allows to customise
the way Python objects are converted to PostgreSQL when a query is
performed and how PostgreSQL values are converted to Python objects when
query results are returned.

     Note: For a high-level view of the conversion of types between
     Python and PostgreSQL please look at *note Passing parameters to
     SQL queries: 40.  Using the objects described in this page is
     useful if you intend to 'customise' the adaptation rules.

   - Adaptation configuration is performed by changing the *note
     adapters: 173. object of objects implementing the *note
     AdaptContext: 174. protocol, for instance *note Connection: 34. or
     *note Cursor: 36.

   - Every context object derived from another context inherits its
     adapters mapping: cursors created from a connection inherit the
     connection’s configuration.

     By default, connections obtain an adapters map from the global map
     exposed as *note psycopg.adapters: 175.: changing the content of
     this object will affect every connection created afterwards.  You
     may specify a different template adapters map using the ‘context’
     parameter on *note connect(): 33.

 [image src="psycopg-figures/adapt.svg" ]

   - The ‘adapters’ attributes are *note AdaptersMap: 176. instances,
     and contain the mapping from Python types and *note Dumper: 177.
     classes, and from PostgreSQL OIDs to *note Loader: 178. classes.
     Changing this mapping (e.g.  writing and registering your own
     adapters, or using a different configuration of builtin adapters)
     affects how types are converted between Python and PostgreSQL.

        - Dumpers (objects implementing the *note Dumper: 177. protocol)
          are the objects used to perform the conversion from a Python
          object to a bytes sequence in a format understood by
          PostgreSQL. The string returned 'shouldn’t be quoted': the
          value will be passed to the database using functions such as
          ‘PQexecParams()(1)’ so quoting and quotes escaping is not
          necessary.  The dumper usually also suggests to the server
          what type to use, via its *note oid: 179. attribute.

        - Loaders (objects implementing the *note Loader: 178. protocol)
          are the objects used to perform the opposite operation:
          reading a bytes sequence from PostgreSQL and creating a Python
          object out of it.

        - Dumpers and loaders are instantiated on demand by a *note
          Transformer: 17a. object when a query is executed.

     Note: Changing adapters in a context only affects that context and
     its children objects created 'afterwards'; the objects already
     created are not affected.  For instance, changing the global
     context will only change newly created connections, not the ones
     already existing.

* Menu:

* Writing a custom adapter; XML: Writing a custom adapter XML.
* Example; converting empty strings to NULL: Example converting empty strings to NULL.
* Example; PostgreSQL numeric to Python float: Example PostgreSQL numeric to Python float.
* Example; handling infinity date: Example handling infinity date.
* Dumpers and loaders life cycle::

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/17/libpq-exec.html#LIBPQ-PQEXECPARAMS


File: psycopg.info,  Node: Writing a custom adapter XML,  Next: Example converting empty strings to NULL,  Up: Data adaptation configuration

1.2.6.1 Writing a custom adapter: XML
.....................................

Psycopg doesn’t provide adapters for the XML data type, because there
are just too many ways of handling XML in Python.  Creating a loader to
parse the PostgreSQL xml type(1) to ElementTree(2) is very simple, using
the *note psycopg.adapt.Loader: 5d. base class and implementing the
*note load(): 17d. method:

     >>> import xml.etree.ElementTree as ET
     >>> from psycopg.adapt import Loader

     >>> # Create a class implementing the `load()` method.
     >>> class XmlLoader(Loader):
     ...     def load(self, data):
     ...         return ET.fromstring(data)

     >>> # Register the loader on the adapters of a context.
     >>> conn.adapters.register_loader("xml", XmlLoader)

     >>> # Now just query the database returning XML data.
     >>> cur = conn.execute(
     ...     """select XMLPARSE (DOCUMENT '<?xml version="1.0"?>
     ...            <book><title>Manual</title><chapter>...</chapter></book>')
     ...     """)

     >>> elem = cur.fetchone()[0]
     >>> elem
     <Element 'book' at 0x7ffb55142ef0>

The opposite operation, converting Python objects to PostgreSQL, is
performed by dumpers.  The *note psycopg.adapt.Dumper: 5c. base class
makes it easy to implement one: you only need to implement the *note
dump(): 17e. method:

     >>> from psycopg.adapt import Dumper

     >>> class XmlDumper(Dumper):
     ...     # Setting an OID is not necessary but can be helpful
     ...     oid = psycopg.adapters.types["xml"].oid
     ...
     ...     def dump(self, elem):
     ...         return ET.tostring(elem)

     >>> # Register the dumper on the adapters of a context
     >>> conn.adapters.register_dumper(ET.Element, XmlDumper)

     >>> # Now, in that context, it is possible to use ET.Element objects as parameters
     >>> conn.execute("SELECT xpath('//title/text()', %s)", [elem]).fetchone()[0]
     ['Manual']

     Note: You can use a *note TypesRegistry: 17f, exposed by any *note
     AdaptContext: 174, to obtain information on builtin types, in the
     form of a ‘TypeInfo’ object:

          # Global types registry
          >>> psycopg.adapters.types["text"]
          <TypeInfo: text (oid: 25, array oid: 1009)>

          # Types registry on a connection
          >>> conn.adapters.types["integer"]
          <TypeInfo: int4 (oid: 23, array oid: 1007)>

     The same method can be used to get information about extension
     types if they have been registered on that context using the *note
     TypeInfo: 85.*note register(): 84. method:

          >>> (t := psycopg.types.TypeInfo.fetch(conn, "hstore"))
          <TypeInfo: hstore (oid: 770082, array oid: 770087)>

          >>> t.register()  # globally

          >>> psycopg.adapters.types["hstore"]
          <TypeInfo: hstore (oid: 770082, array oid: 770087)>

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/datatype-xml.html

   (2) 
https://docs.python.org/3/library/xml.etree.elementtree.html#module-xml.etree.ElementTree


File: psycopg.info,  Node: Example converting empty strings to NULL,  Next: Example PostgreSQL numeric to Python float,  Prev: Writing a custom adapter XML,  Up: Data adaptation configuration

1.2.6.2 Example: converting empty strings to NULL
.................................................

Changed in version 3.2: The ‘dump()’ method can also return ‘None’,
which will be stored as ‘NULL’ in the database.

If you prefer to store missing values as ‘NULL’, in the database, but
your input may contain empty strings, you can subclass the stock string
dumper to return ‘None’ upon empty or whitespace-only strings:

     >>> from psycopg.types.string import StrDumper

     >>> class NullStrDumper(StrDumper):
     ...     def dump(self, obj):
     ...         if not obj or obj.isspace():
     ...             return None
     ...         return super().dump(obj)

     >>> conn.adapters.register_dumper(str, NullStrDumper)

     >>> conn.execute("select %s, %s, %s, %s", ("foo", "", "bar", "  ")).fetchone()
     ('foo', None, 'bar', None)


File: psycopg.info,  Node: Example PostgreSQL numeric to Python float,  Next: Example handling infinity date,  Prev: Example converting empty strings to NULL,  Up: Data adaptation configuration

1.2.6.3 Example: PostgreSQL numeric to Python float
...................................................

Normally PostgreSQL ‘numeric’ values are converted to Python Decimal(1)
instances, because both the types allow fixed-precision arithmetic and
are not subject to rounding.

Sometimes, however, you may want to perform floating-point math on
‘numeric’ values, and ‘Decimal’ may get in the way (maybe because it is
slower, or maybe because mixing ‘float’ and ‘Decimal’ values causes
Python errors).

If you are fine with the potential loss of precision and you simply want
to receive ‘numeric’ values as Python ‘float’, you can register on
‘numeric’ the same *note Loader: 5d. class used to load
‘float4’/‘float8’ values.  Because the PostgreSQL textual representation
of both floats and decimal is the same, the two loaders are compatible.

     conn = psycopg.connect()

     conn.execute("SELECT 123.45").fetchone()[0]
     # Decimal('123.45')

     conn.adapters.register_loader("numeric", psycopg.types.numeric.FloatLoader)

     conn.execute("SELECT 123.45").fetchone()[0]
     # 123.45

In this example the customised adaptation takes effect only on the
connection ‘conn’ and on any cursor created from it, not on other
connections.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/decimal.html#decimal.Decimal


File: psycopg.info,  Node: Example handling infinity date,  Next: Dumpers and loaders life cycle,  Prev: Example PostgreSQL numeric to Python float,  Up: Data adaptation configuration

1.2.6.4 Example: handling infinity date
.......................................

Suppose you want to work with the “infinity” date which is available in
PostgreSQL but not handled by Python:

     >>> conn.execute("SELECT 'infinity'::date").fetchone()
     Traceback (most recent call last):
        ...
     DataError: date too large (after year 10K): 'infinity'

One possibility would be to store Python’s datetime.date.max(1) as
PostgreSQL infinity.  For this, let’s create a subclass for the dumper
and the loader and register them in the working scope (globally or just
on a connection or cursor):

     from datetime import date

     # Subclass existing adapters so that the base case is handled normally.
     from psycopg.types.datetime import DateLoader, DateDumper

     class InfDateDumper(DateDumper):
         def dump(self, obj):
             if obj == date.max:
                 return b"infinity"
             elif obj == date.min:
                 return b"-infinity"
             else:
                 return super().dump(obj)

     class InfDateLoader(DateLoader):
         def load(self, data):
             if data == b"infinity":
                 return date.max
             elif data == b"-infinity":
                 return date.min
             else:
                 return super().load(data)

     # The new classes can be registered globally, on a connection, on a cursor
     cur.adapters.register_dumper(date, InfDateDumper)
     cur.adapters.register_loader("date", InfDateLoader)

     cur.execute("SELECT %s::text, %s::text", [date(2020, 12, 31), date.max]).fetchone()
     # ('2020-12-31', 'infinity')
     cur.execute("SELECT '2020-12-31'::date, 'infinity'::date").fetchone()
     # (datetime.date(2020, 12, 31), datetime.date(9999, 12, 31))

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/datetime.html#datetime.date.max


File: psycopg.info,  Node: Dumpers and loaders life cycle,  Prev: Example handling infinity date,  Up: Data adaptation configuration

1.2.6.5 Dumpers and loaders life cycle
......................................

Registering dumpers and loaders will instruct Psycopg to use them in the
queries to follow, in the context where they have been registered.

When a query is performed on a *note Cursor: 36, a *note Transformer:
17a. object is created as a local context to manage adaptation during
the query, instantiating the required dumpers and loaders and
dispatching the values to perform the wanted conversions from Python to
Postgres and back.

   - The ‘Transformer’ copies the adapters configuration from the
     ‘Cursor’, thus inheriting all the changes made to the global *note
     psycopg.adapters: 175. configuration, the current ‘Connection’, the
     ‘Cursor’.

   - For every Python type passed as query argument, the ‘Transformer’
     will instantiate a ‘Dumper’.  Usually all the objects of the same
     type will be converted by the same dumper instance.

        - According to the placeholder used (‘%s’, ‘%b’, ‘%t’), Psycopg
          may pick a binary or a text dumper.  When using the ‘%s’
          “*note AUTO: 185.” format, if the same type has both a text
          and a binary dumper registered, the last one registered by
          *note register_dumper(): 186. will be used.

        - Sometimes, just looking at the Python type is not enough to
          decide the best PostgreSQL type to use (for instance the
          PostgreSQL type of a Python list depends on the objects it
          contains, whether to use an ‘integer’ or ‘bigint’ depends on
          the number size…) In these cases the mechanism provided by
          *note get_key(): 187. and *note upgrade(): 188. is used to
          create more specific dumpers.

   - The query is executed.  Upon successful request, the result is
     received as a *note PGresult: 189.

   - For every OID returned by the query, the ‘Transformer’ will
     instantiate a ‘Loader’.  All the values with the same OID will be
     converted by the same loader instance.

   - Recursive types (e.g.  Python lists, PostgreSQL arrays and
     composite types) will use the same adaptation rules.

As a consequence it is possible to perform certain choices only once per
query (e.g.  looking up the connection encoding) and then call a
fast-path operation for each value to convert.

Querying will fail if a Python object for which there isn’t a ‘Dumper’
registered (for the right *note Format: 18a.) is used as query
parameter.  If the query returns a data type whose OID doesn’t have a
‘Loader’, the value will be returned as a string (or bytes string for
binary types).


File: psycopg.info,  Node: Prepared statements,  Next: Pipeline mode support,  Prev: Data adaptation configuration,  Up: More advanced topics

1.2.7 Prepared statements
-------------------------

Psycopg uses an automatic system to manage 'prepared statements'.  When
a query is prepared, its parsing and planning is stored in the server
session, so that further executions of the same query on the same
connection (even with different parameters) are optimised.

A query is prepared automatically after it is executed more than *note
prepare_threshold: 18d. times on a connection.  ‘psycopg’ will make sure
that no more than *note prepared_max: 18e. statements are planned: if
further queries are executed, the least recently used ones are
deallocated and the associated resources freed.

Statement preparation can be controlled in several ways:

   - You can decide to prepare a query immediately by passing
     ‘prepare=True’ to *note Connection.execute(): 44. or *note
     Cursor.execute(): 3a.  The query is prepared, if it wasn’t already,
     and executed as prepared from its first use.

   - Conversely, passing ‘prepare=False’ to ‘execute()’ will avoid to
     prepare the query, regardless of the number of times it is
     executed.  The default for the parameter is ‘None’, meaning that
     the query is prepared if the conditions described above are met.

   - You can disable the use of prepared statements on a connection by
     setting its *note prepare_threshold: 18d. attribute to ‘None’.

Changed in version 3.1: You can set ‘prepare_threshold’ as a *note
connect(): 33. keyword parameter too.

See also
........

The PREPARE(1) PostgreSQL documentation contains plenty of details about
prepared statements in PostgreSQL.

Note however that Psycopg doesn’t use SQL statements such as ‘PREPARE’
and ‘EXECUTE’, but protocol level commands such as the ones exposed by
‘PQsendPrepare(2)’, ‘PQsendQueryPrepared(3)’.

* Menu:

* Using prepared statements with PgBouncer::

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/sql-prepare.html

   (2) 
https://www.postgresql.org/docs/17/libpq-async.html#LIBPQ-PQSENDPREPARE

   (3) 
https://www.postgresql.org/docs/17/libpq-async.html#LIBPQ-PQSENDQUERYPREPARED


File: psycopg.info,  Node: Using prepared statements with PgBouncer,  Up: Prepared statements

1.2.7.1 Using prepared statements with PgBouncer
................................................

     Warning: Unless a connection pooling middleware explicitly declares
     otherwise, they are not compatible with prepared statements,
     because the same client connection may change the server session it
     refers to.  If such middleware is used you should disable prepared
     statements, by setting the *note Connection.prepare_threshold: 18d.
     attribute to ‘None’.

Starting from 3.2, Psycopg supports prepared statements when using the
PgBouncer(1) middleware, using the following caveats:

   - PgBouncer version must be version 1.22(2) or newer.

   - PgBouncer max_prepared_statements(3) must be greater than 0.

   - The libpq version on the client must be from PostgreSQL 17 or newer
     (you can check the *note has_send_close_prepared(): 191. capability
     to verify that the libpq implements the features required by
     PgBouncer).

     Hint: If libpq 17 is not available on your client, but PgBouncer is
     1.22 or higher, you can still use Psycopg 'as long as you disable
     deallocation'.

     You can do so by setting *note Connection.prepared_max: 18e. to
     ‘None’.

   ---------- Footnotes ----------

   (1) https://www.pgbouncer.org/

   (2) https://www.pgbouncer.org/2024/01/pgbouncer-1-22-0

   (3) https://www.pgbouncer.org/config.html#max_prepared_statements


File: psycopg.info,  Node: Pipeline mode support,  Prev: Prepared statements,  Up: More advanced topics

1.2.8 Pipeline mode support
---------------------------

Added in version 3.1.

The 'pipeline mode' allows PostgreSQL client applications to send a
query without having to read the result of the previously sent query.
Taking advantage of the pipeline mode, a client will wait less for the
server, since multiple queries/results can be sent/received in a single
network roundtrip.  Pipeline mode can provide a significant performance
boost to the application.

Pipeline mode is most useful when the server is distant, i.e., network
latency (“ping time”) is high, and also when many small operations are
being performed in rapid succession.  There is usually less benefit in
using pipelined commands when each query takes many multiples of the
client/server round-trip time to execute.  A 100-statement operation run
on a server 300 ms round-trip-time away would take 30 seconds in network
latency alone without pipelining; with pipelining it may spend as little
as 0.3 s waiting for results from the server.

The server executes statements, and returns results, in the order the
client sends them.  The server will begin executing the commands in the
pipeline immediately, not waiting for the end of the pipeline.  Note
that results are buffered on the server side; the server flushes that
buffer when a *note synchronization point: 194. is established.

See also
........

The PostgreSQL documentation about:

   - pipeline mode(1)

   - extended query message flow(2)

contains many details around when it is most useful to use the pipeline
mode and about errors management and interaction with transactions.

* Menu:

* Client-server messages flow::
* Pipeline mode usage::
* Synchronization points::
* The fine prints::

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/libpq-pipeline-mode.html

   (2) 
https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY


File: psycopg.info,  Node: Client-server messages flow,  Next: Pipeline mode usage,  Up: Pipeline mode support

1.2.8.1 Client-server messages flow
...................................

In order to understand better how the pipeline mode works, we should
take a closer look at the PostgreSQL client-server message flow(1).

During normal querying, each statement is transmitted by the client to
the server as a stream of request messages, terminating with a 'Sync'
message to tell it that it should process the messages sent so far.  The
server will execute the statement and describe the results back as a
stream of messages, terminating with a 'ReadyForQuery', telling the
client that it may now send a new query.

For example, the statement (returning no result):

     conn.execute("INSERT INTO mytable (data) VALUES (%s)", ["hello"])

results in the following two groups of messages:

Direction           Message
                    
------------------------------------------------------------------------------------
Python                 - Parse ‘INSERT INTO ... (VALUE $1)’ (skipped if
                         *note the statement is prepared: 12.)
▶                   
                       - Bind ‘'hello'’
PostgreSQL          
                       - Describe
                    
                       - Execute
                    
                       - Sync
                    
PostgreSQL             - ParseComplete
                    
◀                      - BindComplete
                    
Python                 - NoData
                    
                       - CommandComplete ‘INSERT 0 1’
                    
                       - ReadyForQuery
                    

and the query:

     conn.execute("SELECT data FROM mytable WHERE id = %s", [1])

results in the two groups of messages:

Direction           Message
                    
------------------------------------------------------------------------------------
Python                 - Parse ‘SELECT data FROM mytable WHERE id = $1’
                    
▶                      - Bind ‘1’
                    
PostgreSQL             - Describe
                    
                       - Execute
                    
                       - Sync
                    
PostgreSQL             - ParseComplete
                    
◀                      - BindComplete
                    
Python                 - RowDescription ‘data’
                    
                       - DataRow ‘hello’
                    
                       - CommandComplete ‘SELECT 1’
                    
                       - ReadyForQuery
                    

The two statements, sent consecutively, pay the communication overhead
four times, once per leg.

The pipeline mode allows the client to combine several operations in
longer streams of messages to the server, then to receive more than one
response in a single batch.  If we execute the two operations above in a
pipeline:

     with conn.pipeline():
         conn.execute("INSERT INTO mytable (data) VALUES (%s)", ["hello"])
         conn.execute("SELECT data FROM mytable WHERE id = %s", [1])

they will result in a single roundtrip between the client and the
server:

Direction           Message
                    
------------------------------------------------------------------------------------
Python                 - Parse ‘INSERT INTO ... (VALUE $1)’
                    
▶                      - Bind ‘'hello'’
                    
PostgreSQL             - Describe
                    
                       - Execute
                    
                       - Parse ‘SELECT data FROM mytable WHERE id = $1’
                    
                       - Bind ‘1’
                    
                       - Describe
                    
                       - Execute
                    
                       - Sync (sent only once)
                    
PostgreSQL             - ParseComplete
                    
◀                      - BindComplete
                    
Python                 - NoData
                    
                       - CommandComplete ‘INSERT 0 1’
                    
                       - ParseComplete
                    
                       - BindComplete
                    
                       - RowDescription ‘data’
                    
                       - DataRow ‘hello’
                    
                       - CommandComplete ‘SELECT 1’
                    
                       - ReadyForQuery (sent only once)
                    

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/protocol-flow.html


File: psycopg.info,  Node: Pipeline mode usage,  Next: Synchronization points,  Prev: Client-server messages flow,  Up: Pipeline mode support

1.2.8.2 Pipeline mode usage
...........................

Psycopg supports the pipeline mode via the *note Connection.pipeline():
198. method.  The method is a context manager: entering the ‘with’ block
yields a *note Pipeline: 199. object.  At the end of block, the
connection resumes the normal operation mode.

Within the pipeline block, you can use normally one or more cursors to
execute several operations, using *note Connection.execute(): 44, *note
Cursor.execute(): 3a. and *note executemany(): 3b.

     >>> with conn.pipeline():
     ...     conn.execute("INSERT INTO mytable VALUES (%s)", ["hello"])
     ...     with conn.cursor() as cur:
     ...         cur.execute("INSERT INTO othertable VALUES (%s)", ["world"])
     ...         cur.executemany(
     ...             "INSERT INTO elsewhere VALUES (%s)",
     ...             [("one",), ("two",), ("four",)])

Unlike in normal mode, Psycopg will not wait for the server to receive
the result of each query; the client will receive results in batches
when the server flushes it output buffer.  You can receive more than a
single result by using more than one cursor in the same pipeline.

If any statement encounters an error, the server aborts the current
transaction and will not execute any subsequent command in the queue
until the next *note synchronization point: 194.; a *note
PipelineAborted: 19a. exception is raised for each such command.  Query
processing resumes after the synchronization point.

     Warning: Certain features are not available in pipeline mode,
     including:

        - COPY is not supported in pipeline mode by PostgreSQL.

        - *note Cursor.stream(): 19b. doesn’t make sense in pipeline
          mode (its job is the opposite of batching!)

        - *note ServerCursor: 15f. are currently not implemented in
          pipeline mode.

     Note: Starting from Psycopg 3.1, *note executemany(): 3b. makes use
     internally of the pipeline mode; as a consequence there is no need
     to handle a pipeline block just to call ‘executemany()’ once.


File: psycopg.info,  Node: Synchronization points,  Next: The fine prints,  Prev: Pipeline mode usage,  Up: Pipeline mode support

1.2.8.3 Synchronization points
..............................

Flushing query results to the client can happen either when a
synchronization point is established by Psycopg:

   - using the *note Pipeline.sync(): 19d. method;

   - on *note Connection.commit(): 38. or *note rollback(): 39.;

   - at the end of a ‘Pipeline’ block;

   - possibly when opening a nested ‘Pipeline’ block;

   - using a fetch method such as *note Cursor.fetchone(): 3c. (which
     only flushes the query but doesn’t issue a Sync and doesn’t reset a
     pipeline state error).

The server might perform a flush on its own initiative, for instance
when the output buffer is full.

Note that, even in *note autocommit: a9, the server wraps the statements
sent in pipeline mode in an implicit transaction, which will be only
committed when the Sync is received.  As such, a failure in a group of
statements will probably invalidate the effect of statements executed
after the previous Sync, and will propagate to the following Sync.

For example, in the following block:

     >>> with psycopg.connect(autocommit=True) as conn:
     ...     with conn.pipeline() as p, conn.cursor() as cur:
     ...         try:
     ...             cur.execute("INSERT INTO mytable (data) VALUES (%s)", ["one"])
     ...             cur.execute("INSERT INTO no_such_table (data) VALUES (%s)", ["two"])
     ...             conn.execute("INSERT INTO mytable (data) VALUES (%s)", ["three"])
     ...             p.sync()
     ...         except psycopg.errors.UndefinedTable:
     ...             pass
     ...         cur.execute("INSERT INTO mytable (data) VALUES (%s)", ["four"])

there will be an error in the block, ‘relation "no_such_table" does not
exist’ caused by the insert ‘two’, but probably raised by the ‘sync()’
call.  At at the end of the block, the table will contain:

     =# SELECT * FROM mytable;
     +----+------+
     | id | data |
     +----+------+
     |  2 | four |
     +----+------+
     (1 row)

because:

   - the value 1 of the sequence is consumed by the statement ‘one’, but
     the record discarded because of the error in the same implicit
     transaction;

   - the statement ‘three’ is not executed because the pipeline is
     aborted (so it doesn’t consume a sequence item);

   - the statement ‘four’ is executed with success after the Sync has
     terminated the failed transaction.

     Warning: The exact Python statement where an exception caused by a
     server error is raised is somewhat arbitrary: it depends on when
     the server flushes its buffered result.

     If you want to make sure that a group of statements is applied
     atomically by the server, do make use of transaction methods such
     as *note commit(): 38. or *note transaction(): 47.: these methods
     will also sync the pipeline and raise an exception if there was any
     error in the commands executed so far.


File: psycopg.info,  Node: The fine prints,  Prev: Synchronization points,  Up: Pipeline mode support

1.2.8.4 The fine prints
.......................

     Warning: The Pipeline mode is an experimental feature.

     Its behaviour, especially around error conditions and concurrency,
     hasn’t been explored as much as the normal request-response
     messages pattern, and its async nature makes it inherently more
     complex.

     As we gain more experience and feedback (which is welcome), we
     might find bugs and shortcomings forcing us to change the current
     interface or behaviour.

The pipeline mode is available on any currently supported PostgreSQL
version, but, in order to make use of it, the client must use a libpq
from PostgreSQL 14 or higher.  You can use the *note has_pipeline: 19f.
capability to make sure your client has the right library.


File: psycopg.info,  Node: Psycopg 3 API,  Next: Release notes,  Prev: More advanced topics,  Up: Documentation

1.3 Psycopg 3 API
=================

This sections is a reference for all the public objects exposed by the
*note psycopg: 0. module.  For a more conceptual description you can
take a look at *note Getting started with Psycopg 3: 1a. and *note More
advanced topics: 101.

* Menu:

* The psycopg module::
* Connection classes::
* Cursor classes::
* COPY-related objects::
* Other top-level objects::
* sql – SQL string composition::
* rows – row factory implementations::
* errors – Package exceptions::
* psycopg_pool – Connection pool implementations::
* conninfo – manipulate connection strings::
* adapt – Types adaptation::
* types – Types information and adapters::
* abc – Psycopg abstract classes::
* pq – libpq wrapper module::
* crdb – CockroachDB support::
* _dns – DNS resolution utilities::


File: psycopg.info,  Node: The psycopg module,  Next: Connection classes,  Up: Psycopg 3 API

1.3.1 The ‘psycopg’ module
--------------------------

Psycopg implements the Python Database DB API 2.0 specification(1).  As
such it also exposes the module-level objects(2) required by the
specifications.

 -- Function: psycopg.connect (conninfo: str = '', *, autocommit: bool =
          False, prepare_threshold: int | None = 5, context:
          AdaptContext | None = None, row_factory: RowFactory[Row] |
          None = None, cursor_factory: type[Cursor[Row]] | None = None,
          **kwargs: str | int | None) -> Self

     Connect to a database server and return a new *note Connection: 34.
     instance.

     This is an alias of the class method *note Connection.connect: 33.:
     see its documentation for details.

     If you need an asynchronous connection use *note
     AsyncConnection.connect: 35. instead.

 -- Data: psycopg.capabilities

     An object that can be used to verify that the client library used
     by psycopg implements a certain feature.  For instance:

          # Fail at import time if encrypted passwords is not available
          import psycopg
          psycopg.capabilities.has_encrypt_password(check=True)

          # Verify at runtime if a feature can be used
          if psycopg.capabilities.has_hostaddr():
              print(conn.info.hostaddr)
          else:
              print("unknown connection hostadd")


     Type: *note Capabilities: 1a6.

     Added in version 3.2.

Exceptions
..........

The standard DBAPI exceptions(3) are exposed both by the ‘psycopg’
module and by the *note psycopg.errors: 6. module.  The latter also
exposes more specific exceptions, mapping to the database error states
(see *note SQLSTATE exceptions: 1a7.).

     Exception
     |__ *note Warning: 1a8.
     |__ *note Error: 1a9.
         |__ *note InterfaceError: 1aa.
         |__ *note DatabaseError: 112.
             |__ *note DataError: 6f.
             |__ *note OperationalError: 1ab.
             |__ *note IntegrityError: 1ac.
             |__ *note InternalError: 1ad.
             |__ *note ProgrammingError: 1ae.
             |__ *note NotSupportedError: 1af.

 -- Data: psycopg.adapters

     The default adapters map establishing how Python and PostgreSQL
     types are converted into each other.

     This map is used as a template when new connections are created,
     using *note psycopg.connect(): 48.  Its *note types: 1b0. attribute
     is a *note TypesRegistry: 17f. containing information about every
     PostgreSQL builtin type, useful for adaptation customisation (see
     *note Data adaptation configuration: 4e.):

          >>> psycopg.adapters.types["int4"]
          <TypeInfo: int4 (oid: 23, array oid: 1007)>


     Type: *note AdaptersMap: 176.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0249/

   (2) https://www.python.org/dev/peps/pep-0249/#module-interface

   (3) https://www.python.org/dev/peps/pep-0249/#exceptions


File: psycopg.info,  Node: Connection classes,  Next: Cursor classes,  Prev: The psycopg module,  Up: Psycopg 3 API

1.3.2 Connection classes
------------------------

The *note Connection: 34. and *note AsyncConnection: 4a. classes are the
main wrappers for a PostgreSQL database session.  You can imagine them
similar to a ‘psql’ session.

One of the differences compared to ‘psql’ is that a *note Connection:
34. usually handles a transaction automatically: other sessions will not
be able to see the changes until you have committed them, more or less
explicitly.  Take a look to *note Transactions management: 42. for the
details.

* Menu:

* The Connection class::
* The AsyncConnection class::


File: psycopg.info,  Node: The Connection class,  Next: The AsyncConnection class,  Up: Connection classes

1.3.2.1 The ‘Connection’ class
..............................

 -- Class: psycopg.Connection

     Wrapper for a connection to the database.

     This class implements a DBAPI-compliant interface(1).  It is what
     you want to use if you write a “classic”, blocking program
     (eventually using threads or Eventlet/gevent for concurrency).  If
     your program uses asyncio(2) you might want to use *note
     AsyncConnection: 4a. instead.

     Connections behave as context managers: on block exit, the current
     transaction will be committed (or rolled back, in case of
     exception) and the connection will be closed.

      -- Method: classmethod connect (conninfo: str = '', *, autocommit:
               bool = False, prepare_threshold: int | None = 5, context:
               AdaptContext | None = None, row_factory: RowFactory[Row]
               | None = None, cursor_factory: type[Cursor[Row]] | None =
               None, **kwargs: str | int | None) -> Self

          Connect to a database server and return a new *note
          Connection: 34. instance.


          Parameters:

             * ‘conninfo’ – The connection string(3) (a ‘postgresql://’
               url or a list of ‘key=value’ pairs) to specify where and
               how to connect.

             * ‘kwargs’ – Further parameters specifying the connection
               string.  They override the ones specified in ‘conninfo’.

             * ‘autocommit’ – If ‘True’ don’t start transactions
               automatically.  See *note Transactions management: 42.
               for details.

             * ‘row_factory’ – The row factory specifying what type of
               records to create fetching data (default: *note
               tuple_row(): 1b4.).  See *note Row factories: 4d. for
               details.

             * ‘cursor_factory’ – Initial value for the *note
               cursor_factory: df. attribute of the connection (new in
               Psycopg 3.1).

             * ‘prepare_threshold’ – Initial value for the *note
               prepare_threshold: 18d. attribute of the connection (new
               in Psycopg 3.1).

          More specialized use:


          Parameters: ‘context’ – A context to copy the initial adapters
          configuration from.  It might be an *note AdaptersMap: 176.
          with customized loaders and dumpers, used as a template to
          create several connections.  See *note Data adaptation
          configuration: 4e. for further details.

          This method is also aliased as *note psycopg.connect(): 48.

          See also
          ........

             - the list of the accepted connection parameters(4)

             - the environment variables(5) affecting connection

          Changed in version 3.1: added ‘prepare_threshold’ and
          ‘cursor_factory’ parameters.

      -- Method: close () -> None

          Close the database connection.

               Note: You can use:

                    with psycopg.connect() as conn:
                        ...

               to close the connection automatically when the block is
               exited.  See *note Connection context: 46.

      -- Attribute: closed

          ‘True’ if the connection is closed.

      -- Attribute: broken

          ‘True’ if the connection was interrupted.

          A broken connection is always *note closed: 1b5, but wasn’t
          closed in a clean way, such as using *note close(): 49. or a
          ‘with’ block.

      -- Method: cursor (*, binary: bool = False, row_factory:
               RowFactory | None = None) -> Cursor

      -- Method: cursor (name: str, *, binary: bool = False,
               row_factory: RowFactory | None = None, scrollable: bool |
               None = None, withhold: bool = False) -> ServerCursor

          Return a new cursor to send commands and queries to the
          connection.


          Parameters:

             * ‘name’ – If not specified create a client-side cursor, if
               specified create a server-side cursor.  See *note Cursor
               types: 15c. for details.

             * ‘binary’ – If ‘True’ return binary values from the
               database.  All the types returned by the query must have
               a binary loader.  See *note Binary parameters and
               results: 14. for details.

             * ‘row_factory’ – If specified override the *note
               row_factory: 135. set on the connection.  See *note Row
               factories: 4d. for details.

             * ‘scrollable’ – Specify the *note scrollable: 1b7.
               property of the server-side cursor created.

             * ‘withhold’ – Specify the *note withhold: 1b8. property of
               the server-side cursor created.


          Returns: A cursor of the class specified by *note
          cursor_factory: df. (or *note server_cursor_factory: 1b9. if
          ‘name’ is specified).

               Note: You can use:

                    with conn.cursor() as cur:
                        ...

               to close the cursor automatically when the block is
               exited.

      -- Attribute: cursor_factory: type(6)[*note Cursor: 36.[Row]]

          The type, or factory function, returned by *note cursor(): 37.
          and *note execute(): 44.

          Default is *note psycopg.Cursor: 36.

      -- Attribute: server_cursor_factory: type(7)[*note ServerCursor:
               15f.[Row]]

          The type, or factory function, returned by *note cursor(): 37.
          when a name is specified.

          Default is *note psycopg.ServerCursor: 15f.

      -- Attribute: row_factory: *note RowFactory: 13d.[Row]

          The row factory defining the type of rows returned by *note
          fetchone(): 3c. and the other cursor fetch methods.

          The default is *note tuple_row: 1b4, which means that the
          fetch methods will return simple tuples.

          See also
          ........

          See *note Row factories: 4d. for details about defining the
          objects returned by cursors.

      -- Method: execute (query: Query, params: Params | None = None, *,
               prepare: bool | None = None, binary: bool = False) ->
               Cursor[Row]

          Execute a query and return a cursor to read its results.


          Parameters:

             * ‘query’ (‘str’, ‘bytes’, *note sql.SQL: 131, or *note
               sql.Composed: 1ba.) – The query to execute.

             * ‘params’ (‘Sequence’‘ or ’‘Mapping’) – The parameters to
               pass to the query, if any.

             * ‘prepare’ – Force (‘True’) or disallow (‘False’)
               preparation of the query.  By default (‘None’) prepare
               automatically.  See *note Prepared statements: 12.

             * ‘binary’ – If ‘True’ the cursor will return binary values
               from the database.  All the types returned by the query
               must have a binary loader.  See *note Binary parameters
               and results: 14. for details.

          The method simply creates a *note Cursor: 36. instance, *note
          execute(): 3a. the query requested, and returns it.

          See *note Passing parameters to SQL queries: 40. for all the
          details about executing queries.

      -- Method: pipeline () -> Iterator[Pipeline]

          Context manager to switch the connection into pipeline mode.

          The method is a context manager: you should call it using:

               with conn.pipeline() as p:
                   ...

          At the end of the block, a synchronization point is
          established and the connection returns in normal mode.

          You can call the method recursively from within a pipeline
          block.  Innermost blocks will establish a synchronization
          point on exit, but pipeline mode will be kept until the
          outermost block exits.

          See *note Pipeline mode support: 13. for details.

          Added in version 3.1.

     Transaction management methods
     ..............................

     For details see *note Transactions management: 42.

      -- Method: commit () -> None

          Commit any pending transaction to the database.

      -- Method: rollback () -> None

          Roll back to the start of any pending transaction.

      -- Method: transaction (savepoint_name: str | None = None,
               force_rollback: bool = False) -> Iterator[Transaction]

          Start a context block with a new transaction or nested
          transaction.


          Parameters:

             * ‘savepoint_name’ – Name of the savepoint used to manage a
               nested transaction.  If ‘None’, one will be chosen
               automatically.

             * ‘force_rollback’ – Roll back the transaction at the end
               of the block even if there were no error (e.g.  to try a
               no-op process).


          Return type: *note Transaction: 1bb.

               Note: The method must be called with a syntax such as:

                    with conn.transaction():
                        ...

                    with conn.transaction() as tx:
                        ...

               The latter is useful if you need to interact with the
               *note Transaction: 1bb. object.  See *note Transaction
               contexts: aa. for details.

          Inside a transaction block it will not be possible to call
          *note commit(): 38. or *note rollback(): 39.

      -- Attribute: autocommit

          The autocommit state of the connection.

          The property is writable for sync connections, read-only for
          async ones: you should call ‘await’ *note set_autocommit: 1bc.
          ‘(VALUE)’ instead.

      -- Method: set_autocommit (value: bool) -> None

          Method version of the *note autocommit: ab. setter.

          Added in version 3.2.

     The following three properties control the characteristics of new
     transactions.  See *note Transaction characteristics: b2. for
     details.

      -- Attribute: isolation_level

          The isolation level of the new transactions started on the
          connection.

          ‘None’ means use the default set in the
          default_transaction_isolation(8) configuration parameter of
          the server.

      -- Method: set_isolation_level (value: IsolationLevel | None) ->
               None

          Method version of the *note isolation_level: b4. setter.

          Added in version 3.2.

      -- Attribute: read_only

          The read-only state of the new transactions started on the
          connection.

          ‘None’ means use the default set in the
          default_transaction_read_only(9) configuration parameter of
          the server.

      -- Method: set_read_only (value: bool | None) -> None

          Method version of the *note read_only: b5. setter.

          Added in version 3.2.

      -- Attribute: deferrable

          The deferrable state of the new transactions started on the
          connection.

          ‘None’ means use the default set in the
          default_transaction_deferrable(10) configuration parameter of
          the server.

      -- Method: set_deferrable (value: bool | None) -> None

          Method version of the *note deferrable: b6. setter.

          Added in version 3.2.

     Checking and configuring the connection state
     .............................................

      -- Attribute: pgconn: *note psycopg.pq.PGconn: 1c1.

          The *note PGconn: 1c1. libpq connection wrapper underlying the
          ‘Connection’.

          It can be used to send low level commands to PostgreSQL and
          access features not currently wrapped by Psycopg.

      -- Attribute: info

          A *note ConnectionInfo: 1c3. attribute to inspect connection
          properties.

      -- Attribute: prepare_threshold

          Number of times a query is executed before it is prepared.

             - If it is set to 0, every query is prepared the first time
               it is executed.

             - If it is set to ‘None’, prepared statements are disabled
               on the connection.

          Default value: 5

          See *note Prepared statements: 12. for details.

      -- Attribute: prepared_max

          Maximum number of prepared statements on the connection.

          ‘None’ means no max number of prepared statements.  The
          default value is 100.

          If more queries need to be prepared, old ones are
          deallocated(11).

          Specifying ‘None’ can be useful for middleware that don’t
          support deallocation; see *note prepared statements notes:
          18f.

          Changed in version 3.2: Added support for the ‘None’ value.

     Methods you can use to do something cool
     ........................................

      -- Method: cancel_safe (*, timeout: float = 30.0) -> None

          Cancel the current operation on the connection.


          Parameters: ‘timeout’ – raise a *note CancellationTimeout:
          1c5. if the cancellation request does not succeed within
          ‘timeout’ seconds.

          Note that a successful cancel attempt on the client is not a
          guarantee that the server will successfully manage to cancel
          the operation.

          This is a non-blocking version of *note cancel(): 10d. which
          leverages a more secure and improved cancellation feature of
          the libpq, which is only available from version 17.

          If the underlying libpq is older than version 17, the method
          will fall back to using the same implementation of ‘cancel()’.

               Note: You can use the *note has_cancel_safe: 1c6.
               capability to check if ‘cancel_safe()’ will not fall back
               on the legacy libpq functions.

               Warning: The ‘timeout’ parameter has no effect for libpq
               older than version 17.

               Warning: This method shouldn’t be used as a signal(12)
               handler.  Please use *note cancel(): 10d. instead.

          Added in version 3.2.

      -- Method: cancel () -> None

          Cancel the current operation on the connection.

               Warning: The ‘cancel()’ method is implemented using the
               ‘PQcancel(13)’ function, which is deprecated since
               PostgreSQL 17, and has a few shortcomings:

                  - it is blocking even on async connections,

                  - it might use an insecure connection(14) even if the
                    original connection was secure.

               Therefore you should use the *note cancel_safe(): 1c4.
               method whenever possible.

               Note: Unlike *note cancel_safe(): 1c4, it is safe to call
               this method as a signal(15) handler.  This is pretty much
               the only case in which you might want to use this
               function.

      -- Method: notifies (*, timeout: float | None = None, stop_after:
               int | None = None) -> Generator[Notify, None, None]

          Yield *note Notify: 118. objects as soon as they are received
          from the database.


          Parameters:

             * ‘timeout’ – maximum amount of time to wait for
               notifications.  ‘None’ means no timeout.

             * ‘stop_after’ – stop after receiving this number of
               notifications.  You might actually receive more than this
               number if more than one notifications arrives in the same
               packet.

          Notifies are received after using ‘LISTEN’ in a connection,
          when any sessions in the database generates a ‘NOTIFY’ on one
          of the listened channels.

          Changed in version 3.2: Added ‘timeout’ and ‘stop_after’
          parameters.

      -- Method: add_notify_handler (callback: Callable[[Notify], None])
               -> None

          Register a callable to be invoked whenever a notification is
          received.


          Parameters: ‘callback’ (‘Callable’‘[’‘[’*note Notify:
          118.‘]’‘, ’‘None’‘]’) – the callback to call upon notification
          received.

          See *note Asynchronous notifications: 116. for details.

      -- Method: remove_notify_handler (callback: Callable[[Notify],
               None]) -> None

          Unregister a notification callable previously registered.


          Parameters: ‘callback’ (‘Callable’‘[’‘[’*note Notify:
          118.‘]’‘, ’‘None’‘]’) – the callback to remove.

      -- Method: add_notice_handler (callback: Callable[[Diagnostic],
               None]) -> None

          Register a callable to be invoked when a notice message is
          received.


          Parameters: ‘callback’ (‘Callable’‘[’‘[’*note Diagnostic:
          114.‘]’‘, ’‘None’‘]’) – the callback to call upon message
          received.

          See *note Server messages: 110. for details.

      -- Method: remove_notice_handler (callback: Callable[[Diagnostic],
               None]) -> None

          Unregister a notice message callable previously registered.


          Parameters: ‘callback’ (‘Callable’‘[’‘[’*note Diagnostic:
          114.‘]’‘, ’‘None’‘]’) – the callback to remove.

      -- Method: fileno () -> int

          Return the file descriptor of the connection.

          This function allows to use the connection as file-like object
          in functions waiting for readiness, such as the ones defined
          in the selectors(16) module.

     Two-Phase Commit support methods
     ................................

     Added in version 3.1.

     See also
     ........

     *note Two-Phase Commit protocol support: bb. for an introductory
     explanation of these methods.

      -- Method: xid (format_id: int, gtrid: str, bqual: str) -> Xid

          Returns a *note Xid: c3. to pass to the ‘tpc_*()’ methods of
          this connection.

          The argument types and constraints are explained in *note
          Two-Phase Commit protocol support: bb.

          The values passed to the method will be available on the
          returned object as the members *note format_id: 1c9, *note
          gtrid: 1ca, *note bqual: 1cb.

      -- Method: tpc_begin (xid: Xid | str) -> None

          Begin a TPC transaction with the given transaction ID ‘xid’.


          Parameters: ‘xid’ (*note Xid: c3.‘ or ’str(17)) – The id of
          the transaction

          This method should be called outside of a transaction (i.e.
          nothing may have executed since the last *note commit(): 38.
          or *note rollback(): 39. and *note transaction_status: 1cc. is
          *note IDLE: 1cd.).

          Furthermore, it is an error to call ‘commit()’ or ‘rollback()’
          within the TPC transaction: in this case a *note
          ProgrammingError: 1ae. is raised.

          The ‘xid’ may be either an object returned by the *note xid():
          bd. method or a plain string: the latter allows to create a
          transaction using the provided string as PostgreSQL
          transaction id.  See also *note tpc_recover(): c2.

      -- Method: tpc_prepare () -> None

          Perform the first phase of a transaction started with *note
          tpc_begin(): be.

          A *note ProgrammingError: 1ae. is raised if this method is
          used outside of a TPC transaction.

          After calling ‘tpc_prepare()’, no statements can be executed
          until *note tpc_commit(): c0. or *note tpc_rollback(): c1.
          will be called.

          See also
          ........

          The PREPARE TRANSACTION(18) PostgreSQL command.

      -- Method: tpc_commit (xid: Xid | str | None = None) -> None

          Commit a prepared two-phase transaction.


          Parameters: ‘xid’ (*note Xid: c3.‘ or ’str(19)) – The id of
          the transaction

          When called with no arguments, ‘tpc_commit()’ commits a TPC
          transaction previously prepared with *note tpc_prepare(): bf.

          If ‘tpc_commit()’ is called prior to ‘tpc_prepare()’, a single
          phase commit is performed.  A transaction manager may choose
          to do this if only a single resource is participating in the
          global transaction.

          When called with a transaction ID ‘xid’, the database commits
          the given transaction.  If an invalid transaction ID is
          provided, a *note ProgrammingError: 1ae. will be raised.  This
          form should be called outside of a transaction, and is
          intended for use in recovery.

          On return, the TPC transaction is ended.

          See also
          ........

          The COMMIT PREPARED(20) PostgreSQL command.

      -- Method: tpc_rollback (xid: Xid | str | None = None) -> None

          Roll back a prepared two-phase transaction.


          Parameters: ‘xid’ (*note Xid: c3.‘ or ’str(21)) – The id of
          the transaction

          When called with no arguments, ‘tpc_rollback()’ rolls back a
          TPC transaction.  It may be called before or after *note
          tpc_prepare(): bf.

          When called with a transaction ID ‘xid’, it rolls back the
          given transaction.  If an invalid transaction ID is provided,
          a *note ProgrammingError: 1ae. is raised.  This form should be
          called outside of a transaction, and is intended for use in
          recovery.

          On return, the TPC transaction is ended.

          See also
          ........

          The ROLLBACK PREPARED(22) PostgreSQL command.

      -- Method: tpc_recover () -> list[Xid]

          Returns a list of *note Xid: c3. representing pending
          transactions, suitable for use with *note tpc_commit(): c0. or
          *note tpc_rollback(): c1.

          If a transaction was not initiated by Psycopg, the returned
          Xids will have attributes *note format_id: 1c9. and *note
          bqual: 1cb. set to ‘None’ and the *note gtrid: 1ca. set to the
          PostgreSQL transaction ID: such Xids are still usable for
          recovery.  Psycopg uses the same algorithm of the PostgreSQL
          JDBC driver(23) to encode a XA triple in a string, so
          transactions initiated by a program using such driver should
          be unpacked correctly.

          Xids returned by ‘tpc_recover()’ also have extra attributes
          *note prepared: 1ce, *note owner: 1cf, *note database: 1d0.
          populated with the values read from the server.

          See also
          ........

          the pg_prepared_xacts(24) system view.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0249/#connection-objects

   (2) https://docs.python.org/3/library/asyncio.html#module-asyncio

   (3) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING

   (4) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS

   (5) https://www.postgresql.org/docs/current/libpq-envars.html

   (6) https://docs.python.org/3/library/functions.html#type

   (7) https://docs.python.org/3/library/functions.html#type

   (8) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-ISOLATION

   (9) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-READ-ONLY

   (10) 
https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-DEFAULT-TRANSACTION-DEFERRABLE

   (11) https://www.postgresql.org/docs/current/sql-deallocate.html

   (12) https://docs.python.org/3/library/signal.html#signal.signal

   (13) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCEL

   (14) 
https://www.postgresql.org/docs/devel/libpq-cancel.html#LIBPQ-CANCEL-DEPRECATED

   (15) https://docs.python.org/3/library/signal.html#signal.signal

   (16) 
https://docs.python.org/3/library/selectors.html#module-selectors

   (17) https://docs.python.org/3/library/stdtypes.html#str

   (18) 
https://www.postgresql.org/docs/current/static/sql-prepare-transaction.html

   (19) https://docs.python.org/3/library/stdtypes.html#str

   (20) 
https://www.postgresql.org/docs/current/static/sql-commit-prepared.html

   (21) https://docs.python.org/3/library/stdtypes.html#str

   (22) 
https://www.postgresql.org/docs/current/static/sql-rollback-prepared.html

   (23) https://jdbc.postgresql.org/

   (24) 
https://www.postgresql.org/docs/current/static/view-pg-prepared-xacts.html


File: psycopg.info,  Node: The AsyncConnection class,  Prev: The Connection class,  Up: Connection classes

1.3.2.2 The ‘AsyncConnection’ class
...................................

 -- Class: psycopg.AsyncConnection

     Wrapper for a connection to the database.

     This class implements a DBAPI-inspired interface, with all the
     blocking methods implemented as coroutines.  Unless specified
     otherwise, non-blocking methods are shared with the *note
     Connection: 34. class.

     The following methods have the same behaviour of the matching
     ‘Connection’ methods, but should be called using the ‘await’
     keyword.

      -- Method: async classmethod connect (conninfo: str = '', *,
               autocommit: bool = False, prepare_threshold: int | None =
               5, context: AdaptContext | None = None, row_factory:
               AsyncRowFactory[Row] | None = None, cursor_factory:
               type[AsyncCursor[Row]] | None = None, **kwargs: str | int
               | None) -> Self

          Connect to a database server and return a new *note
          AsyncConnection: 4a. instance.

          Changed in version 3.1: Automatically resolve domain names
          asynchronously.  In previous versions, name resolution blocks,
          unless the ‘hostaddr’ parameter is specified, or the *note
          resolve_hostaddr_async(): 108. function is used.

      -- Method: async close () -> None

          Close the database connection.

               Note: You can use ‘async with’ to close the connection
               automatically when the block is exited, but be careful
               about the async quirkness: see *note with async
               connections: 4b. for details.

      -- Method: cursor (*, binary: bool = False, row_factory:
               RowFactory | None = None) -> AsyncCursor

      -- Method: cursor (name: str, *, binary: bool = False,
               row_factory: RowFactory | None = None, scrollable: bool |
               None = None, withhold: bool = False) -> AsyncServerCursor

               Note: You can use:

                    async with conn.cursor() as cur:
                        ...

               to close the cursor automatically when the block is
               exited.

      -- Attribute: cursor_factory: type(1)[*note AsyncCursor:
               107.[Row]]

          Default is *note psycopg.AsyncCursor: 107.

      -- Attribute: server_cursor_factory: type(2)[*note
               AsyncServerCursor: 169.[Row]]

          Default is *note psycopg.AsyncServerCursor: 169.

      -- Attribute: row_factory: *note AsyncRowFactory: 1d6.[Row]

      -- Method: async execute (query: Query, params: Params | None =
               None, *, prepare: bool | None = None, binary: bool =
               False) -> AsyncCursor[Row]

          Execute a query and return a cursor to read its results.

      -- Method: pipeline () -> AsyncIterator[AsyncPipeline]

          Context manager to switch the connection into pipeline mode.

               Note: It must be called as:

                    async with conn.pipeline() as p:
                        ...

      -- Method: async commit () -> None

          Commit any pending transaction to the database.

      -- Method: async rollback () -> None

          Roll back to the start of any pending transaction.

      -- Method: transaction (savepoint_name: str | None = None,
               force_rollback: bool = False) ->
               AsyncIterator[AsyncTransaction]

          Start a context block with a new transaction or nested
          transaction.


          Parameters:

             * ‘savepoint_name’ – Name of the savepoint used to manage a
               nested transaction.  If ‘None’, one will be chosen
               automatically.

             * ‘force_rollback’ – Roll back the transaction at the end
               of the block even if there were no error (e.g.  to try a
               no-op process).


          Return type: *note AsyncTransaction: 1dc.

               Note: It must be called as:

                    async with conn.transaction() as tx:
                        ...

      -- Method: async cancel_safe (*, timeout: float = 30.0) -> None

          Cancel the current operation on the connection.


          Parameters: ‘timeout’ – raise a *note CancellationTimeout:
          1c5. if the cancellation request does not succeed within
          ‘timeout’ seconds.

          Note that a successful cancel attempt on the client is not a
          guarantee that the server will successfully manage to cancel
          the operation.

          This is a non-blocking version of *note cancel(): 10d. which
          leverages a more secure and improved cancellation feature of
          the libpq, which is only available from version 17.

          If the underlying libpq is older than version 17, the method
          will fall back to using the same implementation of ‘cancel()’.

          Added in version 3.2.

      -- Method: async notifies (*, timeout: float | None = None,
               stop_after: int | None = None) -> AsyncGenerator[Notify,
               None]

          Yield *note Notify: 118. objects as soon as they are received
          from the database.


          Parameters:

             * ‘timeout’ – maximum amount of time to wait for
               notifications.  ‘None’ means no timeout.

             * ‘stop_after’ – stop after receiving this number of
               notifications.  You might actually receive more than this
               number if more than one notifications arrives in the same
               packet.

          Changed in version 3.2: Added ‘timeout’ and ‘stop_after’
          parameters.

      -- Method: async set_autocommit (value: bool) -> None

          Method version of the *note autocommit: ab. setter.

      -- Method: async set_isolation_level (value: IsolationLevel |
               None) -> None

          Method version of the *note isolation_level: b4. setter.

      -- Method: async set_read_only (value: bool | None) -> None

          Method version of the *note read_only: b5. setter.

      -- Method: async set_deferrable (value: bool | None) -> None

          Method version of the *note deferrable: b6. setter.

      -- Method: async tpc_prepare () -> None

          Perform the first phase of a transaction started with
          ‘tpc_begin()’.

      -- Method: async tpc_commit (xid: Xid | str | None = None) -> None

          Commit a prepared two-phase transaction.

      -- Method: async tpc_rollback (xid: Xid | str | None = None) ->
               None

          Roll back a prepared two-phase transaction.

      -- Method: async tpc_recover () -> list[Xid]

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#type

   (2) https://docs.python.org/3/library/functions.html#type


File: psycopg.info,  Node: Cursor classes,  Next: COPY-related objects,  Prev: Connection classes,  Up: Psycopg 3 API

1.3.3 Cursor classes
--------------------

The *note Cursor: 36. and *note AsyncCursor: 107. classes are the main
objects to send commands to a PostgreSQL database session.  They are
normally created by the connection’s *note cursor(): 37. method.

Using the ‘name’ parameter on ‘cursor()’ will create a *note
ServerCursor: 15f. or *note AsyncServerCursor: 169, which can be used to
retrieve partial results from a database.

Other cursor classes can be created by directly instantiating them, or
can be set as *note Connection.cursor_factory: df. to require them on
‘cursor()’ call.

This page describe the details of the ‘Cursor’ class interface.  Please
refer to *note Cursor types: 15c. for general information about the
different types of cursors available in Psycopg.

* Menu:

* The Cursor class::
* The ClientCursor class::
* The ServerCursor class::
* The RawCursor and RawServerCursor class::
* Async cursor classes::


File: psycopg.info,  Node: The Cursor class,  Next: The ClientCursor class,  Up: Cursor classes

1.3.3.1 The ‘Cursor’ class
..........................

 -- Class: psycopg.Cursor (connection: Connection[Any], *, row_factory:
          RowFactory[Row] | None = None)

     This class implements a DBAPI-compliant interface(1).  It is what
     the classic *note Connection.cursor(): 37. method returns.  *note
     AsyncConnection.cursor(): 10a. will create instead *note
     AsyncCursor: 107. objects, which have the same set of method but
     expose an asyncio(2) interface and require ‘async’ and ‘await’
     keywords to operate.

     Cursors behave as context managers: on block exit they are closed
     and further operation will not be possible.  Closing a cursor will
     not terminate a transaction or a session though.

      -- Attribute: connection: *note Connection: 34.

          The connection this cursor is using.

      -- Method: close () -> None

          Close the current cursor and free associated resources.

               Note: You can use:

                    with conn.cursor() as cur:
                        ...

               to close the cursor automatically when the block is
               exited.  See *note Main objects in Psycopg 3: 1d.

      -- Attribute: closed

          True(3) if the cursor is closed.

     Methods to send commands
     ........................

      -- Method: execute (query: Query, params: Params | None = None, *,
               prepare: bool | None = None, binary: bool | None = None)
               -> Self

          Execute a query or command to the database.


          Parameters:

             * ‘query’ (‘str’, ‘bytes’, *note sql.SQL: 131, or *note
               sql.Composed: 1ba.) – The query to execute.

             * ‘params’ (‘Sequence’‘ or ’‘Mapping’) – The parameters to
               pass to the query, if any.

             * ‘prepare’ – Force (‘True’) or disallow (‘False’)
               preparation of the query.  By default (‘None’) prepare
               automatically.  See *note Prepared statements: 12.

             * ‘binary’ – Specify whether the server should return data
               in binary format (‘True’) or in text format (‘False’).
               By default (‘None’) return data as requested by the
               cursor’s *note format: 1eb.

          Return the cursor itself, so that it will be possible to chain
          a fetch operation after the call.

          See *note Passing parameters to SQL queries: 40. for all the
          details about executing queries.

          Changed in version 3.1: The ‘query’ argument must be a
          ‘StringLiteral’.  If you need to compose a query dynamically,
          please use *note sql.SQL: 131. and related objects.

          See PEP 675(4) for details.

      -- Method: executemany (query: Query, params_seq:
               Iterable[Params], *, returning: bool = False) -> None

          Execute the same command with a sequence of input data.


          Parameters:

             * ‘query’ (‘str’, ‘bytes’, *note sql.SQL: 131, or *note
               sql.Composed: 1ba.) – The query to execute

             * ‘params_seq’ (‘Sequence’‘ of ’‘Sequences’‘ or
               ’‘Mappings’) – The parameters to pass to the query

             * ‘returning’ (‘bool’) – If ‘True’, fetch the results of
               the queries executed

          This is more efficient than performing separate queries, but
          in case of several ‘INSERT’ (and with some SQL creativity for
          massive ‘UPDATE’ too) you may consider using *note copy(): c8.

          If the queries return data you want to read (e.g.  when
          executing an ‘INSERT ... RETURNING’ or a ‘SELECT’ with a
          side-effect), you can specify ‘returning=True’.  This is
          equivalent of calling *note execute(): 3a. as many times as
          the number of items in ‘params_seq’, and to store all the
          results in the cursor’s state.

               Note: Using the usual *note fetchone(): 3c, *note
               fetchall(): 3e, you will be able to read the records
               returned 'by the first query executed only'.  In order to
               read the results of the following queries you can call
               *note nextset(): e7. to move to the following result set.

               A typical use case for ‘executemany(returning=True)’
               might be to insert a bunch of records and to retrieve the
               primary keys inserted, taken from a PostgreSQL sequence.
               In order to do so, you may execute a query such as
               ‘INSERT INTO table VALUES (...) RETURNING id’.  Because
               every ‘INSERT’ is guaranteed to insert exactly a single
               record, you can obtain the list of the new ids using a
               pattern such as:

                    cur.executemany(query, records)
                    ids = []
                    while True:
                        ids.append(cur.fetchone()[0])
                        if not cur.nextset():
                            break

               Warning: More explicitly, ‘fetchall()’ alone will not
               return all the values returned!  You must iterate on the
               results using ‘nextset()’.

          If ‘returning=False’, the value of *note rowcount: 1ec. is set
          to the cumulated number of rows affected by queries.  If
          ‘returning=True’, ‘rowcount’ is set to the number of rows in
          the current result set (i.e.  the first one, until *note
          nextset(): e7. gets called).

          See *note Passing parameters to SQL queries: 40. for all the
          details about executing queries.

          Changed in version 3.1:

             - Added ‘returning’ parameter to receive query results.

             - Performance optimised by making use of the pipeline mode,
               when using libpq 14 or newer.

      -- Method: copy (statement: Query, params: Params | None = None,
               *, writer: Writer | None = None) -> Iterator[Copy]

          Initiate a ‘COPY’ operation and return an object to manage it.


          Parameters:

             * ‘statement’ (‘str’, ‘bytes’, *note sql.SQL: 131, or *note
               sql.Composed: 1ba.) – The copy operation to execute

             * ‘params’ (‘Sequence’‘ or ’‘Mapping’) – The parameters to
               pass to the statement, if any.

               Note: The method must be called with:

                    with cursor.copy() as copy:
                        ...

          See *note Using COPY TO and COPY FROM: e. for information
          about ‘COPY’.

          Changed in version 3.1: Added parameters support.

      -- Method: stream (query: Query, params: Params | None = None, *,
               binary: bool | None = None, size: int = 1) ->
               Iterator[Row]

          Iterate row-by-row on a result from the database.


          Parameters: ‘size’ – if greater than 1, results will be
          retrieved by chunks of this size from the server (but still
          yielded row-by-row); this is only available from version 17 of
          the libpq.

          This command is similar to execute + iter; however it supports
          endless data streams.  The feature is not available in
          PostgreSQL, but some implementations exist: Materialize
          SUBSCRIBE(5) and CockroachDB CHANGEFEED(6) for instance.

          The feature, and the API supporting it, are still
          experimental.  Beware… 👀

          The parameters are the same of *note execute(): 3a, except for
          ‘size’ which can be used to set results retrieval by chunks
          instead of row-by-row.

               Note: This ‘size’ parameter is only available from libpq
               17, you can use the *note has_stream_chunked: 1ed.
               capability to check if this is supported.

               Warning: Failing to consume the iterator entirely will
               result in a connection left in *note transaction_status:
               1cc. *note ACTIVE: 1ee. state: this connection will
               refuse to receive further commands (with a message such
               as 'another command is already in progress').

               If there is a chance that the generator is not consumed
               entirely, in order to restore the connection to a working
               state you can call close(7) on the generator object
               returned by ‘stream()’.  The contextlib.closing(8)
               function might be particularly useful to make sure that
               ‘close()’ is called:

                    with closing(cur.stream("select generate_series(1, 10000)")) as gen:
                        for rec in gen:
                            something(rec)  # might fail

               Without calling ‘close()’, in case of error, the
               connection will be ‘ACTIVE’ and unusable.  If ‘close()’
               is called, the connection might be ‘INTRANS’ or
               ‘INERROR’, depending on whether the server managed to
               send the entire resultset to the client.  An autocommit
               connection will be ‘IDLE’ instead.

      -- Attribute: format

          The format of the data returned by the queries.  It can be
          selected initially e.g.  specifying *note Connection.cursor:
          37.‘(binary=True)’ and changed during the cursor’s lifetime.
          It is also possible to override the value for single queries,
          e.g.  specifying *note execute: 3a.‘(binary=True)’.


          Type: *note pq.Format: 18a.


          Default: *note TEXT: 5a.

          See also
          ........

          *note Binary parameters and results: 14.

     Methods to retrieve results
     ...........................

     Fetch methods are only available if the last operation produced
     results, e.g.  a ‘SELECT’ or a command with ‘RETURNING’.  They will
     raise an exception if used with operations that don’t return
     result, such as an ‘INSERT’ with no ‘RETURNING’ or an ‘ALTER
     TABLE’.

          Note: Cursors are iterable objects, so just using the:

               for record in cursor:
                   ...

          syntax will iterate on the records in the current recordset.

      -- Attribute: row_factory

          Writable attribute to control how result rows are formed.

          The property affects the objects returned by the *note
          fetchone(): 3c, *note fetchmany(): 3d, *note fetchall(): 3e.
          methods.  The default (*note tuple_row: 1b4.) returns a tuple
          for each record fetched.

          See *note Row factories: 4d. for details.

      -- Method: fetchone () -> Row | None

          Return the next record from the current recordset.

          Return ‘None’ the recordset is finished.


          Return type: Row | None, with Row defined by *note
          row_factory: 136.

      -- Method: fetchmany (size: int = 0) -> list[Row]

          Return the next ‘size’ records from the current recordset.

          ‘size’ default to ‘self.arraysize’ if not specified.


          Return type: Sequence[Row], with Row defined by *note
          row_factory: 136.

      -- Method: fetchall () -> list[Row]

          Return all the remaining records from the current recordset.


          Return type: Sequence[Row], with Row defined by *note
          row_factory: 136.

      -- Method: nextset () -> bool | None

          Move to the result set of the next query executed through
          *note executemany(): 3b. or to the next result set if *note
          execute(): 3a. returned more than one.

          Return ‘True’ if a new result is available, which will be the
          one methods ‘fetch*()’ will operate on.

      -- Method: scroll (value: int, mode: str = 'relative') -> None

          Move the cursor in the result set to a new position according
          to mode.

          If ‘mode’ is ‘'relative'’ (default), ‘value’ is taken as
          offset to the current position in the result set; if set to
          ‘'absolute'’, ‘value’ states an absolute target position.

          Raise ‘IndexError’ in case a scroll operation would leave the
          result set.  In this case the position will not change.

      -- Attribute: pgresult: *note psycopg.pq.PGresult: 189. | None(9)

          The result returned by the last query and currently exposed by
          the cursor, if available, else ‘None’.

          It can be used to obtain low level info about the last query
          result and to access to features not currently wrapped by
          Psycopg.

     Information about the data
     ..........................

      -- Attribute: description

          A list of *note Column: 1ef. objects describing the current
          resultset.

          ‘None’ if the current resultset didn’t return tuples.

      -- Attribute: statusmessage

          The command status tag from the last SQL command executed.

          ‘None’ if the cursor doesn’t have a result available.

          This is the status tag you typically see in ‘psql’ after a
          successful command, such as ‘CREATE TABLE’ or ‘UPDATE 42’.

      -- Attribute: rowcount

          Number of records affected by the precedent operation.

          From *note executemany(): 3b, unless called with
          ‘returning=True’, this is the cumulated number of rows
          affected by executed commands.

      -- Attribute: rownumber

          Index of the next row to fetch in the current result.

          ‘None’ if there is no result to fetch.

      -- Attribute: _query

          An helper object used to convert queries and parameters before
          sending them to PostgreSQL.

               Note: This attribute is exposed because it might be
               helpful to debug problems when the communication between
               Python and PostgreSQL doesn’t work as expected.  For this
               reason, the attribute is available when a query fails
               too.

                    Warning: You shouldn’t consider it part of the
                    public interface of the object: it might change
                    without warnings.

                    Except this warning, I guess.

               If you would like to build reliable features using this
               object, please get in touch so we can try and design an
               useful interface for it.

          Among the properties currently exposed by this object:

             - ‘query’ (‘bytes’): the query effectively sent to
               PostgreSQL. It will have Python placeholders (‘%s’-style)
               replaced with PostgreSQL ones (‘$1’, ‘$2’-style).

             - ‘params’ (sequence of ‘bytes’): the parameters passed to
               PostgreSQL, adapted to the database format.

             - ‘types’ (sequence of ‘int’): the OID of the parameters
               passed to PostgreSQL.

             - ‘formats’ (sequence of *note pq.Format: 18a.): whether
               the parameter format is text or binary.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0249/#cursor-objects

   (2) https://docs.python.org/3/library/asyncio.html#module-asyncio

   (3) https://docs.python.org/3/library/constants.html#True

   (4) https://peps.python.org/pep-0675/

   (5) https://materialize.com/docs/sql/subscribe/

   (6) https://www.cockroachlabs.com/docs/stable/changefeed-for.html

   (7) 
https://docs.python.org/3/reference/expressions.html#generator.close

   (8) 
https://docs.python.org/3/library/contextlib.html#contextlib.closing

   (9) https://docs.python.org/3/library/constants.html#None


File: psycopg.info,  Node: The ClientCursor class,  Next: The ServerCursor class,  Prev: The Cursor class,  Up: Cursor classes

1.3.3.2 The ‘ClientCursor’ class
................................

See also
........

See *note Client-side-binding cursors: dd. for details.

 -- Class: psycopg.ClientCursor (connection: Connection[Any], *,
          row_factory: RowFactory[Row] | None = None)

     This *note Cursor: 36. subclass has exactly the same interface of
     its parent class, but, instead of sending query and parameters
     separately to the server, it merges them on the client and sends
     them as a non-parametric query on the server.  This allows, for
     instance, to execute parametrized data definition statements and
     other *note problematic queries: 11.

     Added in version 3.1.

      -- Method: mogrify (query: Query, params: Params | None = None) ->
               str

          Return the query and parameters merged.

          Parameters are adapted and merged to the query the same way
          that ‘execute()’ would do.


          Parameters:

             * ‘query’ (‘str’, ‘bytes’, *note sql.SQL: 131, or *note
               sql.Composed: 1ba.) – The query to execute.

             * ‘params’ (‘Sequence’‘ or ’‘Mapping’) – The parameters to
               pass to the query, if any.


File: psycopg.info,  Node: The ServerCursor class,  Next: The RawCursor and RawServerCursor class,  Prev: The ClientCursor class,  Up: Cursor classes

1.3.3.3 The ‘ServerCursor’ class
................................

See also
........

See *note Server-side cursors: 160. for details.

 -- Class: psycopg.ServerCursor (connection: Connection[Any], name: str,
          *, row_factory: RowFactory[Row] | None = None, scrollable:
          bool | None = None, withhold: bool = False)

     This class also implements a DBAPI-compliant interface(1).  It is
     created by *note Connection.cursor(): 37. specifying the ‘name’
     parameter.  Using this object results in the creation of an
     equivalent PostgreSQL cursor in the server.  DBAPI-extension
     methods (such as *note copy(): c8. or *note stream(): 19b.) are not
     implemented on this object: use a normal *note Cursor: 36. instead.

     Most attribute and methods behave exactly like in *note Cursor: 36,
     here are documented the differences:

      -- Attribute: name

          The name of the cursor.

      -- Attribute: scrollable

          Whether the cursor is scrollable or not.

          If ‘None’ leave the choice to the server.  Use ‘True’ if you
          want to use *note scroll(): 1f7. on the cursor.

          See also
          ........

          The PostgreSQL DECLARE(2) statement documentation for the
          description of ‘[NO] SCROLL’.

      -- Attribute: withhold

          If the cursor can be used after the creating transaction has
          committed.

          See also
          ........

          The PostgreSQL DECLARE(3) statement documentation for the
          description of ‘{WITH|WITHOUT} HOLD’.

      -- Method: close () -> None

          Close the current cursor and free associated resources.

               Warning: Closing a server-side cursor is more important
               than closing a client-side one because it also releases
               the resources on the server, which otherwise might remain
               allocated until the end of the session (memory, locks).
               Using the pattern:

                    with conn.cursor():
                        ...

               is especially useful so that the cursor is closed at the
               end of the block.

      -- Method: execute (query: Query, params: Params | None = None, *,
               binary: bool | None = None, **kwargs: Any) -> Self

          Open a cursor to execute a query to the database.


          Parameters:

             * ‘query’ (‘str’, ‘bytes’, *note sql.SQL: 131, or *note
               sql.Composed: 1ba.) – The query to execute.

             * ‘params’ (‘Sequence’‘ or ’‘Mapping’) – The parameters to
               pass to the query, if any.

             * ‘binary’ – Specify whether the server should return data
               in binary format (‘True’) or in text format (‘False’).
               By default (‘None’) return data as requested by the
               cursor’s *note format: 1eb.

          Create a server cursor with given ‘name’ and the ‘query’ in
          argument.

          If using ‘DECLARE’ is not appropriate (for instance because
          the cursor is returned by calling a stored procedure) you can
          avoid to use ‘execute()’, crete the cursor in other ways, and
          use directly the ‘fetch*()’ methods instead.  See *note
          “Stealing” an existing cursor: 16b. for an example.

          Using ‘execute()’ more than once will close the previous
          cursor and open a new one with the same name.

      -- Method: executemany (query: Query, params_seq:
               Iterable[Params], *, returning: bool = True) -> None

          Method not implemented for server-side cursors.

      -- Method: fetchone () -> Row | None

          Return the next record from the current recordset.

          Return ‘None’ the recordset is finished.


          Return type: Row | None, with Row defined by ‘row_factory’

      -- Method: fetchmany (size: int = 0) -> list[Row]

          Return the next ‘size’ records from the current recordset.

          ‘size’ default to ‘self.arraysize’ if not specified.


          Return type: Sequence[Row], with Row defined by ‘row_factory’

      -- Method: fetchall () -> list[Row]

          Return all the remaining records from the current recordset.


          Return type: Sequence[Row], with Row defined by ‘row_factory’

          These methods use the FETCH(4) SQL statement to retrieve some
          of the records from the cursor’s current position.

               Note: You can also iterate on the cursor to read its
               result one at time with:

                    for record in cur:
                        ...

               In this case, the records are not fetched one at time
               from the server but they are retrieved in batches of
               *note itersize: 1fd. to reduce the number of server
               roundtrips.

      -- Attribute: itersize: int(5)

          Number of records to fetch at time when iterating on the
          cursor.  The default is 100.

      -- Method: scroll (value: int, mode: str = 'relative') -> None

          Move the cursor in the result set to a new position according
          to mode.

          If ‘mode’ is ‘'relative'’ (default), ‘value’ is taken as
          offset to the current position in the result set; if set to
          ‘'absolute'’, ‘value’ states an absolute target position.

          Raise ‘IndexError’ in case a scroll operation would leave the
          result set.  In this case the position will not change.

          This method uses the MOVE(6) SQL statement to move the current
          position in the server-side cursor, which will affect
          following ‘fetch*()’ operations.  If you need to scroll
          backwards you should probably call *note cursor(): 37. using
          ‘scrollable=True’.

          Note that PostgreSQL doesn’t provide a reliable way to report
          when a cursor moves out of bound, so the method might not
          raise ‘IndexError’ when it happens, but it might rather stop
          at the cursor boundary.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0249/#cursor-objects

   (2) https://www.postgresql.org/docs/current/sql-declare.html

   (3) https://www.postgresql.org/docs/current/sql-declare.html

   (4) https://www.postgresql.org/docs/current/sql-fetch.html

   (5) https://docs.python.org/3/library/functions.html#int

   (6) https://www.postgresql.org/docs/current/sql-fetch.html


File: psycopg.info,  Node: The RawCursor and RawServerCursor class,  Next: Async cursor classes,  Prev: The ServerCursor class,  Up: Cursor classes

1.3.3.4 The ‘RawCursor’ and ‘RawServerCursor’ class
...................................................

See also
........

See *note Raw query cursors: 162. for details.

 -- Class: psycopg.RawCursor (connection: Connection[Any], *,
          row_factory: RowFactory[Row] | None = None)

     This *note Cursor: 36. subclass has the same interface of the
     parent class but supports placeholders in PostgreSQL format (‘$1’,
     ‘$2’…) rather than in Python format (‘%s’).  Only positional
     parameters are supported.

     Added in version 3.2.

 -- Class: psycopg.RawServerCursor (connection: Connection[Any], name:
          str, *, row_factory: RowFactory[Row] | None = None,
          scrollable: bool | None = None, withhold: bool = False)

     This *note ServerCursor: 15f. subclass has the same interface of
     the parent class but supports placeholders in PostgreSQL format
     (‘$1’, ‘$2’…) rather than in Python format (‘%s’).  Only positional
     parameters are supported.

     Added in version 3.2.


File: psycopg.info,  Node: Async cursor classes,  Prev: The RawCursor and RawServerCursor class,  Up: Cursor classes

1.3.3.5 Async cursor classes
............................

Every *note Cursor: 36. class has an equivalent ‘Async’ version exposing
the same semantic with an ‘async’ interface.  The main interface is
described in *note AsyncCursor: 107.

 -- Class: psycopg.AsyncCursor (connection: AsyncConnection[Any], *,
          row_factory: AsyncRowFactory[Row] | None = None)

     This class implements a DBAPI-inspired interface, with all the
     blocking methods implemented as coroutines.  Unless specified
     otherwise, non-blocking methods are shared with the *note Cursor:
     36. class.

     The following methods have the same behaviour of the matching
     ‘Cursor’ methods, but should be called using the ‘await’ keyword.

      -- Attribute: connection: *note AsyncConnection: 4a.

      -- Method: async close () -> None

          Close the current cursor and free associated resources.

               Note: You can use:

                    async with conn.cursor():
                        ...

               to close the cursor automatically when the block is
               exited.

      -- Method: async execute (query: Query, params: Params | None =
               None, *, prepare: bool | None = None, binary: bool | None
               = None) -> Self

          Execute a query or command to the database.

      -- Method: async executemany (query: Query, params_seq:
               Iterable[Params], *, returning: bool = False) -> None

          Execute the same command with a sequence of input data.

      -- Method: copy (statement: Query, params: Params | None = None,
               *, writer: AsyncWriter | None = None) ->
               AsyncIterator[AsyncCopy]

          Initiate a ‘COPY’ operation and return an object to manage it.

               Note: The method must be called with:

                    async with cursor.copy() as copy:
                        ...

      -- Method: async stream (query: Query, params: Params | None =
               None, *, binary: bool | None = None, size: int = 1) ->
               AsyncIterator[Row]

          Iterate row-by-row on a result from the database.


          Parameters: ‘size’ – if greater than 1, results will be
          retrieved by chunks of this size from the server (but still
          yielded row-by-row); this is only available from version 17 of
          the libpq.

               Note: The method must be called with:

                    async for record in cursor.stream(query):
                        ...

      -- Method: async fetchone () -> Row | None

          Return the next record from the current recordset.

          Return ‘None’ the recordset is finished.


          Return type: Row | None, with Row defined by ‘row_factory’

      -- Method: async fetchmany (size: int = 0) -> list[Row]

          Return the next ‘size’ records from the current recordset.

          ‘size’ default to ‘self.arraysize’ if not specified.


          Return type: Sequence[Row], with Row defined by ‘row_factory’

      -- Method: async fetchall () -> list[Row]

          Return all the remaining records from the current recordset.


          Return type: Sequence[Row], with Row defined by ‘row_factory’

      -- Method: async scroll (value: int, mode: str = 'relative') ->
               None

          Move the cursor in the result set to a new position according
          to mode.

          If ‘mode’ is ‘'relative'’ (default), ‘value’ is taken as
          offset to the current position in the result set; if set to
          ‘'absolute'’, ‘value’ states an absolute target position.

          Raise ‘IndexError’ in case a scroll operation would leave the
          result set.  In this case the position will not change.

          Note: You can also use:

               async for record in cursor:
                   ...

          to iterate on the async cursor results.

 -- Class: psycopg.AsyncClientCursor (connection: AsyncConnection[Any],
          *, row_factory: AsyncRowFactory[Row] | None = None)

     This class is the ‘async’ equivalent of *note ClientCursor: de.
     The differences w.r.t.  the sync counterpart are the same described
     in *note AsyncCursor: 107.

     Added in version 3.1.

 -- Class: psycopg.AsyncServerCursor (connection: AsyncConnection[Any],
          name: str, *, row_factory: AsyncRowFactory[Row] | None = None,
          scrollable: bool | None = None, withhold: bool = False)

     This class implements a DBAPI-inspired interface as the *note
     AsyncCursor: 107. does, but wraps a server-side cursor like the
     *note ServerCursor: 15f. class.  It is created by *note
     AsyncConnection.cursor(): 10a. specifying the ‘name’ parameter.

     The following are the methods exposing a different (async)
     interface from the *note ServerCursor: 15f. counterpart, but
     sharing the same semantics.

      -- Method: async close () -> None

          Close the current cursor and free associated resources.

               Note: You can close the cursor automatically using:

                    async with conn.cursor("name") as cursor:
                        ...

      -- Method: async execute (query: Query, params: Params | None =
               None, *, binary: bool | None = None, **kwargs: Any) ->
               Self

          Open a cursor to execute a query to the database.

      -- Method: async executemany (query: Query, params_seq:
               Iterable[Params], *, returning: bool = True) -> None

          Method not implemented for server-side cursors.

      -- Method: async fetchone () -> Row | None

          Return the next record from the current recordset.

          Return ‘None’ the recordset is finished.


          Return type: Row | None, with Row defined by ‘row_factory’

      -- Method: async fetchmany (size: int = 0) -> list[Row]

          Return the next ‘size’ records from the current recordset.

          ‘size’ default to ‘self.arraysize’ if not specified.


          Return type: Sequence[Row], with Row defined by ‘row_factory’

      -- Method: async fetchall () -> list[Row]

          Return all the remaining records from the current recordset.


          Return type: Sequence[Row], with Row defined by ‘row_factory’

               Note: You can also iterate on the cursor using:

                    async for record in cur:
                        ...

      -- Method: async scroll (value: int, mode: str = 'relative') ->
               None

          Move the cursor in the result set to a new position according
          to mode.

          If ‘mode’ is ‘'relative'’ (default), ‘value’ is taken as
          offset to the current position in the result set; if set to
          ‘'absolute'’, ‘value’ states an absolute target position.

          Raise ‘IndexError’ in case a scroll operation would leave the
          result set.  In this case the position will not change.

 -- Class: psycopg.AsyncRawCursor (connection: AsyncConnection[Any], *,
          row_factory: AsyncRowFactory[Row] | None = None)

     This class is the ‘async’ equivalent of *note RawCursor: 161.  The
     differences w.r.t.  the sync counterpart are the same described in
     *note AsyncCursor: 107.

     Added in version 3.2.

 -- Class: psycopg.AsyncRawServerCursor (connection:
          AsyncConnection[Any], name: str, *, row_factory:
          AsyncRowFactory[Row] | None = None, scrollable: bool | None =
          None, withhold: bool = False)

     This class is the ‘async’ equivalent of *note RawServerCursor: 163.
     The differences w.r.t.  the sync counterpart are the same described
     in *note AsyncServerCursor: 169.

     Added in version 3.2.


File: psycopg.info,  Node: COPY-related objects,  Next: Other top-level objects,  Prev: Cursor classes,  Up: Psycopg 3 API

1.3.4 COPY-related objects
--------------------------

The main objects (*note Copy: c9, *note AsyncCopy: d8.) present the main
interface to exchange data during a COPY operations.  These objects are
normally obtained by the methods *note Cursor.copy(): c8. and *note
AsyncCursor.copy(): 204.; however, they can be also created directly,
for instance to write to a destination which is not a database (e.g.
using a *note FileWriter: 213.).

See *note Using COPY TO and COPY FROM: e. for details.

* Menu:

* Main Copy objects::
* Writer objects::


File: psycopg.info,  Node: Main Copy objects,  Next: Writer objects,  Up: COPY-related objects

1.3.4.1 Main Copy objects
.........................

 -- Class: psycopg.Copy

     Manage an asynchronous ‘COPY’ operation.


     Parameters:

        * ‘cursor’ – the cursor where the operation is performed.

        * ‘binary’ – if ‘True’, write binary format.

        * ‘writer’ – the object to write to destination.  If not
          specified, write to the ‘cursor’ connection.

     Choosing ‘binary’ is not necessary if the cursor has executed a
     ‘COPY’ operation, because the operation result describes the format
     too.  The parameter is useful when a ‘Copy’ object is created
     manually and no operation is performed on the cursor, such as when
     using ‘writer=’*note FileWriter: 213.

     The object is normally returned by ‘with’ *note Cursor.copy(): c8.

      -- Method: write_row (row: Sequence[Any]) -> None

          Write a record to a table after a ‘COPY FROM’ operation.

          The data in the tuple will be converted as configured on the
          cursor; see *note Data adaptation configuration: 4e. for
          details.

      -- Method: write (buffer: Buffer | str) -> None

          Write a block of data to a table after a ‘COPY FROM’
          operation.

          If the ‘COPY’ is in binary format ‘buffer’ must be ‘bytes’.
          In text mode it can be either ‘bytes’ or ‘str’.

      -- Method: read () -> Buffer

          Read an unparsed row after a ‘COPY TO’ operation.

          Return an empty string when the data is finished.

          Instead of using ‘read()’ you can iterate on the ‘Copy’ object
          to read its data row by row, using ‘for row in copy: ...’.

      -- Method: rows () -> Iterator[tuple[Any, ...]]

          Iterate on the result of a ‘COPY TO’ operation record by
          record.

          Note that the records returned will be tuples of unparsed
          strings or bytes, unless data types are specified using *note
          set_types(): d0.

          Equivalent of iterating on *note read_row(): 216. until it
          returns ‘None’

      -- Method: read_row () -> tuple[Any, ...] | None

          Read a parsed row of data from a table after a ‘COPY TO’
          operation.

          Return ‘None’ when the data is finished.

          Note that the records returned will be tuples of unparsed
          strings or bytes, unless data types are specified using *note
          set_types(): d0.

      -- Method: set_types (types: Sequence[int | str]) -> None

          Set the types expected in a COPY operation.

          The types must be specified as a sequence of oid or PostgreSQL
          type names (e.g.  ‘int4’, ‘timestamptz[]’).

          This operation overcomes the lack of metadata returned by
          PostgreSQL when a COPY operation begins:

             - On ‘COPY TO’, ‘set_types()’ allows to specify what types
               the operation returns.  If ‘set_types()’ is not used, the
               data will be returned as unparsed strings or bytes
               instead of Python objects.

             - On ‘COPY FROM’, ‘set_types()’ allows to choose what type
               the database expects.  This is especially useful in
               binary copy, because PostgreSQL will apply no cast rule.

 -- Class: psycopg.AsyncCopy

     Manage an asynchronous ‘COPY’ operation.


     Parameters:

        * ‘cursor’ – the cursor where the operation is performed.

        * ‘binary’ – if ‘True’, write binary format.

        * ‘writer’ – the object to write to destination.  If not
          specified, write to the ‘cursor’ connection.

     Choosing ‘binary’ is not necessary if the cursor has executed a
     ‘COPY’ operation, because the operation result describes the format
     too.  The parameter is useful when a ‘Copy’ object is created
     manually and no operation is performed on the cursor, such as when
     using ‘writer=’*note FileWriter: 213.

     The object is normally returned by ‘async with’ *note
     AsyncCursor.copy(): 204.  Its methods are similar to the ones of
     the *note Copy: c9. object but offering an asyncio(1) interface
     (‘await’, ‘async for’, ‘async with’).

      -- Method: async write_row (row: Sequence[Any]) -> None

          Write a record to a table after a ‘COPY FROM’ operation.

      -- Method: async write (buffer: Buffer | str) -> None

          Write a block of data to a table after a ‘COPY FROM’
          operation.

          If the ‘COPY’ is in binary format ‘buffer’ must be ‘bytes’.
          In text mode it can be either ‘bytes’ or ‘str’.

      -- Method: async read () -> Buffer

          Read an unparsed row after a ‘COPY TO’ operation.

          Return an empty string when the data is finished.

          Instead of using ‘read()’ you can iterate on the ‘AsyncCopy’
          object to read its data row by row, using ‘async for row in
          copy: ...’.

      -- Method: async rows () -> AsyncIterator[tuple[Any, ...]]

          Iterate on the result of a ‘COPY TO’ operation record by
          record.

          Note that the records returned will be tuples of unparsed
          strings or bytes, unless data types are specified using
          ‘set_types()’.

          Use it as ‘async for record in copy.rows():’ …

      -- Method: async read_row () -> tuple[Any, ...] | None

          Read a parsed row of data from a table after a ‘COPY TO’
          operation.

          Return ‘None’ when the data is finished.

          Note that the records returned will be tuples of unparsed
          strings or bytes, unless data types are specified using
          ‘set_types()’.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/asyncio.html#module-asyncio


File: psycopg.info,  Node: Writer objects,  Prev: Main Copy objects,  Up: COPY-related objects

1.3.4.2 Writer objects
......................

Added in version 3.1.

Copy writers are helper objects to specify where to write COPY-formatted
data.  By default, data is written to the database (using the *note
LibpqWriter: 21e.).  It is possible to write copy-data for offline use
by using a *note FileWriter: 213, or to customize further writing by
implementing your own *note Writer: 21f. or *note AsyncWriter: 220.
subclass.

Writers instances can be used passing them to the cursor *note copy():
c8. method or to the *note Copy: c9. constructor, as the ‘writer’
argument.

 -- Class: psycopg.copy.Writer

     A class to write copy data somewhere (for async connections).

     This is an abstract base class: subclasses are required to
     implement their *note write(): 221. method.

      -- Method: abstract write (data: Buffer) -> None

          Write some data to destination.

      -- Method: finish (exc: BaseException | None = None) -> None

          Called when write operations are finished.

          If operations finished with an error, it will be passed to
          ‘exc’.

 -- Class: psycopg.copy.LibpqWriter (cursor: Cursor[Any])

     An *note Writer: 21f. to write copy data to a Postgres database.

     This is the writer used by default if none is specified.

 -- Class: psycopg.copy.FileWriter (file: IO[bytes])

     A *note Writer: 21f. to write copy data to a file-like object.


     Parameters: ‘file’ – the file where to write copy data.  It must be
     open for writing in binary mode.

     This writer should be used without executing a ‘COPY’ operation on
     the database.  For example, if ‘records’ is a list of tuples
     containing data to save in COPY format to a file (e.g.  for later
     import), it can be used as:

          with open("target-file.pgcopy", "wb") as f:
              with Copy(cur, writer=FileWriter(f)) as copy:
                  for record in records
                      copy.write_row(record)

 -- Class: psycopg.copy.AsyncWriter

     A class to write copy data somewhere (for async connections).

     This class methods have the same semantics of the ones of *note
     Writer: 21f, but offer an async interface.

      -- Method: abstract async write (data: Buffer) -> None

          Write some data to destination.

      -- Method: async finish (exc: BaseException | None = None) -> None

          Called when write operations are finished.

          If operations finished with an error, it will be passed to
          ‘exc’.

 -- Class: psycopg.copy.AsyncLibpqWriter (cursor: AsyncCursor[Any])

     An *note AsyncWriter: 220. to write copy data to a Postgres
     database.


File: psycopg.info,  Node: Other top-level objects,  Next: sql – SQL string composition,  Prev: COPY-related objects,  Up: Psycopg 3 API

1.3.5 Other top-level objects
-----------------------------

* Menu:

* Connection information::
* Libpq capabilities information::
* The description Column object::
* Notifications::
* Pipeline-related objects::
* Transaction-related objects::
* Two-Phase Commit related objects::


File: psycopg.info,  Node: Connection information,  Next: Libpq capabilities information,  Up: Other top-level objects

1.3.5.1 Connection information
..............................

 -- Class: psycopg.ConnectionInfo

     Allow access to information about the connection.

     The object is usually returned by *note Connection.info: 1c2.

      -- Attribute: dsn

          Return the connection string to connect to the database.

          The string contains all the parameters set to a non-default
          value, which might come either from the connection string and
          parameters passed to *note connect(): 33. or from environment
          variables.  The password is never returned (you can read it
          using the *note password: 22a. attribute).

               Note: The *note get_parameters(): 22b. method returns the
               same information as a dict.

      -- Attribute: status

          The status of the connection.  See ‘PQstatus()(1)’.

          The status can be one of a number of values.  However, only
          two of these are seen outside of an asynchronous connection
          procedure: *note OK: 22d. and *note BAD: 22e.  A good
          connection to the database has the status ‘OK’.  Ordinarily,
          an ‘OK’ status will remain so until *note Connection.close():
          49, but a communications failure might result in the status
          changing to ‘BAD’ prematurely.

      -- Attribute: transaction_status

          The current in-transaction status of the session.  See
          ‘PQtransactionStatus()(2)’.

          The status can be *note IDLE: 1cd. (currently idle), *note
          ACTIVE: 1ee. (a command is in progress), *note INTRANS: 22f.
          (idle, in a valid transaction block), or *note INERROR: 230.
          (idle, in a failed transaction block).  *note UNKNOWN: 231. is
          reported if the connection is bad.  ‘ACTIVE’ is reported only
          when a query has been sent to the server and not yet
          completed.

      -- Attribute: pipeline_status

          The current pipeline status of the client.  See
          ‘PQpipelineStatus()(3)’.

      -- Attribute: backend_pid

          The process ID (PID) of the backend process handling this
          connection.  See ‘PQbackendPID()(4)’.

      -- Attribute: vendor

          A string representing the database vendor connected to.

          Normally it is ‘PostgreSQL’; it may be different if connected
          to a different database.

          Added in version 3.1.

      -- Attribute: server_version

          An integer representing the server version.  See
          ‘PQserverVersion()(5)’.

          The number is formed by converting the major, minor, and
          revision numbers into two-decimal-digit numbers and appending
          them together.  Starting from PostgreSQL 10 the minor version
          was dropped, so the second group of digits is always 00.  For
          example, version 9.3.5 is returned as 90305, version 10.2 as
          100002.

      -- Attribute: error_message

          The error message most recently generated by an operation on
          the connection.  See ‘PQerrorMessage()(6)’.

      -- Method: get_parameters () -> dict[str, str]

          Return the connection parameters values.

          Return all the parameters set to a non-default value, which
          might come either from the connection string and parameters
          passed to *note connect(): 33. or from environment variables.
          The password is never returned (you can read it using the
          *note password: 22a. attribute).

               Note: The *note dsn: 229. attribute returns the same
               information in the form as a string.

      -- Attribute: timezone

          The Python timezone info of the connection’s timezone.

               >>> conn.info.timezone
               zoneinfo.ZoneInfo(key='Europe/Rome')

      -- Attribute: host

          The server host name of the active connection.  See
          ‘PQhost()(7)’.

          This can be a host name, an IP address, or a directory path if
          the connection is via Unix socket.  (The path case can be
          distinguished because it will always be an absolute path,
          beginning with ‘/’.)

      -- Attribute: hostaddr

          The server IP address of the connection.  See
          ‘PQhostaddr()(8)’.

          Only available if the libpq used is from PostgreSQL 12 or
          newer.  Raise *note NotSupportedError: 1af. otherwise.  You
          can use the *note has_hostaddr: 239. capability to check for
          support.

      -- Attribute: port

          The port of the active connection.  See ‘PQport()(9)’.

      -- Attribute: dbname

          The database name of the connection.  See ‘PQdb()(10)’.

      -- Attribute: user

          The user name of the connection.  See ‘PQuser()(11)’.

      -- Attribute: password

          The password of the connection.  See ‘PQpass()(12)’.

      -- Attribute: options

          The command-line options passed in the connection request.
          See ‘PQoptions(13)’.

      -- Method: parameter_status (param_name: str) -> str | None

          Return a parameter setting of the connection.

          Return None(14) is the parameter is unknown.

          Example of parameters are ‘server_version’,
          ‘standard_conforming_strings’… See ‘PQparameterStatus()(15)’
          for all the available parameters.

      -- Attribute: encoding

          The Python codec name of the connection’s client encoding.

          The value returned is always normalized to the Python codec
          name(16):

               conn.execute("SET client_encoding TO LATIN9")
               conn.info.encoding
               'iso8859-15'

          A few PostgreSQL encodings are not available in Python and
          cannot be selected (currently ‘EUC_TW’, ‘MULE_INTERNAL’).  The
          PostgreSQL ‘SQL_ASCII’ encoding has the special meaning of “no
          encoding”: see *note Strings adaptation: 65. for details.

          See also
          ........

          The PostgreSQL supported encodings(17).

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQSTATUS

   (2) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQTRANSACTIONSTATUS

   (3) 
https://www.postgresql.org/docs/17/libpq-pipeline-mode.html#LIBPQ-PQPIPELINESTATUS

   (4) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQBACKENDPID

   (5) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQSERVERVERSION

   (6) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQERRORMESSAGE

   (7) https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQHOST

   (8) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQHOSTADDR

   (9) https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQPORT

   (10) https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQDB

   (11) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQUSER

   (12) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQPASS

   (13) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQOPTIONS

   (14) https://docs.python.org/3/library/constants.html#None

   (15) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQPARAMETERSTATUS

   (16) 
https://docs.python.org/3/library/codecs.html#codecs.CodecInfo.name

   (17) https://www.postgresql.org/docs/current/multibyte.html


File: psycopg.info,  Node: Libpq capabilities information,  Next: The description Column object,  Prev: Connection information,  Up: Other top-level objects

1.3.5.2 Libpq capabilities information
......................................

 -- Class: psycopg.Capabilities

     An object to check if a feature is supported by the libpq available
     on the client.

     An instance of this object is normally exposed by the module as the
     object *note psycopg.capabilities: 1a5.

     Every feature check is implemented by an ‘has_SOMETHING()’ method.
     All the methods return a boolean value stating if the capability is
     supported, which can be used by a program to degrade gracefully:

          if psycopg.capabilities.has_pipeline()
              with conn.pipeline():
                  operations(conn)
          else:
              logger.warning("slower")
              operations(conn)

     If ‘check’ is ‘True’, and the capability is not supported, raise a
     *note NotSupportedError: 1af. instead of returning ‘False’,
     explaining why the feature is not supported.  This allows to make a
     check at import time, crashing early and with a clear description
     of the problem.

          >>> import psycopg
          >>> psycopg.capabilities.has_pipeline(check=True)
          Traceback (most recent call last):
            ...
          psycopg.NotSupportedError: the feature 'Connection.pipeline()' is not available:
              the client libpq version (imported from system libraries) is 13.4; the
              feature requires libpq version 14.0 or newer

     Added in version 3.2.

      -- Method: has_encrypt_password (check: bool = False) -> bool

          Check if the ‘PGconn.encrypt_password()’ method is
          implemented.

          The feature requires libpq 10.0 and greater.

      -- Method: has_hostaddr (check: bool = False) -> bool

          Check if the *note ConnectionInfo.hostaddr: 238. attribute is
          implemented.

          The feature requires libpq 12.0 and greater.

      -- Method: has_pipeline (check: bool = False) -> bool

          Check if the *note pipeline mode: 13. is supported.

          The feature requires libpq 14.0 and greater.

      -- Method: has_set_trace_flags (check: bool = False) -> bool

          Check if the *note pq.PGconn.set_trace_flags(): 243. method is
          implemented.

          The feature requires libpq 14.0 and greater.

      -- Method: has_cancel_safe (check: bool = False) -> bool

          Check if the *note Connection.cancel_safe(): 1c4. method is
          implemented.

          The feature requires libpq 17.0 and greater.

               Note: The ‘cancel_safe()’ method is implemented anyway,
               but it will use the legacy ‘PQcancel(1)’ implementation.

      -- Method: has_stream_chunked (check: bool = False) -> bool

          Check if *note Cursor.stream(): 19b. can handle a ‘size’
          parameter value greater than 1 to retrieve results by chunks.

          The feature requires libpq 17.0 and greater.

      -- Method: has_send_close_prepared (check: bool = False) -> bool

          Check if the ‘pq.PGconn.send_closed_prepared()’ method is
          implemented.

          The feature requires libpq 17.0 and greater.

          See also
          ........

          *note Using prepared statements with PgBouncer: 18f.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCEL


File: psycopg.info,  Node: The description Column object,  Next: Notifications,  Prev: Libpq capabilities information,  Up: Other top-level objects

1.3.5.3 The description ‘Column’ object
.......................................

 -- Class: psycopg.Column

     An object describing a column of data from a database result, as
     described by the DBAPI(1), so it can also be unpacked as a 7-items
     tuple.

     The object is returned by *note Cursor.description: 13b.

      -- Attribute: name

          The name of the column.

      -- Attribute: type_code

          The numeric OID of the column.

      -- Attribute: type_display

          A pretty representation of the column type.

          It is composed by the type name, followed by eventual
          modifiers and brackets to signify arrays, e.g.  ‘text’,
          ‘varchar(42)’, ‘date[]’.

          Added in version 3.2.

      -- Attribute: display_size

          The field size, for string types such as ‘varchar(n)’.

      -- Attribute: internal_size

          The internal field size for fixed-size types, None otherwise.

      -- Attribute: precision

          The number of digits for fixed precision types.

      -- Attribute: scale

          The number of digits after the decimal point if available.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0249/#description


File: psycopg.info,  Node: Notifications,  Next: Pipeline-related objects,  Prev: The description Column object,  Up: Other top-level objects

1.3.5.4 Notifications
.....................

 -- Class: psycopg.Notify

     An asynchronous notification received from the database.

     The object is usually returned by *note Connection.notifies(): 11c.

      -- Attribute: channel: str(1)

          The name of the channel on which the notification was
          received.

      -- Attribute: payload: str(2)

          The message attached to the notification.

      -- Attribute: pid: int(3)

          The PID of the backend process which sent the notification.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#str

   (2) https://docs.python.org/3/library/stdtypes.html#str

   (3) https://docs.python.org/3/library/functions.html#int


File: psycopg.info,  Node: Pipeline-related objects,  Next: Transaction-related objects,  Prev: Notifications,  Up: Other top-level objects

1.3.5.5 Pipeline-related objects
................................

See *note Pipeline mode support: 13. for details.

 -- Class: psycopg.Pipeline (conn: Connection[Any], _no_lock: bool =
          False)

     Handler for (sync) connection in pipeline mode.

     This objects is returned by *note Connection.pipeline(): 198.

      -- Method: sync () -> None

          Sync the pipeline, send any pending command and receive and
          process all available results.

      -- Method: classmethod is_supported () -> bool

          Return ‘True’ if the psycopg libpq wrapper supports pipeline
          mode.

 -- Class: psycopg.AsyncPipeline (conn: AsyncConnection[Any], _no_lock:
          bool = False)

     Handler for (async) connection in pipeline mode.

     This objects is returned by *note AsyncConnection.pipeline(): 1d8.

      -- Method: async sync () -> None

          Sync the pipeline, send any pending command and receive and
          process all available results.


File: psycopg.info,  Node: Transaction-related objects,  Next: Two-Phase Commit related objects,  Prev: Pipeline-related objects,  Up: Other top-level objects

1.3.5.6 Transaction-related objects
...................................

See *note Transactions management: 42. for details about these objects.

 -- Class: psycopg.IsolationLevel (*values)

     Enum representing the isolation level for a transaction.

     The value is usually used with the *note
     Connection.isolation_level: b4. property.

     Check the PostgreSQL documentation for a description of the effects
     of the different levels of transaction isolation(1).

      -- Attribute: READ_UNCOMMITTED = 1

      -- Attribute: READ_COMMITTED = 2

      -- Attribute: REPEATABLE_READ = 3

      -- Attribute: SERIALIZABLE = 4

 -- Class: psycopg.Transaction

     Returned by *note Connection.transaction(): 47. to handle a
     transaction block.

      -- Attribute: savepoint_name

          The name of the savepoint; ‘None’ if handling the main
          transaction.

      -- Attribute: connection

          The connection the object is managing.

 -- Class: psycopg.AsyncTransaction

     Returned by *note AsyncConnection.transaction(): 1db. to handle a
     transaction block.

      -- Attribute: connection

 -- Exception: psycopg.Rollback (transaction: Transaction |
          AsyncTransaction | None = None)

     Exit the current *note Transaction: 1bb. context immediately and
     rollback any changes made within this context.

     If a transaction context is specified in the constructor, rollback
     enclosing transactions contexts up to and including the one
     specified.

     It can be used as:

        - ‘raise Rollback’: roll back the operation that happened in the
          current transaction block and continue the program after the
          block.

        - ‘raise Rollback()’: same effect as above

        - ‘raise Rollback(TX)’: roll back any operation that happened in
          the *note Transaction: 1bb. ‘tx’ (returned by a statement such
          as ‘with conn.transaction() as TX:’ and all the blocks nested
          within.  The program will continue after the ‘tx’ block.

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/transaction-iso.html


File: psycopg.info,  Node: Two-Phase Commit related objects,  Prev: Transaction-related objects,  Up: Other top-level objects

1.3.5.7 Two-Phase Commit related objects
........................................

 -- Class: psycopg.Xid

     A two-phase commit transaction identifier.

     The object can also be unpacked as a 3-item tuple (*note format_id:
     1c9, *note gtrid: 1ca, *note bqual: 1cb.).

     See *note Two-Phase Commit protocol support: bb. for details.

      -- Attribute: format_id: int(1) | None(2)

          Format Identifier of the two-phase transaction.

      -- Attribute: gtrid: str(3)

          Global Transaction Identifier of the two-phase transaction.

          If the Xid doesn’t follow the XA standard, it will be the
          PostgreSQL ID of the transaction (in which case *note
          format_id: 1c9. and *note bqual: 1cb. will be ‘None’).

      -- Attribute: bqual: str(4) | None(5)

          Branch Qualifier of the two-phase transaction.

      -- Attribute: prepared: dt.datetime | None(6) = None

          Timestamp at which the transaction was prepared for commit.

          Only available on transactions recovered by *note
          tpc_recover(): c2.

      -- Attribute: owner: str(7) | None(8) = None

          Named of the user that executed the transaction.

          Only available on recovered transactions.

      -- Attribute: database: str(9) | None(10) = None

          Named of the database in which the transaction was executed.

          Only available on recovered transactions.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#int

   (2) https://docs.python.org/3/library/constants.html#None

   (3) https://docs.python.org/3/library/stdtypes.html#str

   (4) https://docs.python.org/3/library/stdtypes.html#str

   (5) https://docs.python.org/3/library/constants.html#None

   (6) https://docs.python.org/3/library/constants.html#None

   (7) https://docs.python.org/3/library/stdtypes.html#str

   (8) https://docs.python.org/3/library/constants.html#None

   (9) https://docs.python.org/3/library/stdtypes.html#str

   (10) https://docs.python.org/3/library/constants.html#None


File: psycopg.info,  Node: sql – SQL string composition,  Next: rows – row factory implementations,  Prev: Other top-level objects,  Up: Psycopg 3 API

1.3.6 ‘sql’ – SQL string composition
------------------------------------

The module contains objects and functions useful to generate SQL
dynamically, in a convenient and safe way.  SQL identifiers (e.g.  names
of tables and fields) cannot be passed to the *note execute(): 3a.
method like query arguments:

     # This will not work
     table_name = 'my_table'
     cur.execute("INSERT INTO %s VALUES (%s, %s)", [table_name, 10, 20])

The SQL query should be composed before the arguments are merged, for
instance:

     # This works, but it is not optimal
     table_name = 'my_table'
     cur.execute(
         "INSERT INTO %s VALUES (%%s, %%s)" % table_name,
         [10, 20])

This sort of works, but it is an accident waiting to happen: the table
name may be an invalid SQL literal and need quoting; even more serious
is the security problem in case the table name comes from an untrusted
source.  The name should be escaped using ‘escape_identifier()’:

     from psycopg.pq import Escaping

     # This works, but it is not optimal
     table_name = 'my_table'
     cur.execute(
         "INSERT INTO %s VALUES (%%s, %%s)" % Escaping.escape_identifier(table_name),
         [10, 20])

This is now safe, but it somewhat ad-hoc.  In case, for some reason, it
is necessary to include a value in the query string (as opposite as in a
value) the merging rule is still different.  It is also still relatively
dangerous: if ‘escape_identifier()’ is forgotten somewhere, the program
will usually work, but will eventually crash in the presence of a table
or field name with containing characters to escape, or will present a
potentially exploitable weakness.

The objects exposed by the ‘psycopg.sql’ module allow generating SQL
statements on the fly, separating clearly the variable parts of the
statement from the query parameters:

     from psycopg import sql

     cur.execute(
         sql.SQL("INSERT INTO {} VALUES (%s, %s)")
             .format(sql.Identifier('my_table')),
         [10, 20])

* Menu:

* Module usage::
* sql objects::
* Utility functions::


File: psycopg.info,  Node: Module usage,  Next: sql objects,  Up: sql – SQL string composition

1.3.6.1 Module usage
....................

Usually you should express the template of your query as an *note SQL:
131. instance with ‘{}’-style placeholders and use *note format(): 25f.
to merge the variable parts into them, all of which must be *note
Composable: 260. subclasses.  You can still have ‘%s’-style placeholders
in your query and pass values to *note execute(): 3a.: such value
placeholders will be untouched by ‘format()’:

     query = sql.SQL("SELECT {field} FROM {table} WHERE {pkey} = %s").format(
         field=sql.Identifier('my_name'),
         table=sql.Identifier('some_table'),
         pkey=sql.Identifier('id'))

The resulting object is meant to be passed directly to cursor methods
such as *note execute(): 3a, *note executemany(): 3b, *note copy(): c8,
but can also be used to compose a query as a Python string, using the
*note as_string(): 261. method:

     cur.execute(query, (42,))
     full_query = query.as_string(cur)

If part of your query is a variable sequence of arguments, such as a
comma-separated list of field names, you can use the *note SQL.join():
262. method to pass them to the query:

     query = sql.SQL("SELECT {fields} FROM {table}").format(
         fields=sql.SQL(',').join([
             sql.Identifier('field1'),
             sql.Identifier('field2'),
             sql.Identifier('field3'),
         ]),
         table=sql.Identifier('some_table'))


File: psycopg.info,  Node: sql objects,  Next: Utility functions,  Prev: Module usage,  Up: sql – SQL string composition

1.3.6.2 ‘sql’ objects
.....................

The ‘sql’ objects are in the following inheritance hierarchy:

     *note Composable: 260.: the base class exposing the common interface
     ‘|__’ *note SQL: 131.: a literal snippet of an SQL query
     ‘|__’ *note Identifier: 264.: a PostgreSQL identifier or dot-separated sequence of identifiers
     ‘|__’ *note Literal: 265.: a value hardcoded into a query
     ‘|__’ *note Placeholder: 266.: a ‘%s’-style placeholder whose value will be added later e.g. by *note execute(): 3a.
     ‘|__’ *note Composed: 1ba.: a sequence of ‘Composable’ instances.

 -- Class: psycopg.sql.Composable

     Abstract base class for objects that can be used to compose an SQL
     string.

     ‘Composable’ objects can be joined using the ‘+’ operator: the
     result will be a *note Composed: 1ba. instance containing the
     objects joined.  The operator ‘*’ is also supported with an integer
     argument: the result is a ‘Composed’ instance containing the left
     argument repeated as many times as requested.

     ‘SQL’ and ‘Composed’ objects can be passed directly to *note
     execute(): 3a, *note executemany(): 3b, *note copy(): c8. in place
     of the query string.

      -- Method: as_string (context: AdaptContext | None = None) -> str

          Return the value of the object as string.


          Parameters: ‘context’ (connection(1) or cursor(2)) – the
          context to evaluate the string into.

     Changed in version 3.2: The ‘context’ parameter is optional.

          Warning: If a context is not specified, the results are
          “generic” and not tailored for a specific target connection.
          Details such as the connection encoding and escaping style
          will not be taken into account.

      -- Method: abstract as_bytes (context: AdaptContext | None = None)
               -> bytes

          Return the value of the object as bytes.


          Parameters: ‘context’ (connection(3) or cursor(4)) – the
          context to evaluate the object into.

          The method is automatically invoked by *note execute(): 3a,
          *note executemany(): 3b, *note copy(): c8. if a ‘Composable’
          is passed instead of the query string.

     Changed in version 3.2: The ‘context’ parameter is optional.  See
     *note as_string: 261. for details.

 -- Class: psycopg.sql.SQL (obj: LiteralString)

     A *note Composable: 260. representing a snippet of SQL statement.

     ‘SQL’ exposes *note join(): 262. and *note format(): 25f. methods
     useful to create a template where to merge variable parts of a
     query (for instance field or table names).

     The ‘obj’ string doesn’t undergo any form of escaping, so it is not
     suitable to represent variable identifiers or values: you should
     only use it to pass constant strings representing templates or
     snippets of SQL statements; use other objects such as *note
     Identifier: 264. or *note Literal: 265. to represent variable
     parts.

     ‘SQL’ objects can be passed directly to *note execute(): 3a, *note
     executemany(): 3b, *note copy(): c8. in place of the query string.

     Example:

          >>> query = sql.SQL("SELECT {0} FROM {1}").format(
          ...    sql.SQL(', ').join([sql.Identifier('foo'), sql.Identifier('bar')]),
          ...    sql.Identifier('table'))
          >>> print(query.as_string(conn))
          SELECT "foo", "bar" FROM "table"

     Changed in version 3.1: The input object should be a
     LiteralString(5).  See PEP 675(6) for details.

      -- Method: format (*args: Any, **kwargs: Any) -> Composed

          Merge *note Composable: 260. objects into a template.


          Parameters:

             * ‘args’ – parameters to replace to numbered (‘{0}’, ‘{1}’)
               or auto-numbered (‘{}’) placeholders

             * ‘kwargs’ – parameters to replace to named (‘{name}’)
               placeholders


          Returns: the union of the ‘SQL’ string with placeholders
          replaced


          Return type: *note Composed: 1ba.

          The method is similar to the Python ‘str.format()’ method: the
          string template supports auto-numbered (‘{}’), numbered
          (‘{0}’, ‘{1}’…), and named placeholders (‘{name}’), with
          positional arguments replacing the numbered placeholders and
          keywords replacing the named ones.  However placeholder
          modifiers (‘{0!r}’, ‘{0:<10}’) are not supported.

          If a ‘Composable’ objects is passed to the template it will be
          merged according to its ‘as_string()’ method.  If any other
          Python object is passed, it will be wrapped in a *note
          Literal: 265. object and so escaped according to SQL rules.

          Example:

               >>> print(sql.SQL("SELECT * FROM {} WHERE {} = %s")
               ...     .format(sql.Identifier('people'), sql.Identifier('id'))
               ...     .as_string(conn))
               SELECT * FROM "people" WHERE "id" = %s

               >>> print(sql.SQL("SELECT * FROM {tbl} WHERE name = {name}")
               ...     .format(tbl=sql.Identifier('people'), name="O'Rourke"))
               ...     .as_string(conn))
               SELECT * FROM "people" WHERE name = 'O''Rourke'

      -- Method: join (seq: Iterable[Any]) -> Composed

          Join a sequence of *note Composable: 260.


          Parameters: ‘seq’ – the elements to join.  Elements that are
          not *note Composable: 260. will be considered *note Literal:
          265.

          Use the ‘SQL’ object’s string to separate the elements in
          ‘seq’.  Note that *note Composed: 1ba. objects are iterable
          too, so they can be used as argument for this method.

          Example:

               >>> snip = sql.SQL(', ').join(
               ...     sql.Identifier(n) for n in ['foo', 'bar', 'baz'])
               >>> print(snip.as_string(conn))
               "foo", "bar", "baz"

 -- Class: psycopg.sql.Identifier (*strings: str)

     A *note Composable: 260. representing an SQL identifier or a
     dot-separated sequence.

     Identifiers usually represent names of database objects, such as
     tables or fields.  PostgreSQL identifiers follow different rules(7)
     than SQL string literals for escaping (e.g.  they use double quotes
     instead of single).

     Example:

          >>> t1 = sql.Identifier("foo")
          >>> t2 = sql.Identifier("ba'r")
          >>> t3 = sql.Identifier('ba"z')
          >>> print(sql.SQL(', ').join([t1, t2, t3]).as_string(conn))
          "foo", "ba'r", "ba""z"

     Multiple strings can be passed to the object to represent a
     qualified name, i.e.  a dot-separated sequence of identifiers.

     Example:

          >>> query = sql.SQL("SELECT {} FROM {}").format(
          ...     sql.Identifier("table", "field"),
          ...     sql.Identifier("schema", "table"))
          >>> print(query.as_string(conn))
          SELECT "table"."field" FROM "schema"."table"

 -- Class: psycopg.sql.Literal (obj: Any)

     A *note Composable: 260. representing an SQL value to include in a
     query.

     Usually you will want to include placeholders in the query and pass
     values as ‘execute()’ arguments.  If however you really really need
     to include a literal value in the query you can use this object.

     The string returned by ‘as_string()’ follows the normal *note
     adaptation rules: 41. for Python objects.

     Example:

          >>> s1 = sql.Literal("fo'o")
          >>> s2 = sql.Literal(42)
          >>> s3 = sql.Literal(date(2000, 1, 1))
          >>> print(sql.SQL(', ').join([s1, s2, s3]).as_string(conn))
          'fo''o', 42, '2000-01-01'::date

     Changed in version 3.1: Add a type cast to the representation if
     useful in ambiguous context (e.g.  ‘'2000-01-01'::date’)

 -- Class: psycopg.sql.Placeholder (name: str = '', format: str |
          PyFormat = PyFormat.AUTO)

     A *note Composable: 260. representing a placeholder for query
     parameters.

     If the name is specified, generate a named placeholder (e.g.
     ‘%(name)s’, ‘%(name)b’), otherwise generate a positional
     placeholder (e.g.  ‘%s’, ‘%b’).

     The object is useful to generate SQL queries with a variable number
     of arguments.

     Examples:

          >>> names = ['foo', 'bar', 'baz']

          >>> q1 = sql.SQL("INSERT INTO my_table ({}) VALUES ({})").format(
          ...     sql.SQL(', ').join(map(sql.Identifier, names)),
          ...     sql.SQL(', ').join(sql.Placeholder() * len(names)))
          >>> print(q1.as_string(conn))
          INSERT INTO my_table ("foo", "bar", "baz") VALUES (%s, %s, %s)

          >>> q2 = sql.SQL("INSERT INTO my_table ({}) VALUES ({})").format(
          ...     sql.SQL(', ').join(map(sql.Identifier, names)),
          ...     sql.SQL(', ').join(map(sql.Placeholder, names)))
          >>> print(q2.as_string(conn))
          INSERT INTO my_table ("foo", "bar", "baz") VALUES (%(foo)s, %(bar)s, %(baz)s)

 -- Class: psycopg.sql.Composed (seq: Sequence[Any])

     A *note Composable: 260. object made of a sequence of ‘Composable’.

     The object is usually created using ‘Composable’ operators and
     methods (such as the *note SQL.format(): 25f. method).  ‘Composed’
     objects can be passed directly to *note execute(): 3a, *note
     executemany(): 3b, *note copy(): c8. in place of the query string.

     It is also possible to create a ‘Composed’ directly specifying a
     sequence of objects as arguments: if they are not ‘Composable’ they
     will be wrapped in a *note Literal: 265.

     Example:

          >>> comp = sql.Composed(
          ...     [sql.SQL("INSERT INTO "), sql.Identifier("table")])
          >>> print(comp.as_string(conn))
          INSERT INTO "table"

     ‘Composed’ objects are iterable (so they can be used in *note
     SQL.join: 262. for instance).

      -- Method: join (joiner: SQL | LiteralString) -> Composed

          Return a new ‘Composed’ interposing the ‘joiner’ with the
          ‘Composed’ items.

          The ‘joiner’ must be a *note SQL: 131. or a string which will
          be interpreted as an *note SQL: 131.

          Example:

               >>> fields = sql.Identifier('foo') + sql.Identifier('bar')  # a Composed
               >>> print(fields.join(', ').as_string(conn))
               "foo", "bar"

   ---------- Footnotes ----------

   (1) https://www.psycopg.org/docs/connection.html#connection

   (2) https://www.psycopg.org/docs/cursor.html#cursor

   (3) https://www.psycopg.org/docs/connection.html#connection

   (4) https://www.psycopg.org/docs/cursor.html#cursor

   (5) 
https://docs.python.org/3/library/typing.html#typing.LiteralString

   (6) https://peps.python.org/pep-0675/

   (7) 
https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS


File: psycopg.info,  Node: Utility functions,  Prev: sql objects,  Up: sql – SQL string composition

1.3.6.3 Utility functions
.........................

 -- Function: psycopg.sql.quote (obj: Any, context: AdaptContext | None
          = None) -> str

     Adapt a Python object to a quoted SQL string.

     Use this function only if you absolutely want to convert a Python
     string to an SQL quoted literal to use e.g.  to generate batch SQL
     and you won’t have a connection available when you will need to use
     it.

     This function is relatively inefficient, because it doesn’t cache
     the adaptation rules.  If you pass a ‘context’ you can adapt the
     adaptation rules used, otherwise only global rules are used.

 -- Data: psycopg.sql.NULL
 -- Data: psycopg.sql.DEFAULT

     ‘sql.SQL’ objects often useful in queries.


File: psycopg.info,  Node: rows – row factory implementations,  Next: errors – Package exceptions,  Prev: sql – SQL string composition,  Up: Psycopg 3 API

1.3.7 ‘rows’ – row factory implementations
------------------------------------------

The module exposes a few generic ‘RowFactory’ implementation, which can
be used to retrieve data from the database in more complex structures
than the basic tuples.

Check out *note Creating new row factories: 139. for information about
how to use these objects.

 -- Function: psycopg.rows.tuple_row (cursor: BaseCursor[Any, Any]) ->
          RowMaker[TupleRow]

     Row factory to represent rows as simple tuples.

     This is the default factory, used when *note connect(): 33. or
     *note cursor(): 37. are called without a ‘row_factory’ parameter.

     Example:

          >>> cur = conn.cursor(row_factory=tuple_row)
          >>> cur.execute("SELECT 10 AS foo, 'hello' AS bar").fetchone()
          (10, 'hello')

 -- Function: psycopg.rows.dict_row (cursor: BaseCursor[Any, Any]) ->
          RowMaker[DictRow]

     Row factory to represent rows as dictionaries.

     The dictionary keys are taken from the column names of the returned
     columns.

     Example:

          >>> cur = conn.cursor(row_factory=dict_row)
          >>> cur.execute("SELECT 10 AS foo, 'hello' AS bar").fetchone()
          {'foo': 10, 'bar': 'hello'}

 -- Function: psycopg.rows.namedtuple_row (cursor: BaseCursor[Any, Any])
          -> RowMaker[NamedTuple]

     Row factory to represent rows as namedtuple(1).

     The field names are taken from the column names of the returned
     columns, with some mangling to deal with invalid names.

     Example:

          >>> cur = conn.cursor(row_factory=namedtuple_row)
          >>> cur.execute("SELECT 10 AS foo, 'hello' AS bar").fetchone()
          Row(foo=10, bar='hello')

 -- Function: psycopg.rows.scalar_row (cursor: BaseCursor[Any, Any]) ->
          RowMaker[Any]

     Generate a row factory returning the first column as a scalar
     value.

     Example:

          >>> cur = conn.cursor(row_factory=scalar_row)
          >>> cur.execute("SELECT 10 AS foo, 'hello' AS bar").fetchone()
          10

     Added in version 3.2.

 -- Function: psycopg.rows.class_row (cls: type[T]) -> BaseRowFactory[T]

     Generate a row factory to represent rows as instances of the class
     ‘cls’.

     The class must support every output column name as a keyword
     parameter.


     Parameters: ‘cls’ – The class to return for each row.  It must
     support the fields returned by the query as keyword arguments.


     Return type: ‘Callable[[Cursor],’ *note RowMaker: 13e.[~T]]

     This is not a row factory, but rather a factory of row factories.
     Specifying ‘row_factory=class_row(MyClass)’ will create connections
     and cursors returning ‘MyClass’ objects on fetch.

     Example:

          from dataclasses import dataclass
          import psycopg
          from psycopg.rows import class_row

          @dataclass
          class Person:
              first_name: str
              last_name: str
              age: int = None

          conn = psycopg.connect()
          cur = conn.cursor(row_factory=class_row(Person))

          cur.execute("select 'John' as first_name, 'Smith' as last_name").fetchone()
          # Person(first_name='John', last_name='Smith', age=None)

 -- Function: psycopg.rows.args_row (func: Callable[[...], T]) ->
          BaseRowFactory[T]

     Generate a row factory calling ‘func’ with positional parameters
     for every row.


     Parameters: ‘func’ – The function to call for each row.  It must
     support the fields returned by the query as positional arguments.

 -- Function: psycopg.rows.kwargs_row (func: Callable[[...], T]) ->
          BaseRowFactory[T]

     Generate a row factory calling ‘func’ with keyword parameters for
     every row.


     Parameters: ‘func’ – The function to call for each row.  It must
     support the fields returned by the query as keyword arguments.

* Menu:

* Formal rows protocols::

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/collections.html#collections.namedtuple


File: psycopg.info,  Node: Formal rows protocols,  Up: rows – row factory implementations

1.3.7.1 Formal rows protocols
.............................

These objects can be used to describe your own rows adapter for static
typing checks, such as mypy(1).

 -- Class: psycopg.rows.RowMaker

     Callable protocol taking a sequence of value and returning an
     object.

     The sequence of value is what is returned from a database query,
     already adapted to the right Python types.  The return value is the
     object that your program would like to receive: by default (*note
     tuple_row(): 1b4.) it is a simple tuple, but it may be any type of
     object.

     Typically, ‘RowMaker’ functions are returned by *note RowFactory:
     13d.

      -- Method: __call__ (values: Sequence[Any]) -> Row

          Convert a sequence of values from the database to a finished
          object.

 -- Class: psycopg.rows.RowFactory

     Callable protocol taking a *note Cursor: 36. and returning a *note
     RowMaker: 13e.

     A ‘RowFactory’ is typically called when a ‘Cursor’ receives a
     result.  This way it can inspect the cursor state (for instance the
     *note description: 13b. attribute) and help a ‘RowMaker’ to create
     a complete object.

     For instance the *note dict_row(): f0. ‘RowFactory’ uses the names
     of the column to define the dictionary key and returns a ‘RowMaker’
     function which would use the values to create a dictionary for each
     record.

      -- Method: __call__ (cursor: Cursor[Row]) -> RowMaker[Row]

          Inspect the result on a cursor and return a *note RowMaker:
          13e. to convert rows.

 -- Class: psycopg.rows.AsyncRowFactory

     Like *note RowFactory: 13d, taking an async cursor as argument.

 -- Class: psycopg.rows.BaseRowFactory

     Like *note RowFactory: 13d, taking either type of cursor as
     argument.

Note that it’s easy to implement an object implementing both
‘RowFactory’ and ‘AsyncRowFactory’: usually, everything you need to
implement a row factory is to access the cursor’s *note description:
13b, which is provided by both the cursor flavours.

   ---------- Footnotes ----------

   (1) https://mypy.readthedocs.io/


File: psycopg.info,  Node: errors – Package exceptions,  Next: psycopg_pool – Connection pool implementations,  Prev: rows – row factory implementations,  Up: Psycopg 3 API

1.3.8 ‘errors’ – Package exceptions
-----------------------------------

This module exposes objects to represent and examine database errors.

* Menu:

* DB-API exceptions::
* Error diagnostics::
* SQLSTATE exceptions::


File: psycopg.info,  Node: DB-API exceptions,  Next: Error diagnostics,  Up: errors – Package exceptions

1.3.8.1 DB-API exceptions
.........................

In compliance with the DB-API, all the exceptions raised by Psycopg
derive from the following classes:

     Exception
     |__ *note Warning: 1a8.
     |__ *note Error: 1a9.
         |__ *note InterfaceError: 1aa.
         |__ *note DatabaseError: 112.
             |__ *note DataError: 6f.
             |__ *note OperationalError: 1ab.
             |__ *note IntegrityError: 1ac.
             |__ *note InternalError: 1ad.
             |__ *note ProgrammingError: 1ae.
             |__ *note NotSupportedError: 1af.

These classes are exposed both by this module and the root *note
psycopg: 0. module.

 -- Exception: psycopg.Error

     Base exception for all the errors psycopg will raise.

     Exception that is the base class of all other error exceptions.
     You can use this to catch all errors with one single ‘except’
     statement.

     This exception is guaranteed to be picklable.

      -- Attribute: diag

          A ‘Diagnostic’ object to inspect details of the errors from
          the database.

      -- Attribute: sqlstate: str(1) | None(2) = None

          The code of the error, if received from the server.

          This attribute is also available as class attribute on the
          *note SQLSTATE exceptions: 1a7. classes.

      -- Attribute: pgconn: *note pq.PGconn: 1c1. | None(3)

          The connection object, if the error was raised from a
          connection attempt.

          It has been closed and will be in *note BAD: 22e. state;
          however it might be useful to verify precisely what went
          wrong, for instance checking the *note needs_password: 27c.
          and *note used_password: 27d. attributes.  Attempting to
          operate this connection will raise an *note OperationalError:
          1ab.

          Added in version 3.1.

      -- Attribute: pgresult: *note pq.PGresult: 189. | None(4)

          The result object, if the exception was raised after a failed
          query.

          Added in version 3.1.

 -- Exception: psycopg.Warning

     Exception raised for important warnings.

     Defined for DBAPI compatibility, but never raised by ‘psycopg’.

 -- Exception: psycopg.InterfaceError

     An error related to the database interface rather than the database
     itself.

 -- Exception: psycopg.DatabaseError

     Exception raised for errors that are related to the database.

 -- Exception: psycopg.DataError

     An error caused by problems with the processed data.

     Examples may be division by zero, numeric value out of range, etc.

 -- Exception: psycopg.OperationalError

     An error related to the database’s operation.

     These errors are not necessarily under the control of the
     programmer, e.g.  an unexpected disconnect occurs, the data source
     name is not found, a transaction could not be processed, a memory
     allocation error occurred during processing, etc.

 -- Exception: psycopg.IntegrityError

     An error caused when the relational integrity of the database is
     affected.

     An example may be a foreign key check failed.

 -- Exception: psycopg.InternalError

     An error generated when the database encounters an internal error,

     Examples could be the cursor is not valid anymore, the transaction
     is out of sync, etc.

 -- Exception: psycopg.ProgrammingError

     Exception raised for programming errors

     Examples may be table not found or already exists, syntax error in
     the SQL statement, wrong number of parameters specified, etc.

 -- Exception: psycopg.NotSupportedError

     A method or database API was used which is not supported by the
     database.

* Menu:

* Other Psycopg errors::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#str

   (2) https://docs.python.org/3/library/constants.html#None

   (3) https://docs.python.org/3/library/constants.html#None

   (4) https://docs.python.org/3/library/constants.html#None


File: psycopg.info,  Node: Other Psycopg errors,  Up: DB-API exceptions

1.3.8.2 Other Psycopg errors
............................

In addition to the standard DB-API errors, Psycopg defines a few more
specific ones.

 -- Exception: psycopg.errors.ConnectionTimeout

     Exception raised on timeout of the *note connect(): 33. method.

     The error is raised if the ‘connect_timeout’ is specified and a
     connection is not obtained in useful time.

     Subclass of *note OperationalError: 1ab.

 -- Exception: psycopg.errors.CancellationTimeout

     Exception raised on timeout of connection’s *note cancel_safe():
     1c4. method.

     Subclass of *note OperationalError: 1ab.

 -- Exception: psycopg.errors.PipelineAborted

     Raised when a operation fails because the current pipeline is in
     aborted state.

     Subclass of *note OperationalError: 1ab.


File: psycopg.info,  Node: Error diagnostics,  Next: SQLSTATE exceptions,  Prev: DB-API exceptions,  Up: errors – Package exceptions

1.3.8.3 Error diagnostics
.........................

 -- Class: psycopg.errors.Diagnostic

     Details from a database error report.

     The object is available as the *note Error: 1a9.*note diag: 115.
     attribute and is passed to the callback functions registered with
     *note add_notice_handler(): 113.

     All the information available from the ‘PQresultErrorField()(1)’
     function are exposed as attributes by the object.  For instance the
     ‘severity’ attribute returns the ‘PG_DIAG_SEVERITY’ code.  Please
     refer to the PostgreSQL documentation for the meaning of all the
     attributes.

     The attributes available are:

      -- Attribute: column_name
      -- Attribute: constraint_name
      -- Attribute: context
      -- Attribute: datatype_name
      -- Attribute: internal_position
      -- Attribute: internal_query
      -- Attribute: message_detail
      -- Attribute: message_hint
      -- Attribute: message_primary
      -- Attribute: schema_name
      -- Attribute: severity
      -- Attribute: severity_nonlocalized
      -- Attribute: source_file
      -- Attribute: source_function
      -- Attribute: source_line
      -- Attribute: sqlstate
      -- Attribute: statement_position
      -- Attribute: table_name

          A string with the error field if available; ‘None’ if not
          available.  The attribute value is available only for errors
          sent by the server: not all the fields are available for all
          the errors and for all the server versions.

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/17/libpq-exec.html#LIBPQ-PQRESULTERRORFIELD


File: psycopg.info,  Node: SQLSTATE exceptions,  Prev: Error diagnostics,  Up: errors – Package exceptions

1.3.8.4 SQLSTATE exceptions
...........................

Errors coming from a database server (as opposite as ones generated
client-side, such as connection failed) usually have a 5-letters error
code called SQLSTATE (available in the *note sqlstate: 291. attribute of
the error’s *note diag: 115. attribute).

Psycopg exposes a different class for each SQLSTATE value, allowing to
write idiomatic error handling code according to specific conditions
happening in the database:

     try:
         cur.execute("LOCK TABLE mytable IN ACCESS EXCLUSIVE MODE NOWAIT")
     except psycopg.errors.LockNotAvailable:
         locked = True

The exception names are generated from the PostgreSQL source code and
includes classes for every error defined by PostgreSQL in versions
between 9.6 and 15.  Every class in the module is named after what
referred as “condition name” in the documentation(1), converted to
CamelCase: e.g.  the error 22012, ‘division_by_zero’ is exposed by this
module as the class ‘DivisionByZero’.  There is a handful of… exceptions
to this rule, required for disambiguate name clashes: please refer to
the *note table below: 295. for all the classes defined.

Every exception class is a subclass of one of the *note standard DB-API
exception: 279, thus exposing the *note Error: 1a9. interface.

Changed in version 3.1.4: Added exceptions introduced in PostgreSQL 15.

 -- Function: psycopg.errors.lookup (sqlstate: str) -> type[Error]

     Lookup an error code or constant name(2) and return its exception
     class.

     Raise ‘KeyError’ if the code is not found.

     Example: if you have code using constant names or sql codes you can
     use them to look up the exception class.

          try:
              cur.execute("LOCK TABLE mytable IN ACCESS EXCLUSIVE MODE NOWAIT")
          except psycopg.errors.lookup("UNDEFINED_TABLE"):
              missing = True
          except psycopg.errors.lookup("55P03"):
              locked = True

* Menu:

* List of known exceptions::

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/errcodes-appendix.html#ERRCODES-TABLE

   (2) 
https://www.postgresql.org/docs/current/errcodes-appendix.html#ERRCODES-TABLE


File: psycopg.info,  Node: List of known exceptions,  Up: SQLSTATE exceptions

1.3.8.5 List of known exceptions
................................

The following are all the SQLSTATE-related error classed defined by this
module, together with the base DBAPI exception they derive from.

SQLSTATE      Exception                                              Base exception
                                                                     
----------------------------------------------------------------------------------------------
'Class 02'
- No Data
(this is
also a
warning
class per
the SQL
standard)

‘02000’       ‘NoData’                                               ‘DatabaseError’
                                                                     
‘02001’       ‘NoAdditionalDynamicResultSetsReturned’                ‘DatabaseError’
                                                                     
'Class 03'
- SQL
Statement
Not Yet
Complete

‘03000’       ‘SqlStatementNotYetComplete’                           ‘DatabaseError’
                                                                     
'Class 08'
-
Connection
Exception

‘08000’       ‘ConnectionException’                                  ‘OperationalError’
                                                                     
‘08001’       ‘SqlclientUnableToEstablishSqlconnection’              ‘OperationalError’
                                                                     
‘08003’       ‘ConnectionDoesNotExist’                               ‘OperationalError’
                                                                     
‘08004’       ‘SqlserverRejectedEstablishmentOfSqlconnection’        ‘OperationalError’
                                                                     
‘08006’       ‘ConnectionFailure’                                    ‘OperationalError’
                                                                     
‘08007’       ‘TransactionResolutionUnknown’                         ‘OperationalError’
                                                                     
‘08P01’       ‘ProtocolViolation’                                    ‘OperationalError’
                                                                     
'Class 09'
- Triggered
Action
Exception

‘09000’       ‘TriggeredActionException’                             ‘DatabaseError’
                                                                     
'Class 0A'
- Feature
Not
Supported

‘0A000’       ‘FeatureNotSupported’                                  ‘NotSupportedError’
                                                                     
'Class 0B'
- Invalid
Transaction
Initiation

‘0B000’       ‘InvalidTransactionInitiation’                         ‘DatabaseError’
                                                                     
'Class 0F'
- Locator
Exception

‘0F000’       ‘LocatorException’                                     ‘DatabaseError’
                                                                     
‘0F001’       ‘InvalidLocatorSpecification’                          ‘DatabaseError’
                                                                     
'Class 0L'
- Invalid
Grantor

‘0L000’       ‘InvalidGrantor’                                       ‘DatabaseError’
                                                                     
‘0LP01’       ‘InvalidGrantOperation’                                ‘DatabaseError’
                                                                     
'Class 0P'
- Invalid
Role
Specification

‘0P000’       ‘InvalidRoleSpecification’                             ‘DatabaseError’
                                                                     
'Class 0Z'
-
Diagnostics
Exception

‘0Z000’       ‘DiagnosticsException’                                 ‘DatabaseError’
                                                                     
‘0Z002’       ‘StackedDiagnosticsAccessedWithoutActiveHandler’       ‘DatabaseError’
                                                                     
'Class 10'
- XQuery
Error

‘10608’       ‘InvalidArgumentForXquery’                             ‘ProgrammingError’
                                                                     
'Class 20'
- Case Not
Found

‘20000’       ‘CaseNotFound’                                         ‘ProgrammingError’
                                                                     
'Class 21'
-
Cardinality
Violation

‘21000’       ‘CardinalityViolation’                                 ‘ProgrammingError’
                                                                     
'Class 22'
- Data
Exception

‘22000’       ‘DataException’                                        ‘DataError’
                                                                     
‘22001’       ‘StringDataRightTruncation’                            ‘DataError’
                                                                     
‘22002’       ‘NullValueNoIndicatorParameter’                        ‘DataError’
                                                                     
‘22003’       ‘NumericValueOutOfRange’                               ‘DataError’
                                                                     
‘22004’       ‘NullValueNotAllowed’                                  ‘DataError’
                                                                     
‘22005’       ‘ErrorInAssignment’                                    ‘DataError’
                                                                     
‘22007’       ‘InvalidDatetimeFormat’                                ‘DataError’
                                                                     
‘22008’       ‘DatetimeFieldOverflow’                                ‘DataError’
                                                                     
‘22009’       ‘InvalidTimeZoneDisplacementValue’                     ‘DataError’
                                                                     
‘2200B’       ‘EscapeCharacterConflict’                              ‘DataError’
                                                                     
‘2200C’       ‘InvalidUseOfEscapeCharacter’                          ‘DataError’
                                                                     
‘2200D’       ‘InvalidEscapeOctet’                                   ‘DataError’
                                                                     
‘2200F’       ‘ZeroLengthCharacterString’                            ‘DataError’
                                                                     
‘2200G’       ‘MostSpecificTypeMismatch’                             ‘DataError’
                                                                     
‘2200H’       ‘SequenceGeneratorLimitExceeded’                       ‘DataError’
                                                                     
‘2200L’       ‘NotAnXmlDocument’                                     ‘DataError’
                                                                     
‘2200M’       ‘InvalidXmlDocument’                                   ‘DataError’
                                                                     
‘2200N’       ‘InvalidXmlContent’                                    ‘DataError’
                                                                     
‘2200S’       ‘InvalidXmlComment’                                    ‘DataError’
                                                                     
‘2200T’       ‘InvalidXmlProcessingInstruction’                      ‘DataError’
                                                                     
‘22010’       ‘InvalidIndicatorParameterValue’                       ‘DataError’
                                                                     
‘22011’       ‘SubstringError’                                       ‘DataError’
                                                                     
‘22012’       ‘DivisionByZero’                                       ‘DataError’
                                                                     
‘22013’       ‘InvalidPrecedingOrFollowingSize’                      ‘DataError’
                                                                     
‘22014’       ‘InvalidArgumentForNtileFunction’                      ‘DataError’
                                                                     
‘22015’       ‘IntervalFieldOverflow’                                ‘DataError’
                                                                     
‘22016’       ‘InvalidArgumentForNthValueFunction’                   ‘DataError’
                                                                     
‘22018’       ‘InvalidCharacterValueForCast’                         ‘DataError’
                                                                     
‘22019’       ‘InvalidEscapeCharacter’                               ‘DataError’
                                                                     
‘2201B’       ‘InvalidRegularExpression’                             ‘DataError’
                                                                     
‘2201E’       ‘InvalidArgumentForLogarithm’                          ‘DataError’
                                                                     
‘2201F’       ‘InvalidArgumentForPowerFunction’                      ‘DataError’
                                                                     
‘2201G’       ‘InvalidArgumentForWidthBucketFunction’                ‘DataError’
                                                                     
‘2201W’       ‘InvalidRowCountInLimitClause’                         ‘DataError’
                                                                     
‘2201X’       ‘InvalidRowCountInResultOffsetClause’                  ‘DataError’
                                                                     
‘22021’       ‘CharacterNotInRepertoire’                             ‘DataError’
                                                                     
‘22022’       ‘IndicatorOverflow’                                    ‘DataError’
                                                                     
‘22023’       ‘InvalidParameterValue’                                ‘DataError’
                                                                     
‘22024’       ‘UnterminatedCString’                                  ‘DataError’
                                                                     
‘22025’       ‘InvalidEscapeSequence’                                ‘DataError’
                                                                     
‘22026’       ‘StringDataLengthMismatch’                             ‘DataError’
                                                                     
‘22027’       ‘TrimError’                                            ‘DataError’
                                                                     
‘2202E’       ‘ArraySubscriptError’                                  ‘DataError’
                                                                     
‘2202G’       ‘InvalidTablesampleRepeat’                             ‘DataError’
                                                                     
‘2202H’       ‘InvalidTablesampleArgument’                           ‘DataError’
                                                                     
‘22030’       ‘DuplicateJsonObjectKeyValue’                          ‘DataError’
                                                                     
‘22031’       ‘InvalidArgumentForSqlJsonDatetimeFunction’            ‘DataError’
                                                                     
‘22032’       ‘InvalidJsonText’                                      ‘DataError’
                                                                     
‘22033’       ‘InvalidSqlJsonSubscript’                              ‘DataError’
                                                                     
‘22034’       ‘MoreThanOneSqlJsonItem’                               ‘DataError’
                                                                     
‘22035’       ‘NoSqlJsonItem’                                        ‘DataError’
                                                                     
‘22036’       ‘NonNumericSqlJsonItem’                                ‘DataError’
                                                                     
‘22037’       ‘NonUniqueKeysInAJsonObject’                           ‘DataError’
                                                                     
‘22038’       ‘SingletonSqlJsonItemRequired’                         ‘DataError’
                                                                     
‘22039’       ‘SqlJsonArrayNotFound’                                 ‘DataError’
                                                                     
‘2203A’       ‘SqlJsonMemberNotFound’                                ‘DataError’
                                                                     
‘2203B’       ‘SqlJsonNumberNotFound’                                ‘DataError’
                                                                     
‘2203C’       ‘SqlJsonObjectNotFound’                                ‘DataError’
                                                                     
‘2203D’       ‘TooManyJsonArrayElements’                             ‘DataError’
                                                                     
‘2203E’       ‘TooManyJsonObjectMembers’                             ‘DataError’
                                                                     
‘2203F’       ‘SqlJsonScalarRequired’                                ‘DataError’
                                                                     
‘2203G’       ‘SqlJsonItemCannotBeCastToTargetType’                  ‘DataError’
                                                                     
‘22P01’       ‘FloatingPointException’                               ‘DataError’
                                                                     
‘22P02’       ‘InvalidTextRepresentation’                            ‘DataError’
                                                                     
‘22P03’       ‘InvalidBinaryRepresentation’                          ‘DataError’
                                                                     
‘22P04’       ‘BadCopyFileFormat’                                    ‘DataError’
                                                                     
‘22P05’       ‘UntranslatableCharacter’                              ‘DataError’
                                                                     
‘22P06’       ‘NonstandardUseOfEscapeCharacter’                      ‘DataError’
                                                                     
'Class 23'
- Integrity
Constraint
Violation

‘23000’       ‘IntegrityConstraintViolation’                         ‘IntegrityError’
                                                                     
‘23001’       ‘RestrictViolation’                                    ‘IntegrityError’
                                                                     
‘23502’       ‘NotNullViolation’                                     ‘IntegrityError’
                                                                     
‘23503’       ‘ForeignKeyViolation’                                  ‘IntegrityError’
                                                                     
‘23505’       ‘UniqueViolation’                                      ‘IntegrityError’
                                                                     
‘23514’       ‘CheckViolation’                                       ‘IntegrityError’
                                                                     
‘23P01’       ‘ExclusionViolation’                                   ‘IntegrityError’
                                                                     
'Class 24'
- Invalid
Cursor
State

‘24000’       ‘InvalidCursorState’                                   ‘InternalError’
                                                                     
'Class 25'
- Invalid
Transaction
State

‘25000’       ‘InvalidTransactionState’                              ‘InternalError’
                                                                     
‘25001’       ‘ActiveSqlTransaction’                                 ‘InternalError’
                                                                     
‘25002’       ‘BranchTransactionAlreadyActive’                       ‘InternalError’
                                                                     
‘25003’       ‘InappropriateAccessModeForBranchTransaction’          ‘InternalError’
                                                                     
‘25004’       ‘InappropriateIsolationLevelForBranchTransaction’      ‘InternalError’
                                                                     
‘25005’       ‘NoActiveSqlTransactionForBranchTransaction’           ‘InternalError’
                                                                     
‘25006’       ‘ReadOnlySqlTransaction’                               ‘InternalError’
                                                                     
‘25007’       ‘SchemaAndDataStatementMixingNotSupported’             ‘InternalError’
                                                                     
‘25008’       ‘HeldCursorRequiresSameIsolationLevel’                 ‘InternalError’
                                                                     
‘25P01’       ‘NoActiveSqlTransaction’                               ‘InternalError’
                                                                     
‘25P02’       ‘InFailedSqlTransaction’                               ‘InternalError’
                                                                     
‘25P03’       ‘IdleInTransactionSessionTimeout’                      ‘InternalError’
                                                                     
‘25P04’       ‘TransactionTimeout’                                   ‘InternalError’
                                                                     
'Class 26'
- Invalid
SQL
Statement
Name

‘26000’       ‘InvalidSqlStatementName’                              ‘ProgrammingError’
                                                                     
'Class 27'
- Triggered
Data Change
Violation

‘27000’       ‘TriggeredDataChangeViolation’                         ‘OperationalError’
                                                                     
'Class 28'
- Invalid
Authorization
Specification

‘28000’       ‘InvalidAuthorizationSpecification’                    ‘OperationalError’
                                                                     
‘28P01’       ‘InvalidPassword’                                      ‘OperationalError’
                                                                     
'Class 2B'
- Dependent
Privilege
Descriptors
Still Exist

‘2B000’       ‘DependentPrivilegeDescriptorsStillExist’              ‘InternalError’
                                                                     
‘2BP01’       ‘DependentObjectsStillExist’                           ‘InternalError’
                                                                     
'Class 2D'
- Invalid
Transaction
Termination

‘2D000’       ‘InvalidTransactionTermination’                        ‘InternalError’
                                                                     
'Class 2F'
- SQL
Routine
Exception

‘2F000’       ‘SqlRoutineException’                                  ‘OperationalError’
                                                                     
‘2F002’       ‘ModifyingSqlDataNotPermitted’                         ‘OperationalError’
                                                                     
‘2F003’       ‘ProhibitedSqlStatementAttempted’                      ‘OperationalError’
                                                                     
‘2F004’       ‘ReadingSqlDataNotPermitted’                           ‘OperationalError’
                                                                     
‘2F005’       ‘FunctionExecutedNoReturnStatement’                    ‘OperationalError’
                                                                     
'Class 34'
- Invalid
Cursor Name

‘34000’       ‘InvalidCursorName’                                    ‘ProgrammingError’
                                                                     
'Class 38'
- External
Routine
Exception

‘38000’       ‘ExternalRoutineException’                             ‘OperationalError’
                                                                     
‘38001’       ‘ContainingSqlNotPermitted’                            ‘OperationalError’
                                                                     
‘38002’       ‘ModifyingSqlDataNotPermittedExt’                      ‘OperationalError’
                                                                     
‘38003’       ‘ProhibitedSqlStatementAttemptedExt’                   ‘OperationalError’
                                                                     
‘38004’       ‘ReadingSqlDataNotPermittedExt’                        ‘OperationalError’
                                                                     
'Class 39'
- External
Routine
Invocation
Exception

‘39000’       ‘ExternalRoutineInvocationException’                   ‘OperationalError’
                                                                     
‘39001’       ‘InvalidSqlstateReturned’                              ‘OperationalError’
                                                                     
‘39004’       ‘NullValueNotAllowedExt’                               ‘OperationalError’
                                                                     
‘39P01’       ‘TriggerProtocolViolated’                              ‘OperationalError’
                                                                     
‘39P02’       ‘SrfProtocolViolated’                                  ‘OperationalError’
                                                                     
‘39P03’       ‘EventTriggerProtocolViolated’                         ‘OperationalError’
                                                                     
'Class 3B'
- Savepoint
Exception

‘3B000’       ‘SavepointException’                                   ‘OperationalError’
                                                                     
‘3B001’       ‘InvalidSavepointSpecification’                        ‘OperationalError’
                                                                     
'Class 3D'
- Invalid
Catalog
Name

‘3D000’       ‘InvalidCatalogName’                                   ‘ProgrammingError’
                                                                     
'Class 3F'
- Invalid
Schema Name

‘3F000’       ‘InvalidSchemaName’                                    ‘ProgrammingError’
                                                                     
'Class 40'
-
Transaction
Rollback

‘40000’       ‘TransactionRollback’                                  ‘OperationalError’
                                                                     
‘40001’       ‘SerializationFailure’                                 ‘OperationalError’
                                                                     
‘40002’       ‘TransactionIntegrityConstraintViolation’              ‘OperationalError’
                                                                     
‘40003’       ‘StatementCompletionUnknown’                           ‘OperationalError’
                                                                     
‘40P01’       ‘DeadlockDetected’                                     ‘OperationalError’
                                                                     
'Class 42'
- Syntax
Error or
Access Rule
Violation

‘42000’       ‘SyntaxErrorOrAccessRuleViolation’                     ‘ProgrammingError’
                                                                     
‘42501’       ‘InsufficientPrivilege’                                ‘ProgrammingError’
                                                                     
‘42601’       ‘SyntaxError’                                          ‘ProgrammingError’
                                                                     
‘42602’       ‘InvalidName’                                          ‘ProgrammingError’
                                                                     
‘42611’       ‘InvalidColumnDefinition’                              ‘ProgrammingError’
                                                                     
‘42622’       ‘NameTooLong’                                          ‘ProgrammingError’
                                                                     
‘42701’       ‘DuplicateColumn’                                      ‘ProgrammingError’
                                                                     
‘42702’       ‘AmbiguousColumn’                                      ‘ProgrammingError’
                                                                     
‘42703’       ‘UndefinedColumn’                                      ‘ProgrammingError’
                                                                     
‘42704’       ‘UndefinedObject’                                      ‘ProgrammingError’
                                                                     
‘42710’       ‘DuplicateObject’                                      ‘ProgrammingError’
                                                                     
‘42712’       ‘DuplicateAlias’                                       ‘ProgrammingError’
                                                                     
‘42723’       ‘DuplicateFunction’                                    ‘ProgrammingError’
                                                                     
‘42725’       ‘AmbiguousFunction’                                    ‘ProgrammingError’
                                                                     
‘42803’       ‘GroupingError’                                        ‘ProgrammingError’
                                                                     
‘42804’       ‘DatatypeMismatch’                                     ‘ProgrammingError’
                                                                     
‘42809’       ‘WrongObjectType’                                      ‘ProgrammingError’
                                                                     
‘42830’       ‘InvalidForeignKey’                                    ‘ProgrammingError’
                                                                     
‘42846’       ‘CannotCoerce’                                         ‘ProgrammingError’
                                                                     
‘42883’       ‘UndefinedFunction’                                    ‘ProgrammingError’
                                                                     
‘428C9’       ‘GeneratedAlways’                                      ‘ProgrammingError’
                                                                     
‘42939’       ‘ReservedName’                                         ‘ProgrammingError’
                                                                     
‘42P01’       ‘UndefinedTable’                                       ‘ProgrammingError’
                                                                     
‘42P02’       ‘UndefinedParameter’                                   ‘ProgrammingError’
                                                                     
‘42P03’       ‘DuplicateCursor’                                      ‘ProgrammingError’
                                                                     
‘42P04’       ‘DuplicateDatabase’                                    ‘ProgrammingError’
                                                                     
‘42P05’       ‘DuplicatePreparedStatement’                           ‘ProgrammingError’
                                                                     
‘42P06’       ‘DuplicateSchema’                                      ‘ProgrammingError’
                                                                     
‘42P07’       ‘DuplicateTable’                                       ‘ProgrammingError’
                                                                     
‘42P08’       ‘AmbiguousParameter’                                   ‘ProgrammingError’
                                                                     
‘42P09’       ‘AmbiguousAlias’                                       ‘ProgrammingError’
                                                                     
‘42P10’       ‘InvalidColumnReference’                               ‘ProgrammingError’
                                                                     
‘42P11’       ‘InvalidCursorDefinition’                              ‘ProgrammingError’
                                                                     
‘42P12’       ‘InvalidDatabaseDefinition’                            ‘ProgrammingError’
                                                                     
‘42P13’       ‘InvalidFunctionDefinition’                            ‘ProgrammingError’
                                                                     
‘42P14’       ‘InvalidPreparedStatementDefinition’                   ‘ProgrammingError’
                                                                     
‘42P15’       ‘InvalidSchemaDefinition’                              ‘ProgrammingError’
                                                                     
‘42P16’       ‘InvalidTableDefinition’                               ‘ProgrammingError’
                                                                     
‘42P17’       ‘InvalidObjectDefinition’                              ‘ProgrammingError’
                                                                     
‘42P18’       ‘IndeterminateDatatype’                                ‘ProgrammingError’
                                                                     
‘42P19’       ‘InvalidRecursion’                                     ‘ProgrammingError’
                                                                     
‘42P20’       ‘WindowingError’                                       ‘ProgrammingError’
                                                                     
‘42P21’       ‘CollationMismatch’                                    ‘ProgrammingError’
                                                                     
‘42P22’       ‘IndeterminateCollation’                               ‘ProgrammingError’
                                                                     
'Class 44'
- WITH
CHECK
OPTION
Violation

‘44000’       ‘WithCheckOptionViolation’                             ‘ProgrammingError’
                                                                     
'Class 53'
-
Insufficient
Resources

‘53000’       ‘InsufficientResources’                                ‘OperationalError’
                                                                     
‘53100’       ‘DiskFull’                                             ‘OperationalError’
                                                                     
‘53200’       ‘OutOfMemory’                                          ‘OperationalError’
                                                                     
‘53300’       ‘TooManyConnections’                                   ‘OperationalError’
                                                                     
‘53400’       ‘ConfigurationLimitExceeded’                           ‘OperationalError’
                                                                     
'Class 54'
- Program
Limit
Exceeded

‘54000’       ‘ProgramLimitExceeded’                                 ‘OperationalError’
                                                                     
‘54001’       ‘StatementTooComplex’                                  ‘OperationalError’
                                                                     
‘54011’       ‘TooManyColumns’                                       ‘OperationalError’
                                                                     
‘54023’       ‘TooManyArguments’                                     ‘OperationalError’
                                                                     
'Class 55'
- Object
Not In
Prerequisite
State

‘55000’       ‘ObjectNotInPrerequisiteState’                         ‘OperationalError’
                                                                     
‘55006’       ‘ObjectInUse’                                          ‘OperationalError’
                                                                     
‘55P02’       ‘CantChangeRuntimeParam’                               ‘OperationalError’
                                                                     
‘55P03’       ‘LockNotAvailable’                                     ‘OperationalError’
                                                                     
‘55P04’       ‘UnsafeNewEnumValueUsage’                              ‘OperationalError’
                                                                     
'Class 57'
- Operator
Intervention

‘57000’       ‘OperatorIntervention’                                 ‘OperationalError’
                                                                     
‘57014’       ‘QueryCanceled’                                        ‘OperationalError’
                                                                     
‘57P01’       ‘AdminShutdown’                                        ‘OperationalError’
                                                                     
‘57P02’       ‘CrashShutdown’                                        ‘OperationalError’
                                                                     
‘57P03’       ‘CannotConnectNow’                                     ‘OperationalError’
                                                                     
‘57P04’       ‘DatabaseDropped’                                      ‘OperationalError’
                                                                     
‘57P05’       ‘IdleSessionTimeout’                                   ‘OperationalError’
                                                                     
'Class 58'
- System
Error
(errors
external to
PostgreSQL
itself)

‘58000’       ‘SystemError’                                          ‘OperationalError’
                                                                     
‘58030’       ‘IoError’                                              ‘OperationalError’
                                                                     
‘58P01’       ‘UndefinedFile’                                        ‘OperationalError’
                                                                     
‘58P02’       ‘DuplicateFile’                                        ‘OperationalError’
                                                                     
‘58P03’       ‘FileNameTooLong’                                      ‘OperationalError’
                                                                     
'Class 72'
- Snapshot
Failure

‘72000’       ‘SnapshotTooOld’                                       ‘DatabaseError’
                                                                     
'Class F0'
-
Configuration
File Error

‘F0000’       ‘ConfigFileError’                                      ‘OperationalError’
                                                                     
‘F0001’       ‘LockFileExists’                                       ‘OperationalError’
                                                                     
'Class HV'
- Foreign
Data
Wrapper
Error
(SQL/MED)

‘HV000’       ‘FdwError’                                             ‘OperationalError’
                                                                     
‘HV001’       ‘FdwOutOfMemory’                                       ‘OperationalError’
                                                                     
‘HV002’       ‘FdwDynamicParameterValueNeeded’                       ‘OperationalError’
                                                                     
‘HV004’       ‘FdwInvalidDataType’                                   ‘OperationalError’
                                                                     
‘HV005’       ‘FdwColumnNameNotFound’                                ‘OperationalError’
                                                                     
‘HV006’       ‘FdwInvalidDataTypeDescriptors’                        ‘OperationalError’
                                                                     
‘HV007’       ‘FdwInvalidColumnName’                                 ‘OperationalError’
                                                                     
‘HV008’       ‘FdwInvalidColumnNumber’                               ‘OperationalError’
                                                                     
‘HV009’       ‘FdwInvalidUseOfNullPointer’                           ‘OperationalError’
                                                                     
‘HV00A’       ‘FdwInvalidStringFormat’                               ‘OperationalError’
                                                                     
‘HV00B’       ‘FdwInvalidHandle’                                     ‘OperationalError’
                                                                     
‘HV00C’       ‘FdwInvalidOptionIndex’                                ‘OperationalError’
                                                                     
‘HV00D’       ‘FdwInvalidOptionName’                                 ‘OperationalError’
                                                                     
‘HV00J’       ‘FdwOptionNameNotFound’                                ‘OperationalError’
                                                                     
‘HV00K’       ‘FdwReplyHandle’                                       ‘OperationalError’
                                                                     
‘HV00L’       ‘FdwUnableToCreateExecution’                           ‘OperationalError’
                                                                     
‘HV00M’       ‘FdwUnableToCreateReply’                               ‘OperationalError’
                                                                     
‘HV00N’       ‘FdwUnableToEstablishConnection’                       ‘OperationalError’
                                                                     
‘HV00P’       ‘FdwNoSchemas’                                         ‘OperationalError’
                                                                     
‘HV00Q’       ‘FdwSchemaNotFound’                                    ‘OperationalError’
                                                                     
‘HV00R’       ‘FdwTableNotFound’                                     ‘OperationalError’
                                                                     
‘HV010’       ‘FdwFunctionSequenceError’                             ‘OperationalError’
                                                                     
‘HV014’       ‘FdwTooManyHandles’                                    ‘OperationalError’
                                                                     
‘HV021’       ‘FdwInconsistentDescriptorInformation’                 ‘OperationalError’
                                                                     
‘HV024’       ‘FdwInvalidAttributeValue’                             ‘OperationalError’
                                                                     
‘HV090’       ‘FdwInvalidStringLengthOrBufferLength’                 ‘OperationalError’
                                                                     
‘HV091’       ‘FdwInvalidDescriptorFieldIdentifier’                  ‘OperationalError’
                                                                     
'Class P0'
- PL/pgSQL
Error

‘P0000’       ‘PlpgsqlError’                                         ‘ProgrammingError’
                                                                     
‘P0001’       ‘RaiseException’                                       ‘ProgrammingError’
                                                                     
‘P0002’       ‘NoDataFound’                                          ‘ProgrammingError’
                                                                     
‘P0003’       ‘TooManyRows’                                          ‘ProgrammingError’
                                                                     
‘P0004’       ‘AssertFailure’                                        ‘ProgrammingError’
                                                                     
'Class XX'
- Internal
Error

‘XX000’       ‘InternalError_’                                       ‘InternalError’
                                                                     
‘XX001’       ‘DataCorrupted’                                        ‘InternalError’
                                                                     
‘XX002’       ‘IndexCorrupted’                                       ‘InternalError’
                                                                     

Added in version 3.1.4: Exception ‘SqlJsonItemCannotBeCastToTargetType’,
introduced in PostgreSQL 15.

Added in version 3.2.3: Exception ‘TransactionTimeout’, introduced in
PostgreSQL 17.

Added in version 3.2.10: Exception ‘InvalidArgumentForXquery’,
‘FileNameTooLong’, introduced in PostgreSQL 18.


File: psycopg.info,  Node: psycopg_pool – Connection pool implementations,  Next: conninfo – manipulate connection strings,  Prev: errors – Package exceptions,  Up: Psycopg 3 API

1.3.9 ‘psycopg_pool’ – Connection pool implementations
------------------------------------------------------

A connection pool is an object used to create and maintain a limited
amount of PostgreSQL connections, reducing the time requested by the
program to obtain a working connection and allowing an arbitrary large
number of concurrent threads or tasks to use a controlled amount of
resources on the server.  See *note Connection pools: f. for more
details and usage pattern.

This package exposes a few connection pool classes:

   - *note ConnectionPool: 12c. is a synchronous connection pool
     yielding *note Connection: 34. objects and can be used by
     multithread applications.

   - *note AsyncConnectionPool: 142. has an interface similar to
     ‘ConnectionPool’, but with asyncio(1) functions replacing blocking
     functions, and yields *note AsyncConnection: 4a. instances.

   - *note NullConnectionPool: 14c. is a ‘ConnectionPool’ subclass
     exposing the same interface of its parent, but not keeping any
     unused connection in its state.  See *note Null connection pools:
     14b. for details about related use cases.

   - *note AsyncNullConnectionPool: 29a. has the same behaviour of the
     ‘NullConnectionPool’, but with the same async interface of the
     ‘AsyncConnectionPool’.

     Note: The ‘psycopg_pool’ package is distributed separately from the
     main *note psycopg: 0. package: use ‘pip install "psycopg[pool]"’,
     or ‘pip install psycopg_pool’, to make it available.  See *note
     Installing the connection pool: 2e.

     The version numbers indicated in this page refer to the
     ‘psycopg_pool’ package, not to *note psycopg: 0.

* Menu:

* The ConnectionPool class::
* Pool exceptions::
* The AsyncConnectionPool class::
* Null connection pools: Null connection pools<2>.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/asyncio.html#module-asyncio


File: psycopg.info,  Node: The ConnectionPool class,  Next: Pool exceptions,  Up: psycopg_pool – Connection pool implementations

1.3.9.1 The ‘ConnectionPool’ class
..................................

 -- Class: psycopg_pool.ConnectionPool (conninfo: str = '', *,
          connection_class: type[~psycopg_pool.abc.CT] = <class
          'psycopg.Connection'>, kwargs: dict[str, ~typing.Any] | None =
          None, min_size: int = 4, max_size: int | None = None, open:
          bool | None = None, configure:
          ~typing.Callable[[~psycopg_pool.abc.CT], None] | None = None,
          check: ~typing.Callable[[~psycopg_pool.abc.CT], None] | None =
          None, reset: ~typing.Callable[[~psycopg_pool.abc.CT], None] |
          None = None, name: str | None = None, timeout: float = 30.0,
          max_waiting: int = 0, max_lifetime: float = 3600.0, max_idle:
          float = 600.0, reconnect_timeout: float = 300.0,
          reconnect_failed:
          ~typing.Callable[[~psycopg_pool.pool.ConnectionPool[~typing.Any]],
          None] | None = None, num_workers: int = 3)

     This class implements a connection pool serving *note Connection:
     34. instances (or subclasses).  The constructor has 'alot' of
     arguments, but only ‘conninfo’ and ‘min_size’ are the fundamental
     ones, all the other arguments have meaningful defaults and can
     probably be tweaked later, if required.


     Parameters:

        * ‘conninfo’ (‘str’) – The connection string.  See *note
          connect(): 33. for details.

        * ‘connection_class’ (‘type’, default: *note Connection: 34.) –
          The class of the connections to serve.  It should be a
          ‘Connection’ subclass.

        * ‘kwargs’ (‘dict’) – Extra arguments to pass to ‘connect()’.
          Note that this is 'one dict argument' of the pool constructor,
          which is expanded as ‘connect()’ keyword parameters.

        * ‘min_size’ (‘int’, default: 4) – The minimum number of
          connection the pool will hold.  The pool will actively try to
          create new connections if some are lost (closed, broken) and
          will try to never go below ‘min_size’.

        * ‘max_size’ (‘int’, default: ‘None’) – The maximum number of
          connections the pool will hold.  If ‘None’, or equal to
          ‘min_size’, the pool will not grow or shrink.  If larger than
          ‘min_size’, the pool can grow if more than ‘min_size’
          connections are requested at the same time and will shrink
          back after the extra connections have been unused for more
          than ‘max_idle’ seconds.

        * ‘open’ (‘bool’, default: ‘True’) – If ‘True’, open the pool,
          creating the required connections, on init.  If ‘False’, open
          the pool when ‘open()’ is called or when the pool context is
          entered.  See the *note open(): 148. method documentation for
          more details.

        * ‘configure’ (‘Callable[[Connection], None]’) – A callback to
          configure a connection after creation.  Useful, for instance,
          to configure its adapters.  If the connection is used to run
          internal queries (to inspect the database) make sure to close
          an eventual transaction before leaving the function.

        * ‘check’ (‘Callable[[Connection], None]’) – A callback to check
          that a connection is working correctly when obtained by the
          pool.  The callback is called at every *note getconn(): 29c.
          or *note connection(): 12d.: the connection is only passed to
          the client if the callback doesn’t throw an exception.  By
          default no check is made on the connection.  You can provide
          the *note check_connection(): 152. pool static method if you
          want to perform a simple check.

        * ‘reset’ (‘Callable[[Connection], None]’) – A callback to reset
          a function after it has been returned to the pool.  The
          connection is guaranteed to be passed to the ‘reset()’
          function in “idle” state (no transaction).  When leaving the
          ‘reset()’ function the connection must be left in 'idle'
          state, otherwise it is discarded.

        * ‘name’ (‘str’) – An optional name to give to the pool, useful,
          for instance, to identify it in the logs if more than one pool
          is used.  if not specified pick a sequential name such as
          ‘pool-1’, ‘pool-2’, etc.

        * ‘timeout’ (‘float’, default: 30 seconds) – The default maximum
          time in seconds that a client can wait to receive a connection
          from the pool (using *note connection(): 12d. or *note
          getconn(): 29c.).  Note that these methods allow to override
          the ‘timeout’ default.

        * ‘max_waiting’ (‘int’, default: 0) – Maximum number of requests
          that can be queued to the pool, after which new requests will
          fail, raising *note TooManyRequests: 29d.  0 means no queue
          limit.

        * ‘max_lifetime’ (‘float’, default: 1 hour) – The maximum
          lifetime of a connection in the pool, in seconds.  Connections
          used for longer get closed and replaced by a new one.  The
          amount is reduced by a random 10% to avoid mass eviction.

        * ‘max_idle’ (‘float’, default: 10 minutes) – Maximum time, in
          seconds, that a connection can stay unused in the pool before
          being closed, and the pool shrunk.  This only happens to
          connections more than ‘min_size’, if ‘max_size’ allowed the
          pool to grow.

        * ‘reconnect_timeout’ (‘float’, default: 5 minutes) – Maximum
          time, in seconds, the pool will try to create a connection.
          If a connection attempt fails, the pool will try to reconnect
          a few times, using an exponential backoff and some random
          factor to avoid mass attempts.  If repeated attempts fail,
          after ‘reconnect_timeout’ second the connection attempt is
          aborted and the ‘reconnect_failed()’ callback invoked.

        * ‘reconnect_failed’ (‘Callable[[ConnectionPool], None]’) –
          Callback invoked if an attempt to create a new connection
          fails for more than ‘reconnect_timeout’ seconds.  The user may
          decide, for instance, to terminate the program (executing
          ‘sys.exit()’).  By default don’t do anything: restart a new
          connection attempt (if the number of connection fell below
          ‘min_size’).

        * ‘num_workers’ (‘int’, default: 3) – Number of background
          worker threads used to maintain the pool state.  Background
          workers are used for example to create new connections and to
          clean up connections when they are returned to the pool.

     Changed in version 3.1: added ‘open’ parameter to the constructor.

     Changed in version 3.2: added ‘check’ parameter to the constructor.

     Changed in version 3.2: The class is generic and ‘connection_class’
     provides types type variable.  See *note Generic pool types: 12b.

          Warning: At the moment, the default value for the ‘open’
          parameter is ‘True’; In a future version, the default will be
          changed to ‘False’.

          If you expect the pool to be open on creation even if you
          don’t use the pool as context manager, you should specify the
          parameter ‘open=True’ explicitly.

          Starting from psycopg_pool 3.2, a warning is raised if the
          pool is used with the expectation of being implicitly opened
          in the constructor and ‘open’ is not specified.

      -- Method: connection (timeout: float | None = None) ->
               Iterator[CT]

          Context manager to obtain a connection from the pool.

          Return the connection immediately if available, otherwise wait
          up to 'timeout' or ‘self.timeout’ seconds and throw *note
          PoolTimeout: 144. if a connection is not available in time.

          Upon context exit, return the connection to the pool.  Apply
          the normal *note connection context behaviour: 46.
          (commit/rollback the transaction in case of success/error).
          If the connection is no more in working state, replace it with
          a new one.

               with my_pool.connection() as conn:
                   conn.execute(...)

               # the connection is now back in the pool

          Changed in version 3.2: The connection returned is annotated
          as defined in ‘connection_class’.  See *note Generic pool
          types: 12b.

      -- Method: open (wait: bool = False, timeout: float = 30.0) ->
               None

          Open the pool by starting connecting and and accepting
          clients.

          If 'wait' is ‘False’, return immediately and let the
          background worker fill the pool if *note min_size: 158. > 0.
          Otherwise wait up to 'timeout' seconds for the requested
          number of connections to be ready (see *note wait(): 145. for
          details).

          It is safe to call ‘open()’ again on a pool already open
          (because the method was already called, or because the pool
          context was entered, or because the pool was initialized with
          'open' = ‘True’) but you cannot currently re-open a closed
          pool.

          Added in version 3.1.

      -- Method: close (timeout: float = 5.0) -> None

          Close the pool and make it unavailable to new clients.

          All the waiting and future clients will fail to acquire a
          connection with a *note PoolClosed: 29e. exception.  Currently
          used connections will not be closed until returned to the
          pool.

          Wait 'timeout' seconds for threads to terminate their job, if
          positive.  If the timeout expires the pool is closed anyway,
          although it may raise some warnings on exit.

          Note: The pool can be also used as a context manager, in which
          case it will be opened (if necessary) on entering the block
          and closed on exiting it:

               with ConnectionPool(...) as pool:
                   # code using the pool

      -- Method: wait (timeout: float = 30.0) -> None

          Wait for the pool to be full (with *note min_size: 158.
          connections) after creation.

          Close the pool, and raise *note PoolTimeout: 144, if not ready
          within 'timeout' sec.

          Calling this method is not mandatory: you can try and use the
          pool immediately after its creation.  The first client will be
          served as soon as a connection is ready.  You can use this
          method if you prefer your program to terminate in case the
          environment is not configured properly, rather than trying to
          stay up the hardest it can.

      -- Attribute: name: str(1)

          The name of the pool set on creation, or automatically
          generated if not set.

      -- Attribute: min_size

      -- Attribute: max_size

          The current minimum and maximum size of the pool.  Use *note
          resize(): 150. to change them at runtime.

      -- Method: resize (min_size: int, max_size: int | None = None) ->
               None

          Change the size of the pool during runtime.

      -- Method: check () -> None

          Verify the state of the connections currently in the pool.

          Test each connection: if it works return it to the pool,
          otherwise dispose of it and create a new one.

      -- Method: static check_connection (conn: CT) -> None

          A simple check to verify that a connection is still working.

          Return quietly if the connection is still working, otherwise
          raise an exception.

          Used internally by *note check(): 15a, but also available for
          client usage, for instance as ‘check’ callback when a pool is
          created.

          Added in version 3.2.

      -- Method: get_stats () -> dict[str, int]

          Return current stats about the pool usage.

      -- Method: pop_stats () -> dict[str, int]

          Return current stats about the pool usage.

          After the call, all the counters are reset to zero.

          See *note Pool stats: 156. for the metrics returned.

     Functionalities you may not need
     ................................

      -- Method: getconn (timeout: float | None = None) -> CT

          Obtain a connection from the pool.

          You should preferably use *note connection(): 12d.  Use this
          function only if it is not possible to use the connection as
          context manager.

          After using this function you 'must' call a corresponding
          *note putconn(): 2a0.: failing to do so will deplete the pool.
          A depleted pool is a sad pool: you don’t want a depleted pool.

      -- Method: putconn (conn: CT) -> None

          Return a connection to the loving hands of its pool.

          Use this function only paired with a *note getconn(): 29c.
          You don’t need to use it if you use the much more comfortable
          *note connection(): 12d. context manager.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#str


File: psycopg.info,  Node: Pool exceptions,  Next: The AsyncConnectionPool class,  Prev: The ConnectionPool class,  Up: psycopg_pool – Connection pool implementations

1.3.9.2 Pool exceptions
.......................

 -- Class: psycopg_pool.PoolTimeout

     The pool couldn’t provide a connection in acceptable time.

     Subclass of *note OperationalError: 1ab.

 -- Class: psycopg_pool.PoolClosed

     Attempt to get a connection from a closed pool.

     Subclass of *note OperationalError: 1ab.

 -- Class: psycopg_pool.TooManyRequests

     Too many requests in the queue waiting for a connection from the
     pool.

     Subclass of *note OperationalError: 1ab.


File: psycopg.info,  Node: The AsyncConnectionPool class,  Next: Null connection pools<2>,  Prev: Pool exceptions,  Up: psycopg_pool – Connection pool implementations

1.3.9.3 The ‘AsyncConnectionPool’ class
.......................................

‘AsyncConnectionPool’ has a very similar interface to the *note
ConnectionPool: 12c. class but its blocking methods are implemented as
‘async’ coroutines.  It returns instances of *note AsyncConnection: 4a,
or of its subclass if specified so in the ‘connection_class’ parameter.

Only the functions and parameters with different signature from
‘ConnectionPool’ are listed here.

 -- Class: psycopg_pool.AsyncConnectionPool (conninfo: str = '', *,
          connection_class: type[~psycopg_pool.abc.ACT] = <class
          'psycopg.AsyncConnection'>, kwargs: dict[str, ~typing.Any] |
          None = None, min_size: int = 4, max_size: int | None = None,
          open: bool | None = None, configure:
          ~typing.Callable[[~psycopg_pool.abc.ACT],
          ~typing.Awaitable[None]] | None = None, check:
          ~typing.Callable[[~psycopg_pool.abc.ACT],
          ~typing.Awaitable[None]] | None = None, reset:
          ~typing.Callable[[~psycopg_pool.abc.ACT],
          ~typing.Awaitable[None]] | None = None, name: str | None =
          None, timeout: float = 30.0, max_waiting: int = 0,
          max_lifetime: float = 3600.0, max_idle: float = 600.0,
          reconnect_timeout: float = 300.0, reconnect_failed:
          ~typing.Callable[[~psycopg_pool.pool_async.AsyncConnectionPool[~typing.Any]],
          None] |
          ~typing.Callable[[~psycopg_pool.pool_async.AsyncConnectionPool[~typing.Any]],
          ~typing.Awaitable[None]] | None = None, num_workers: int = 3)


     Parameters:

        * ‘connection_class’ (‘type’, default: *note AsyncConnection:
          4a.) – The class of the connections to serve.  It should be an
          ‘AsyncConnection’ subclass.

        * ‘check’ (‘async Callable[[Connection], None]’) – A callback to
          check that a connection is working correctly when obtained by
          the pool.

        * ‘configure’ (‘async Callable[[AsyncConnection], None]’) – A
          callback to configure a connection after creation.

        * ‘reset’ (‘async Callable[[AsyncConnection], None]’) – A
          callback to reset a function after it has been returned to the
          pool.

        * ‘reconnect_failed’ (‘Callable[[AsyncConnectionPool], None]’ or
          ‘async Callable[[AsyncConnectionPool], None]’) – Callback
          invoked if an attempt to create a new connection fails for
          more than ‘reconnect_timeout’ seconds.

     Changed in version 3.2: added ‘check’ parameter to the constructor.

     Changed in version 3.2: The ‘reconnect_failed’ parameter can be
     ‘async’.

          Warning: Opening an async pool in the constructor (using
          ‘open=True’ on init) will become an error in a future pool
          versions.  Please note that, currently, ‘open=True’ is the
          default; in a future version, the default for the parameter
          will be changed to ‘False’.

          In order to make sure that your code will keep working as
          expected in future versions, please specify ‘open=False’ in
          the constructor and use an explicit ‘await pool.open()’:

               pool = AsyncConnectionPool(..., open=False)
               await pool.open()

          or use the pool context manager:

               async with AsyncConnectionPool(..., open=False) as pool:
                   ...

          Starting from psycopg_pool 3.2, opening an async pool in the
          constructor raises a warning.

      -- Method: connection (timeout: float | None = None) ->
               AsyncIterator[ACT]

          Context manager to obtain a connection from the pool.

          Return the connection immediately if available, otherwise wait
          up to 'timeout' or ‘self.timeout’ seconds and throw *note
          PoolTimeout: 144. if a connection is not available in time.

          Upon context exit, return the connection to the pool.  Apply
          the normal *note connection context behaviour: 46.
          (commit/rollback the transaction in case of success/error).
          If the connection is no more in working state, replace it with
          a new one.

               async with my_pool.connection() as conn:
                   await conn.execute(...)

               # the connection is now back in the pool

      -- Method: async open (wait: bool = False, timeout: float = 30.0)
               -> None

          Open the pool by starting connecting and and accepting
          clients.

          If 'wait' is ‘False’, return immediately and let the
          background worker fill the pool if ‘min_size’ > 0.  Otherwise
          wait up to 'timeout' seconds for the requested number of
          connections to be ready (see *note wait(): 2a5. for details).

          It is safe to call ‘open()’ again on a pool already open
          (because the method was already called, or because the pool
          context was entered, or because the pool was initialized with
          'open' = ‘True’) but you cannot currently re-open a closed
          pool.

      -- Method: async close (timeout: float = 5.0) -> None

          Close the pool and make it unavailable to new clients.

          All the waiting and future clients will fail to acquire a
          connection with a *note PoolClosed: 29e. exception.  Currently
          used connections will not be closed until returned to the
          pool.

          Wait 'timeout' seconds for threads to terminate their job, if
          positive.  If the timeout expires the pool is closed anyway,
          although it may raise some warnings on exit.

          Note: The pool can be also used as an async context manager,
          in which case it will be opened (if necessary) on entering the
          block and closed on exiting it:

               async with AsyncConnectionPool(...) as pool:
                   # code using the pool

     All the other constructor parameters are the same of
     ‘ConnectionPool’.

      -- Method: async wait (timeout: float = 30.0) -> None

          Wait for the pool to be full (with ‘min_size’ connections)
          after creation.

          Close the pool, and raise *note PoolTimeout: 144, if not ready
          within 'timeout' sec.

          Calling this method is not mandatory: you can try and use the
          pool immediately after its creation.  The first client will be
          served as soon as a connection is ready.  You can use this
          method if you prefer your program to terminate in case the
          environment is not configured properly, rather than trying to
          stay up the hardest it can.

      -- Method: async resize (min_size: int, max_size: int | None =
               None) -> None

          Change the size of the pool during runtime.

      -- Method: async check () -> None

          Verify the state of the connections currently in the pool.

          Test each connection: if it works return it to the pool,
          otherwise dispose of it and create a new one.

      -- Method: async static check_connection (conn: ACT) -> None

          A simple check to verify that a connection is still working.

          Return quietly if the connection is still working, otherwise
          raise an exception.

          Used internally by *note check(): 2a8, but also available for
          client usage, for instance as ‘check’ callback when a pool is
          created.

          Added in version 3.2.

      -- Method: async getconn (timeout: float | None = None) -> ACT

          Obtain a connection from the pool.

          You should preferably use *note connection(): 2a3.  Use this
          function only if it is not possible to use the connection as
          context manager.

          After using this function you 'must' call a corresponding
          *note putconn(): 2ab.: failing to do so will deplete the pool.
          A depleted pool is a sad pool: you don’t want a depleted pool.

      -- Method: async putconn (conn: ACT) -> None

          Return a connection to the loving hands of its pool.

          Use this function only paired with a *note getconn(): 2aa.
          You don’t need to use it if you use the much more comfortable
          *note connection(): 2a3. context manager.


File: psycopg.info,  Node: Null connection pools<2>,  Prev: The AsyncConnectionPool class,  Up: psycopg_pool – Connection pool implementations

1.3.9.4 Null connection pools
.............................

Added in version 3.1.

The *note NullConnectionPool: 14c. is a *note ConnectionPool: 12c.
subclass which doesn’t create connections preemptively and doesn’t keep
unused connections in its state.  See *note Null connection pools: 14b.
for further details.

The interface of the object is entirely compatible with its parent
class.  Its behaviour is similar, with the following differences:

 -- Class: psycopg_pool.NullConnectionPool (conninfo: str = '', *,
          connection_class: type[~psycopg_pool.abc.CT] = <class
          'psycopg.Connection'>, kwargs: dict[str, ~typing.Any] | None =
          None, min_size: int = 0, max_size: int | None = None, open:
          bool | None = None, configure:
          ~typing.Callable[[~psycopg_pool.abc.CT], None] | None = None,
          check: ~typing.Callable[[~psycopg_pool.abc.CT], None] | None =
          None, reset: ~typing.Callable[[~psycopg_pool.abc.CT], None] |
          None = None, name: str | None = None, timeout: float = 30.0,
          max_waiting: int = 0, max_lifetime: float = 3600.0, max_idle:
          float = 600.0, reconnect_timeout: float = 300.0,
          reconnect_failed:
          ~typing.Callable[[~psycopg_pool.pool.ConnectionPool[~typing.Any]],
          None] | None = None, num_workers: int = 3)

     All the other constructor parameters are the same as in *note
     ConnectionPool: 12c.


     Parameters:

        * ‘min_size’ (‘int’, default: 0) – Always 0, cannot be changed.

        * ‘max_size’ (‘int’, default: None) – If None or 0, create a new
          connection at every request, without a maximum.  If greater
          than 0, don’t create more than ‘max_size’ connections and
          queue the waiting clients.

        * ‘reset’ (‘Callable[[Connection], None]’) – It is only called
          when there are waiting clients in the queue, before giving
          them a connection already open.  If no client is waiting, the
          connection is closed and discarded without a fuss.

        * ‘max_idle’ – Ignored, as null pools don’t leave idle
          connections sitting around.

      -- Method: wait (timeout: float = 30.0) -> None

          Create a connection for test.

          Calling this function will verify that the connectivity with
          the database works as expected.  However the connection will
          not be stored in the pool.

          Close the pool, and raise *note PoolTimeout: 144, if not ready
          within 'timeout' sec.

      -- Method: resize (min_size: int, max_size: int | None = None) ->
               None

          Change the size of the pool during runtime.

          Only 'max_size' can be changed; 'min_size' must remain 0.

      -- Method: check () -> None

          No-op, as the pool doesn’t have connections in its state.

The *note AsyncNullConnectionPool: 29a. is, similarly, an *note
AsyncConnectionPool: 142. subclass with the same behaviour of the *note
NullConnectionPool: 14c.

 -- Class: psycopg_pool.AsyncNullConnectionPool (conninfo: str = '', *,
          connection_class: type[~psycopg_pool.abc.ACT] = <class
          'psycopg.AsyncConnection'>, kwargs: dict[str, ~typing.Any] |
          None = None, min_size: int = 0, max_size: int | None = None,
          open: bool | None = None, configure:
          ~typing.Callable[[~psycopg_pool.abc.ACT],
          ~typing.Awaitable[None]] | None = None, check:
          ~typing.Callable[[~psycopg_pool.abc.ACT],
          ~typing.Awaitable[None]] | None = None, reset:
          ~typing.Callable[[~psycopg_pool.abc.ACT],
          ~typing.Awaitable[None]] | None = None, name: str | None =
          None, timeout: float = 30.0, max_waiting: int = 0,
          max_lifetime: float = 3600.0, max_idle: float = 600.0,
          reconnect_timeout: float = 300.0, reconnect_failed:
          ~typing.Callable[[~psycopg_pool.pool_async.AsyncConnectionPool[~typing.Any]],
          None] |
          ~typing.Callable[[~psycopg_pool.pool_async.AsyncConnectionPool[~typing.Any]],
          ~typing.Awaitable[None]] | None = None, num_workers: int = 3)

     The interface is the same of its parent class *note
     AsyncConnectionPool: 142.  The behaviour is different in the same
     way described for *note NullConnectionPool: 14c.


File: psycopg.info,  Node: conninfo – manipulate connection strings,  Next: adapt – Types adaptation,  Prev: psycopg_pool – Connection pool implementations,  Up: Psycopg 3 API

1.3.10 ‘conninfo’ – manipulate connection strings
-------------------------------------------------

This module contains a few utility functions to manipulate database
connection strings.

 -- Function: psycopg.conninfo.conninfo_to_dict (conninfo: str = '',
          **kwargs: str | int | None) -> Dict[str, str | int | None]

     Convert the ‘conninfo’ string into a dictionary of parameters.


     Parameters:

        * ‘conninfo’ – A connection string(1) as accepted by PostgreSQL.

        * ‘kwargs’ – Parameters overriding the ones specified in
          ‘conninfo’.


     Returns: Dictionary with the parameters parsed from ‘conninfo’ and
     ‘kwargs’.

     Raise *note ProgrammingError: 1ae. if ‘conninfo’ is not a a valid
     connection string.

          >>> conninfo_to_dict("postgres://jeff@example.com/db", user="piro")
          {'user': 'piro', 'dbname': 'db', 'host': 'example.com'}

 -- Function: psycopg.conninfo.make_conninfo (conninfo: str = '',
          **kwargs: str | int | None) -> str

     Merge a string and keyword params into a single conninfo string.


     Parameters:

        * ‘conninfo’ – A connection string(2) as accepted by PostgreSQL.

        * ‘kwargs’ – Parameters overriding the ones specified in
          ‘conninfo’.


     Returns: A connection string valid for PostgreSQL, with the
     ‘kwargs’ parameters merged.

     Raise *note ProgrammingError: 1ae. if the input doesn’t make a
     valid conninfo string.

          >>> make_conninfo("dbname=db user=jeff", user="piro", port=5432)
          'dbname=db user=piro port=5432'

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING

   (2) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING


File: psycopg.info,  Node: adapt – Types adaptation,  Next: types – Types information and adapters,  Prev: conninfo – manipulate connection strings,  Up: Psycopg 3 API

1.3.11 ‘adapt’ – Types adaptation
---------------------------------

The ‘psycopg.adapt’ module exposes a set of objects useful for the
configuration of 'data adaptation', which is the conversion of Python
objects to PostgreSQL data types and back.

These objects are useful if you need to configure data adaptation, i.e.
if you need to change the default way that Psycopg converts between
types or if you want to adapt custom data types and objects.  You don’t
need this object in the normal use of Psycopg.

See *note Data adaptation configuration: 4e. for an overview of the
Psycopg adaptation system.

* Menu:

* Dumpers and loaders::
* Other objects used in adaptations::


File: psycopg.info,  Node: Dumpers and loaders,  Next: Other objects used in adaptations,  Up: adapt – Types adaptation

1.3.11.1 Dumpers and loaders
............................

 -- Class: psycopg.adapt.Dumper (cls, context=None)

     Convert Python object of the type ‘cls’ to PostgreSQL
     representation.

     This is an abstract base class(1), partially implementing the *note
     Dumper: 177. protocol.  Subclasses 'must' at least implement the
     *note dump(): 2b9. method and optionally override other members.

      -- Method: abstract dump (obj: Any) -> bytes | bytearray |
               memoryview | None

          Convert the object ‘obj’ to PostgreSQL representation.


          Parameters: ‘obj’ – the object to convert.

          Changed in version 3.2: ‘dump()’ can also return ‘None’, to
          represent a ‘NULL’ in the database.

      -- Attribute: format: *note psycopg.pq.Format: 18a. = TEXT

          Class attribute.  Set it to *note BINARY: 5b. if the class
          *note dump(): 2b9. methods converts the object to binary
          format.

      -- Method: quote (obj: Any) -> bytes | bytearray | memoryview

          By default return the *note dump(): 2b9. value quoted and
          sanitised, so that the result can be used to build a SQL
          string.  This works well for most types and you won’t likely
          have to implement this method in a subclass.

      -- Method: get_key (obj: Any, format: PyFormat) -> abc.DumperKey

          Implementation of the *note get_key(): 187. member of the
          *note Dumper: 177. protocol.  Look at its definition for
          details.

          This implementation returns the ‘cls’ passed in the
          constructor.  Subclasses needing to specialise the PostgreSQL
          type according to the 'value' of the object dumped (not only
          according to to its type) should override this class.

      -- Method: upgrade (obj: Any, format: PyFormat) -> Dumper

          Implementation of the *note upgrade(): 188. member of the
          *note Dumper: 177. protocol.  Look at its definition for
          details.

          This implementation just returns ‘self’.  If a subclass
          implements *note get_key(): 2bc. it should probably override
          ‘upgrade()’ too.

 -- Class: psycopg.adapt.Loader (oid, context=None)

     Convert PostgreSQL values with type OID ‘oid’ to Python objects.

     This is an abstract base class(2), partially implementing the *note
     Loader: 178. protocol.  Subclasses 'must' at least implement the
     *note load(): 2be. method and optionally override other members.

      -- Method: abstract load (data: bytes | bytearray | memoryview) ->
               Any

          Convert a PostgreSQL value to a Python object.

      -- Attribute: format: *note psycopg.pq.Format: 18a. = TEXT

          Class attribute.  Set it to *note BINARY: 5b. if the class
          *note load(): 2be. methods converts the object from binary
          format.

   ---------- Footnotes ----------

   (1) https://docs.python.org/glossary.html#term-abstract-base-class

   (2) https://docs.python.org/glossary.html#term-abstract-base-class


File: psycopg.info,  Node: Other objects used in adaptations,  Prev: Dumpers and loaders,  Up: adapt – Types adaptation

1.3.11.2 Other objects used in adaptations
..........................................

 -- Class: psycopg.adapt.PyFormat (*values)

     Enum representing the format wanted for a query argument.

     The value *note AUTO: 185. allows psycopg to choose the best format
     for a certain parameter.

      -- Attribute: AUTO = 's'

      -- Attribute: TEXT = 't'

      -- Attribute: BINARY = 'b'

 -- Class: psycopg.adapt.AdaptersMap (template: AdaptersMap | None =
          None, types: TypesRegistry | None = None)

     Establish how types should be converted between Python and
     PostgreSQL in an *note AdaptContext: 174.

     ‘AdaptersMap’ maps Python types to *note Dumper: 5c. classes to
     define how Python types are converted to PostgreSQL, and maps OIDs
     to *note Loader: 5d. classes to establish how query results are
     converted to Python.

     Every ‘AdaptContext’ object has an underlying ‘AdaptersMap’
     defining how types are converted in that context, exposed as the
     *note adapters: 173. attribute: changing such map allows to
     customise adaptation in a context without changing separated
     contexts.

     When a context is created from another context (for instance when a
     *note Cursor: 36. is created from a *note Connection: 34.), the
     parent’s ‘adapters’ are used as template for the child’s
     ‘adapters’, so that every cursor created from the same connection
     use the connection’s types configuration, but separate connections
     have independent mappings.

     Once created, ‘AdaptersMap’ are independent.  This means that
     objects already created are not affected if a wider scope (e.g.
     the global one) is changed.

     The connections adapters are initialised using a global
     ‘AdptersMap’ template, exposed as *note psycopg.adapters: 175.:
     changing such mapping allows to customise the type mapping for
     every connections created afterwards.

     The object can start empty or copy from another object of the same
     class.  Copies are copy-on-write: if the maps are updated make a
     copy.  This way extending e.g.  global map by a connection or a
     connection map from a cursor is cheap: a copy is only made on
     customisation.

     See also
     ........

     *note Data adaptation configuration: 4e. for an explanation about
     how contexts are connected.

      -- Method: register_dumper (cls: type | str | None, dumper:
               type[Dumper]) -> None

          Configure the context to use ‘dumper’ to convert objects of
          type ‘cls’.

          If two dumpers with different *note format: 2ba. are
          registered for the same type, the last one registered will be
          chosen when the query doesn’t specify a format (i.e.  when the
          value is used with a ‘%s’ “*note AUTO: 185.” placeholder).


          Parameters:

             * ‘cls’ – The type to manage.

             * ‘dumper’ – The dumper to register for ‘cls’.

          If ‘cls’ is specified as string it will be lazy-loaded, so
          that it will be possible to register it without importing it
          before.  In this case it should be the fully qualified name of
          the object (e.g.  ‘"uuid.UUID"’).

          If ‘cls’ is None, only use the dumper when looking up using
          *note get_dumper_by_oid(): 2c4, which happens when we know the
          Postgres type to adapt to, but not the Python type that will
          be adapted (e.g.  in COPY after using *note set_types(): d0.).

      -- Method: register_loader (oid: int | str, loader: type[Loader])
               -> None

          Configure the context to use ‘loader’ to convert data of oid
          ‘oid’.


          Parameters:

             * ‘oid’ – The PostgreSQL OID or type name to manage.

             * ‘loader’ – The loar to register for ‘oid’.

          If ‘oid’ is specified as string, it refers to a type name,
          which is looked up in the *note types: 1b0. registry.

      -- Attribute: types

          The object where to look up for types information (such as the
          mapping between type names and oids in the specified context).


          Type: *note TypesRegistry: 17f.

      -- Method: get_dumper (cls: type, format: PyFormat) ->
               type[Dumper]

          Return the dumper class for the given type and format.

          Raise *note ProgrammingError: 1ae. if a class is not
          available.


          Parameters:

             * ‘cls’ – The class to adapt.

             * ‘format’ – The format to dump to.  If *note AUTO: 185,
               use the last one of the dumpers registered on ‘cls’.

      -- Method: get_dumper_by_oid (oid: int, format: Format) ->
               type[Dumper]

          Return the dumper class for the given oid and format.

          Raise *note ProgrammingError: 1ae. if a class is not
          available.


          Parameters:

             * ‘oid’ – The oid of the type to dump to.

             * ‘format’ – The format to dump to.

      -- Method: get_loader (oid: int, format: Format) -> type[Loader] |
               None

          Return the loader class for the given oid and format.

          Return ‘None’ if not found.


          Parameters:

             * ‘oid’ – The oid of the type to load.

             * ‘format’ – The format to load from.

 -- Class: psycopg.adapt.Transformer (context=None)

     An object that can adapt efficiently between Python and PostgreSQL.

     The life cycle of the object is the query, so it is assumed that
     attributes such as the server version or the connection encoding
     will not change.  The object have its state so adapting several
     values of the same type can be optimised.


     Parameters: ‘context’ (*note AdaptContext: 174.) – The context
     where the transformer should operate.


File: psycopg.info,  Node: types – Types information and adapters,  Next: abc – Psycopg abstract classes,  Prev: adapt – Types adaptation,  Up: Psycopg 3 API

1.3.12 ‘types’ – Types information and adapters
-----------------------------------------------

The ‘psycopg.types’ package exposes:

   - objects to describe PostgreSQL types, such as *note TypeInfo: 85,
     *note TypesRegistry: 17f, to help or *note customise the types
     conversion: 4e.;

   - concrete implementations of *note Loader: 178. and *note Dumper:
     177. protocols to *note handle builtin data types: 41.;

   - helper objects to represent PostgreSQL data types which *note don’t
     have a straightforward Python representation: 8a, such as *note
     Range: 92.

* Menu:

* Types information::
* JSON adapters::


File: psycopg.info,  Node: Types information,  Next: JSON adapters,  Up: types – Types information and adapters

1.3.12.1 Types information
..........................

The *note TypeInfo: 85. object describes simple information about a
PostgreSQL data type, such as its name, oid and array oid.  ‘TypeInfo’
subclasses may hold more information, for instance the components of a
composite type.

You can use *note TypeInfo.fetch(): 83. to query information from a
database catalog, which is then used by helper functions, such as *note
register_hstore(): a3, to register adapters on types whose OID is not
known upfront or to create more specialised adapters.

The ‘TypeInfo’ object doesn’t instruct Psycopg to convert a PostgreSQL
type into a Python type: this is the role of a *note Loader: 178.
However it can extend the behaviour of other adapters: if you create a
loader for ‘MyType’, using the *note TypeInfo: 85. information, Psycopg
will be able to manage seamlessly arrays of ‘MyType’ or ranges and
composite types using ‘MyType’ as a subtype.

See also
........

*note Data adaptation configuration: 4e. describes how to convert from
Python objects to PostgreSQL types and back.

     from psycopg.adapt import Loader
     from psycopg.types import TypeInfo

     t = TypeInfo.fetch(conn, "mytype")
     t.register(conn)

     for record in conn.execute("SELECT mytypearray FROM mytable"):
         # records will return lists of "mytype" as string

     class MyTypeLoader(Loader):
         def load(self, data):
             # parse the data and return a MyType instance

     conn.adapters.register_loader("mytype", MyTypeLoader)

     for record in conn.execute("SELECT mytypearray FROM mytable"):
         # records will return lists of MyType instances

 -- Class: psycopg.types.TypeInfo (name: str, oid: int, array_oid: int,
          *, regtype: str = '', delimiter: str = ', ', typemod:
          type[~psycopg._typemod.TypeModifier] = <class
          'psycopg._typemod.TypeModifier'>)

     Hold information about a PostgreSQL base type.

      -- Method: classmethod fetch (conn, name)

      -- Method: async classmethod fetch (aconn, name)

          Query a system catalog to read information about a type.


          Parameters:

             * ‘conn’ (*note Connection: 34.‘ or ’*note AsyncConnection:
               4a.) – the connection to query

             * ‘name’ (‘str’ or *note Identifier: 264.) – the name of
               the type to query.  It can include a schema name.


          Returns: a ‘TypeInfo’ object (or subclass) populated with the
          type information, ‘None’ if not found.

          If the connection is async, ‘fetch()’ will behave as a
          coroutine and the caller will need to ‘await’ on it to get the
          result:

               t = await TypeInfo.fetch(aconn, "mytype")

      -- Method: register (context: AdaptContext | None = None) -> None

          Register the type information, globally or in the specified
          ‘context’.


          Parameters: ‘context’ (‘Optional’‘[’*note AdaptContext:
          174.‘]’) – the context where the type is registered, for
          instance a *note Connection: 34. or *note Cursor: 36.  ‘None’
          registers the ‘TypeInfo’ globally.

          Registering the *note TypeInfo: 85. in a context allows the
          adapters of that context to look up type information: for
          instance it allows to recognise automatically arrays of that
          type and load them from the database as a list of the base
          type.

In order to get information about dynamic PostgreSQL types, Psycopg
offers a few ‘TypeInfo’ subclasses, whose ‘fetch()’ method can extract
more complete information about the type, such as *note CompositeInfo:
8d, *note RangeInfo: 9a, *note MultirangeInfo: 9f, *note EnumInfo: 81.

‘TypeInfo’ objects are collected in *note TypesRegistry: 17f. instances,
which help type information lookup.  Every *note AdaptersMap: 176.
exposes its type map on its *note types: 1b0. attribute.

 -- Class: psycopg.types.TypesRegistry (template: TypesRegistry | None =
          None)

     Container for the information about types in a database.

     ‘TypeRegistry’ instances are typically exposed by *note
     AdaptersMap: 176. objects in adapt contexts such as *note
     Connection: 34. or *note Cursor: 36. (e.g.  ‘conn.adapters.types’).

     The global registry, from which the others inherit from, is
     available as *note psycopg.adapters: 175.‘.types’.

      -- Method: __getitem__ (key: str | int) -> TypeInfo

      -- Method: __getitem__ (key: tuple[type[T], int]) -> T

          Return info about a type, specified by name or oid


          Parameters: ‘key’ – the name or oid of the type to look for.

          Raise KeyError if not found.

               >>> import psycopg

               >>> psycopg.adapters.types["text"]
               <TypeInfo: text (oid: 25, array oid: 1009)>

               >>> psycopg.adapters.types[23]
               <TypeInfo: int4 (oid: 23, array oid: 1007)>

      -- Method: get (key: str | int) -> TypeInfo | None

      -- Method: get (key: tuple[type[T], int]) -> T | None

          Return info about a type, specified by name or oid


          Parameters: ‘key’ – the name or oid of the type to look for.

          Unlike *note __getitem__: 2cc, return None if not found.

      -- Method: get_oid (name: str) -> int

          Return the oid of a PostgreSQL type by name.


          Parameters: ‘key’ – the name of the type to look for.

          Return the array oid if the type ends with “‘[]’”

          Raise KeyError if the name is unknown.

               >>> psycopg.adapters.types.get_oid("text[]")
               1009

      -- Method: get_by_subtype (cls: type[T], subtype: int | str) -> T
               | None

          Return info about a *note TypeInfo: 85. subclass by its
          element name or oid.


          Parameters:

             * ‘cls’ – the subtype of ‘TypeInfo’ to look for.  Currently
               supported are *note RangeInfo: 9a. and *note
               MultirangeInfo: 9f.

             * ‘subtype’ – The name or OID of the subtype of the element
               to look for.


          Returns: The ‘TypeInfo’ object of class ‘cls’ whose subtype is
          ‘subtype’.  ‘None’ if the element or its range are not found.


File: psycopg.info,  Node: JSON adapters,  Prev: Types information,  Up: types – Types information and adapters

1.3.12.2 JSON adapters
......................

See *note JSON adaptation: 73. for details.

 -- Class: psycopg.types.json.Json (obj: Any, dumps: Callable[[Any], str
          | bytes] | None = None)

 -- Class: psycopg.types.json.Jsonb (obj: Any, dumps: Callable[[Any],
          str | bytes] | None = None)

Wrappers to signal to convert ‘obj’ to a json or jsonb PostgreSQL value.

Any object supported by the underlying ‘dumps()’ function can be
wrapped.

If a ‘dumps’ function is passed to the wrapper, use it to dump the
wrapped object.  Otherwise use the function specified by *note
set_json_dumps(): 77.

 -- Function: psycopg.types.json.set_json_dumps (dumps: Callable[[Any],
          str | bytes], context: AdaptContext | None = None) -> None

     Set the JSON serialisation function to store JSON objects in the
     database.


     Parameters:

        * ‘dumps’ (‘Callable[[Any], str]’) – The dump function to use.

        * ‘context’ (*note Connection: 34. or *note Cursor: 36.) – Where
          to use the ‘dumps’ function.  If not specified, use it
          globally.

     By default dumping JSON uses the builtin json.dumps(1).  You can
     override it to use a different JSON library or to use customised
     arguments.

     If the *note Json: 75. wrapper specified a ‘dumps’ function, use it
     in precedence of the one set by this function.

 -- Function: psycopg.types.json.set_json_loads (loads: Callable[[str |
          bytes], Any], context: AdaptContext | None = None) -> None

     Set the JSON parsing function to fetch JSON objects from the
     database.


     Parameters:

        * ‘loads’ (‘Callable[[bytes], Any]’) – The load function to use.

        * ‘context’ (*note Connection: 34. or *note Cursor: 36.) – Where
          to use the ‘loads’ function.  If not specified, use it
          globally.

     By default loading JSON uses the builtin json.loads(2).  You can
     override it to use a different JSON library or to use customised
     arguments.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/json.html#json.dumps

   (2) https://docs.python.org/3/library/json.html#json.loads


File: psycopg.info,  Node: abc – Psycopg abstract classes,  Next: pq – libpq wrapper module,  Prev: types – Types information and adapters,  Up: Psycopg 3 API

1.3.13 ‘abc’ – Psycopg abstract classes
---------------------------------------

The module exposes Psycopg definitions which can be used for static type
checking.

 -- Class: psycopg.abc.Dumper (cls, context=None)

     Convert Python objects of type ‘cls’ to PostgreSQL representation.


     Parameters:

        * ‘cls’ (type(1)) – The type that will be managed by this
          dumper.

        * ‘context’ (*note AdaptContext: 174. or None) – The context
          where the transformation is performed.  If not specified the
          conversion might be inaccurate, for instance it will not be
          possible to know the connection encoding or the server date
          format.

     A partial implementation of this protocol (implementing everything
     except *note dump(): 17e.) is available as *note
     psycopg.adapt.Dumper: 5c.

      -- Attribute: format: *note Format: 18a.

          The format that this class *note dump(): 17e. method produces,
          *note TEXT: 5a. or *note BINARY: 5b.

          This is a class attribute.

      -- Method: dump (obj: Any) -> bytes | bytearray | memoryview |
               None

          Convert the object ‘obj’ to PostgreSQL representation.


          Parameters: ‘obj’ – the object to convert.

          The format returned by dump shouldn’t contain quotes or
          escaped values.

          Changed in version 3.2: ‘dump()’ can also return ‘None’, to
          represent a ‘NULL’ in the database.

      -- Method: quote (obj: Any) -> bytes | bytearray | memoryview

          Convert the object ‘obj’ to escaped representation.


          Parameters: ‘obj’ – the object to convert.

               Tip: This method will be used by *note Literal: 265. to
               convert a value client-side.

          This method only makes sense for text dumpers; the result of
          calling it on a binary dumper is undefined.  It might scratch
          your car, or burn your cake.  Don’t tell me I didn’t warn you.

      -- Attribute: oid: int(2)

          The oid to pass to the server, if known; 0 otherwise (class
          attribute).

          If the OID is not specified, PostgreSQL will try to infer the
          type from the context, but this may fail in some contexts and
          may require a cast (e.g.  specifying ‘%s::TYPE’ for its
          placeholder).

          You can use the *note psycopg.adapters: 175.‘.’*note types:
          1b0. registry to find the OID of builtin types, and you can
          use *note TypeInfo: 85. to extend the registry to custom
          types.

      -- Method: get_key (obj: Any, format: PyFormat) -> type |
               tuple[type | ForwardRef('tuple[DumperKey, ...]'), ...]

          Return an alternative key to upgrade the dumper to represent
          ‘obj’.


          Parameters:

             * ‘obj’ – The object to convert

             * ‘format’ – The format to convert to

          Normally the type of the object is all it takes to define how
          to dump the object to the database.  For instance, a Python
          date(3) can be simply converted into a PostgreSQL ‘date’.

          In a few cases, just the type is not enough.  For example:

             - A Python datetime(4) could be represented as a
               ‘timestamptz’ or a ‘timestamp’, according to whether it
               specifies a ‘tzinfo’ or not.

             - A Python int could be stored as several Postgres types:
               int2, int4, int8, numeric.  If a type too small is used,
               it may result in an overflow.  If a type too large is
               used, PostgreSQL may not want to cast it to a smaller
               type.

             - Python lists should be dumped according to the type they
               contain to convert them to e.g.  array of strings, array
               of ints (and which size of int?…)

          In these cases, a dumper can implement ‘get_key()’ and return
          a new class, or sequence of classes, that can be used to
          identify the same dumper again.  If the mechanism is not
          needed, the method should return the same ‘cls’ object passed
          in the constructor.

          If a dumper implements *note get_key(): 187. it should also
          implement *note upgrade(): 188.

      -- Method: upgrade (obj: Any, format: PyFormat) -> Dumper

          Return a new dumper to manage ‘obj’.


          Parameters:

             * ‘obj’ – The object to convert

             * ‘format’ – The format to convert to

          Once ‘Transformer.get_dumper()’ has been notified by *note
          get_key(): 187. that this Dumper class cannot handle ‘obj’
          itself, it will invoke ‘upgrade()’, which should return a new
          *note Dumper: 177. instance, which will be reused for every
          objects for which ‘get_key()’ returns the same result.

 -- Class: psycopg.abc.Loader (oid, context=None)

     Convert PostgreSQL values with type OID ‘oid’ to Python objects.


     Parameters:

        * ‘oid’ (int(5)) – The type that will be managed by this dumper.

        * ‘context’ (*note AdaptContext: 174. or None) – The context
          where the transformation is performed.  If not specified the
          conversion might be inaccurate, for instance it will not be
          possible to know the connection encoding or the server date
          format.

     A partial implementation of this protocol (implementing everything
     except *note load(): 17d.) is available as *note
     psycopg.adapt.Loader: 5d.

      -- Attribute: format: *note Format: 18a.

          The format that this class *note load(): 17d. method can
          convert, *note TEXT: 5a. or *note BINARY: 5b.

          This is a class attribute.

      -- Method: load (data: bytes | bytearray | memoryview) -> Any

          Convert the data returned by the database into a Python
          object.


          Parameters: ‘data’ – the data to convert.

 -- Class: psycopg.abc.AdaptContext (*args, **kwargs)

     A context describing how types are adapted.

     Example of *note AdaptContext: 174. are *note Connection: 34, *note
     Cursor: 36, *note Transformer: 17a, *note AdaptersMap: 176.

     Note that this is a Protocol(6), so objects implementing
     ‘AdaptContext’ don’t need to explicitly inherit from this class.

     See also
     ........

     *note Data adaptation configuration: 4e. for an explanation about
     how contexts are connected.

      -- Property: adapters: *note AdaptersMap: 176.

          The adapters configuration that this object uses.

      -- Property: connection: BaseConnection[Any] | None(7)

          The connection used by this object, if available.


          Return type: *note Connection: 34. or *note AsyncConnection:
          4a. or ‘None’

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#type

   (2) https://docs.python.org/3/library/functions.html#int

   (3) https://docs.python.org/3/library/datetime.html#datetime.date

   (4) https://docs.python.org/3/library/datetime.html#datetime.datetime

   (5) https://docs.python.org/3/library/functions.html#int

   (6) https://docs.python.org/3/library/typing.html#typing.Protocol

   (7) https://docs.python.org/3/library/constants.html#None


File: psycopg.info,  Node: pq – libpq wrapper module,  Next: crdb – CockroachDB support,  Prev: abc – Psycopg abstract classes,  Up: Psycopg 3 API

1.3.14 ‘pq’ – libpq wrapper module
----------------------------------

Psycopg is built around the libpq(1), the PostgreSQL client library,
which performs most of the network communications and returns query
results in C structures.

The low-level functions of the library are exposed by the objects in the
‘psycopg.pq’ module.

* Menu:

* pq module implementations::
* Module content::
* Objects wrapping libpq structures and functions::
* Enumerations::

   ---------- Footnotes ----------

   (1) https://www.postgresql.org/docs/current/libpq.html


File: psycopg.info,  Node: pq module implementations,  Next: Module content,  Up: pq – libpq wrapper module

1.3.14.1 ‘pq’ module implementations
....................................

There are actually several implementations of the module, all offering
the same interface.  Current implementations are:

   - ‘python’: a pure-python implementation, implemented using the
     ctypes(1) module.  It is less performing than the others, but it
     doesn’t need a C compiler to install.  It requires the libpq
     installed in the system.

   - ‘c’: a C implementation of the libpq wrapper (more precisely,
     implemented in Cython(2)).  It is much better performing than the
     ‘python’ implementation, however it requires development packages
     installed on the client machine.  It can be installed using the ‘c’
     extra, i.e.  running ‘pip install "psycopg[c]"’.

   - ‘binary’: a pre-compiled C implementation, bundled with all the
     required libraries.  It is the easiest option to deal with, fast to
     install and it should require no development tool or client
     library, however it may be not available for every platform.  You
     can install it using the ‘binary’ extra, i.e.  running ‘pip install
     "psycopg[binary]"’.

The implementation currently used is available in the *note __impl__:
2db. module constant.

At import time, Psycopg 3 will try to use the best implementation
available and will fail if none is usable.  You can force the use of a
specific implementation by exporting the env var ‘PSYCOPG_IMPL’:
importing the library will fail if the requested implementation is not
available:

     $ PSYCOPG_IMPL=c python -c "import psycopg"
     Traceback (most recent call last):
        ...
     ImportError: couldn't import requested psycopg 'c' implementation: No module named 'psycopg_c'

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/ctypes.html#module-ctypes

   (2) https://cython.org/


File: psycopg.info,  Node: Module content,  Next: Objects wrapping libpq structures and functions,  Prev: pq module implementations,  Up: pq – libpq wrapper module

1.3.14.2 Module content
.......................

 -- Data: psycopg.pq.__impl__: str(1) = 'python'

     The currently loaded implementation of the ‘psycopg.pq’ package.

     Possible values include ‘python’, ‘c’, ‘binary’.

     The choice of implementation is automatic but can be forced setting
     the ‘PSYCOPG_IMPL’ env var.

 -- Function: psycopg.pq.version () -> int

     Return the version number of the libpq currently loaded.

     The number is in the same format of *note server_version: 235.

     Certain features might not be available if the libpq library used
     is too old.

     See also
     ........

     the ‘PQlibVersion()(2)’ function

 -- Data: psycopg.pq.__build_version__: int(3) = 180000

     The libpq version the C package was built with.

     A number in the same format of *note server_version: 235.
     representing the libpq used to build the speedup module (‘c’,
     ‘binary’) if available.

     Certain features might not be available if the built version is too
     old.

 -- Function: psycopg.pq.error_message (obj: PGconn | PGresult |
          PGcancelConn, encoding: str = '') -> str

     Return an error message from a *note PGconn: 1c1, *note PGresult:
     189, *note PGcancelConn: 2de.

     The return value is a ‘str’ (unlike pq data which is usually
     ‘bytes’): use the connection encoding if available, otherwise the
     ‘encoding’ parameter as a fallback for decoding.  Don’t raise
     exceptions on decoding errors.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#str

   (2) 
https://www.postgresql.org/docs/17/libpq-misc.html#LIBPQ-PQLIBVERSION

   (3) https://docs.python.org/3/library/functions.html#int


File: psycopg.info,  Node: Objects wrapping libpq structures and functions,  Next: Enumerations,  Prev: Module content,  Up: pq – libpq wrapper module

1.3.14.3 Objects wrapping libpq structures and functions
........................................................

     TODO: finish documentation

 -- Class: psycopg.pq.PGconn

     Python representation of a libpq connection.

      -- Attribute: pgconn_ptr

          The pointer to the underlying ‘PGconn’ structure, as integer.

          ‘None’ if the connection is closed.

          The value can be used to pass the structure to libpq functions
          which psycopg doesn’t (currently) wrap, either in C or in
          Python using FFI libraries such as ctypes(1).

      -- Method: cancel_conn () -> PGcancelConn

          Create a connection over which a cancel request can be sent.

          See ‘PQcancelCreate(2)’ for details.

      -- Method: get_cancel () -> PGcancel

          Create an object with the information needed to cancel a
          command.

          See ‘PQgetCancel(3)’ for details.

      -- Attribute: needs_password

          True if the connection authentication method required a
          password, but none was available.

          See ‘PQconnectionNeedsPassword(4)’ for details.

      -- Attribute: used_password

          True if the connection authentication method used a password.

          See ‘PQconnectionUsedPassword(5)’ for details.

      -- Method: encrypt_password (passwd: bytes, user: bytes,
               algorithm: bytes | None = None) -> bytes

          Return the encrypted form of a PostgreSQL password.

          See ‘PQencryptPasswordConn(6)’ for details.

               >>> enc = conn.info.encoding
               >>> encrypted = conn.pgconn.encrypt_password(password.encode(enc), rolename.encode(enc))
               b'SCRAM-SHA-256$4096:...

      -- Method: change_password (user: bytes, passwd: bytes) -> None

          Change a PostgreSQL password.


          Raises: *note OperationalError: 1ab. – if the command to
          change password failed.

          See ‘PQchangePassword(7)’ for details.

      -- Method: trace (fileno: int) -> None

          Enable tracing of the client/server communication to a file
          stream.

          See ‘PQtrace(8)’ for details.

      -- Method: set_trace_flags (flags: Trace) -> None

          Configure tracing behavior of client/server communication.


          Parameters: ‘flags’ – operating mode of tracing.

          See ‘PQsetTraceFlags(9)’ for details.

      -- Method: untrace () -> None

          Disable tracing, previously enabled through *note trace():
          2e5.

          See ‘PQuntrace(10)’ for details.

          >>> conn.pgconn.trace(sys.stderr.fileno())
          >>> conn.pgconn.set_trace_flags(pq.Trace.SUPPRESS_TIMESTAMPS | pq.Trace.REGRESS_MODE)
          >>> conn.execute("select now()")
          F       13      Parse    "" "BEGIN" 0
          F       14      Bind     "" "" 0 0 1 0
          F       6       Describe         P ""
          F       9       Execute  "" 0
          F       4       Sync
          B       4       ParseComplete
          B       4       BindComplete
          B       4       NoData
          B       10      CommandComplete  "BEGIN"
          B       5       ReadyForQuery    T
          F       17      Query    "select now()"
          B       28      RowDescription   1 "now" NNNN 0 NNNN 8 -1 0
          B       39      DataRow  1 29 '2022-09-14 14:12:16.648035+02'
          B       13      CommandComplete  "SELECT 1"
          B       5       ReadyForQuery    T
          <psycopg.Cursor [TUPLES_OK] [INTRANS] (database=postgres) at 0x7f18a18ba040>
          >>> conn.pgconn.untrace()

 -- Class: psycopg.pq.PGresult

     Python representation of a libpq result.

      -- Attribute: pgresult_ptr

          The pointer to the underlying ‘PGresult’ structure, as
          integer.

          ‘None’ if the result was cleared.

          The value can be used to pass the structure to libpq functions
          which psycopg doesn’t (currently) wrap, either in C or in
          Python using FFI libraries such as ctypes(11).

 -- Class: psycopg.pq.Conninfo

     Utility object to manipulate connection strings.

 -- Class: psycopg.pq.Escaping (conn: PGconn | None = None)

     Utility object to escape strings for SQL interpolation.

 -- Class: psycopg.pq.PGcancelConn

     Token to handle non-blocking cancellation requests.

     Created by *note PGconn.cancel_conn(): 2e1.

      -- Method: start () -> None

          Requests that the server abandons processing of the current
          command in a non-blocking manner.

          See ‘PQcancelStart(12)’ for details.

      -- Method: blocking () -> None

          Requests that the server abandons processing of the current
          command in a blocking manner.

          See ‘PQcancelBlocking(13)’ for details.

      -- Method: finish (_PGcancelConn__PQcancelFinish: ~typing.Any =
               <_FuncPtr object>) -> None

          Free the data structure created by ‘PQcancelCreate()’.

          Automatically invoked by ‘__del__()’.

          See ‘PQcancelFinish()(14)’ for details.

 -- Class: psycopg.pq.PGcancel

     Token to cancel the current operation on a connection.

     Created by *note PGconn.get_cancel(): 2e2.

      -- Method: free (_PGcancel__PQfreeCancel: ~typing.Any = <_FuncPtr
               object>) -> None

          Free the data structure created by ‘PQgetCancel()(15)’.

          Automatically invoked by ‘__del__()’.

          See ‘PQfreeCancel()(16)’ for details.

      -- Method: cancel () -> None

          Requests that the server abandon processing of the current
          command.

          See ‘PQcancel()(17)’ for details.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/ctypes.html#module-ctypes

   (2) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCELCREATE

   (3) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQGETCANCEL

   (4) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQCONNECTIONNEEDSPASSWORD

   (5) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQCONNECTIONUSEDPASSWORD

   (6) 
https://www.postgresql.org/docs/17/libpq-misc.html#LIBPQ-PQENCRYPTPASSWORDCONN

   (7) 
https://www.postgresql.org/docs/17/libpq-misc.html#LIBPQ-PQCHANGEPASSWORD

   (8) 
https://www.postgresql.org/docs/17/libpq-control.html#LIBPQ-PQTRACE

   (9) 
https://www.postgresql.org/docs/17/libpq-control.html#LIBPQ-PQSETTRACEFLAGS

   (10) 
https://www.postgresql.org/docs/17/libpq-control.html#LIBPQ-PQUNTRACE

   (11) https://docs.python.org/3/library/ctypes.html#module-ctypes

   (12) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCELSTART

   (13) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCELBLOCKING

   (14) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCELFINISH

   (15) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQGETCANCEL

   (16) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQFREECANCEL

   (17) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCEL


File: psycopg.info,  Node: Enumerations,  Prev: Objects wrapping libpq structures and functions,  Up: pq – libpq wrapper module

1.3.14.4 Enumerations
.....................

 -- Class: psycopg.pq.ConnStatus (*values)

     Current status of the connection.

     There are other values in this enum, but only *note OK: 22d. and
     *note BAD: 22e. are seen after a connection has been established.
     Other statuses might only be seen during the connection phase and
     are considered internal.  ‘ALLOCATED’ is only expected to be
     returned by ‘PGcancelConn.status’.

     See also
     ........

     ‘PQstatus()(1)’ and ‘PQcancelStatus()(2)’ return this value.

      -- Attribute: OK = 0

      -- Attribute: BAD = 1

 -- Class: psycopg.pq.PollingStatus (*values)

     The status of the socket during a connection.

     If ‘READING’ or ‘WRITING’ you may select before polling again.

     See also
     ........

     ‘PQconnectPoll(3)’ for a description of these states.

      -- Attribute: FAILED = 0

      -- Attribute: READING = 1

      -- Attribute: WRITING = 2

      -- Attribute: OK = 3

 -- Class: psycopg.pq.TransactionStatus (*values)

     The transaction status of a connection.

     See also
     ........

     ‘PQtransactionStatus(4)’ for a description of these states.

      -- Attribute: IDLE = 0

      -- Attribute: ACTIVE = 1

      -- Attribute: INTRANS = 2

      -- Attribute: INERROR = 3

      -- Attribute: UNKNOWN = 4

 -- Class: psycopg.pq.ExecStatus (*values)

     The status of a command.

     See also
     ........

     ‘PQresultStatus(5)’ for a description of these states.

      -- Attribute: EMPTY_QUERY = 0

      -- Attribute: COMMAND_OK = 1

      -- Attribute: TUPLES_OK = 2

      -- Attribute: COPY_OUT = 3

      -- Attribute: COPY_IN = 4

      -- Attribute: BAD_RESPONSE = 5

      -- Attribute: NONFATAL_ERROR = 6

      -- Attribute: FATAL_ERROR = 7

      -- Attribute: COPY_BOTH = 8

      -- Attribute: SINGLE_TUPLE = 9

      -- Attribute: PIPELINE_SYNC = 10

      -- Attribute: PIPELINE_ABORTED = 11

      -- Attribute: TUPLES_CHUNK = 12

 -- Class: psycopg.pq.PipelineStatus (*values)

     Pipeline mode status of the libpq connection.

     See also
     ........

     ‘PQpipelineStatus(6)’ for a description of these states.

      -- Attribute: OFF = 0

      -- Attribute: ON = 1

      -- Attribute: ABORTED = 2

 -- Class: psycopg.pq.Format (*values)

     Enum representing the format of a query argument or return value.

     These values are only the ones managed by the libpq.  *note
     psycopg: 0. may also support automatically-chosen values: see *note
     psycopg.adapt.PyFormat: 2c1.

      -- Attribute: TEXT = 0

      -- Attribute: BINARY = 1

 -- Class: psycopg.pq.DiagnosticField (*values)

     Fields in an error report.

     Available attributes:

      -- Attribute: SEVERITY
      -- Attribute: SEVERITY_NONLOCALIZED
      -- Attribute: SQLSTATE
      -- Attribute: MESSAGE_PRIMARY
      -- Attribute: MESSAGE_DETAIL
      -- Attribute: MESSAGE_HINT
      -- Attribute: STATEMENT_POSITION
      -- Attribute: INTERNAL_POSITION
      -- Attribute: INTERNAL_QUERY
      -- Attribute: CONTEXT
      -- Attribute: SCHEMA_NAME
      -- Attribute: TABLE_NAME
      -- Attribute: COLUMN_NAME
      -- Attribute: DATATYPE_NAME
      -- Attribute: CONSTRAINT_NAME
      -- Attribute: SOURCE_FILE
      -- Attribute: SOURCE_LINE
      -- Attribute: SOURCE_FUNCTION

     See also
     ........

     ‘PQresultErrorField(7)’ for a description of these values.

 -- Class: psycopg.pq.Ping (*values)

     Response from a ping attempt.

     See also
     ........

     ‘PQpingParams(8)’ for a description of these values.

      -- Attribute: OK = 0

      -- Attribute: REJECT = 1

      -- Attribute: NO_RESPONSE = 2

      -- Attribute: NO_ATTEMPT = 3

 -- Class: psycopg.pq.Trace (*values)

     Enum to control tracing of the client/server communication.

     See also
     ........

     ‘PQsetTraceFlags(9)’ for a description of these values.

      -- Attribute: SUPPRESS_TIMESTAMPS = 1

      -- Attribute: REGRESS_MODE = 2

   ---------- Footnotes ----------

   (1) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQSTATUS

   (2) 
https://www.postgresql.org/docs/17/libpq-cancel.html#LIBPQ-PQCANCELSTATUS

   (3) 
https://www.postgresql.org/docs/17/libpq-connect.html#LIBPQ-PQCONNECTSTARTPARAMS

   (4) 
https://www.postgresql.org/docs/17/libpq-status.html#LIBPQ-PQTRANSACTIONSTATUS

   (5) 
https://www.postgresql.org/docs/17/libpq-exec.html#LIBPQ-PQRESULTSTATUS

   (6) 
https://www.postgresql.org/docs/17/libpq-pipeline-mode.html#LIBPQ-PQPIPELINESTATUS

   (7) 
https://www.postgresql.org/docs/17/libpq-exec.html#LIBPQ-PQRESULTERRORFIELD

   (8) 
https://www.postgresql.org/docs/17/libpq-connect.html#LIBPQ-PQPINGPARAMS

   (9) 
https://www.postgresql.org/docs/17/libpq-control.html#LIBPQ-PQSETTRACEFLAGS


File: psycopg.info,  Node: crdb – CockroachDB support,  Next: _dns – DNS resolution utilities,  Prev: pq – libpq wrapper module,  Up: Psycopg 3 API

1.3.15 ‘crdb’ – CockroachDB support
-----------------------------------

Added in version 3.1.

CockroachDB(1) is a distributed database using the same fronted-backend
protocol of PostgreSQL. As such, Psycopg can be used to write Python
programs interacting with CockroachDB.

Opening a connection to a CRDB database using *note psycopg.connect():
48. provides a largely working object.  However, using the *note
psycopg.crdb.connect(): 327. function instead, Psycopg will create more
specialised objects and provide a types mapping tweaked on the
CockroachDB data model.

* Menu:

* Main differences from PostgreSQL::
* CockroachDB-specific objects::

   ---------- Footnotes ----------

   (1) https://www.cockroachlabs.com/


File: psycopg.info,  Node: Main differences from PostgreSQL,  Next: CockroachDB-specific objects,  Up: crdb – CockroachDB support

1.3.15.1 Main differences from PostgreSQL
.........................................

CockroachDB behaviour is different from PostgreSQL(1): please refer to
the database documentation for details.  These are some of the main
differences affecting Psycopg behaviour:

   - *note cancel(): 10d. doesn’t work before CockroachDB 22.1.  On
     older versions, you can use CANCEL QUERY(2) instead (but from a
     different connection).

   - *note Server-side cursors: 160. are well supported only from
     CockroachDB 22.1.3.

   - *note backend_pid: 233. is only populated from CockroachDB 22.1.
     Note however that you cannot use the PID to terminate the session;
     use SHOW session_id(3) to find the id of a session, which you may
     terminate with CANCEL SESSION(4) in lieu of PostgreSQL’s
     ‘pg_terminate_backend()’.

   - Several data types are missing or slightly different from
     PostgreSQL (see *note adapters: 32a. for an overview of the
     differences).

   - The *note two-phase commit protocol: bb. is not supported.

   - ‘LISTEN’ and ‘NOTIFY’ are not supported.  However the CHANGEFEED(5)
     command, in conjunction with *note stream(): 19b, can provide push
     notifications.

   ---------- Footnotes ----------

   (1) 
https://www.cockroachlabs.com/docs/stable/postgresql-compatibility.html

   (2) https://www.cockroachlabs.com/docs/stable/cancel-query.html

   (3) https://www.cockroachlabs.com/docs/stable/show-vars.html

   (4) https://www.cockroachlabs.com/docs/stable/cancel-session.html

   (5) https://www.cockroachlabs.com/docs/stable/changefeed-for.html


File: psycopg.info,  Node: CockroachDB-specific objects,  Prev: Main differences from PostgreSQL,  Up: crdb – CockroachDB support

1.3.15.2 CockroachDB-specific objects
.....................................

 -- Function: psycopg.crdb.connect (conninfo: str = '', *, autocommit:
          bool = False, prepare_threshold: int | None = 5, context:
          AdaptContext | None = None, row_factory: RowFactory[Row] |
          None = None, cursor_factory: type[Cursor[Row]] | None = None,
          **kwargs: str | int | None) -> Self

     Connect to a database server and return a new ‘Connection’
     instance.

     This is an alias of the class method ‘CrdbConnection.connect’.

     If you need an asynchronous connection use the
     ‘AsyncCrdbConnection.connect()’ method instead.

 -- Class: psycopg.crdb.CrdbConnection (pgconn: PGconn, row_factory:
          RowFactory[Row] = <function tuple_row>)

     Wrapper for a connection to a CockroachDB database.

     *note psycopg.Connection: 34. subclass.

      -- Method: classmethod is_crdb (conn: Connection[Any] |
               AsyncConnection[Any] | PGconn) -> bool

          Return ‘True’ if the server connected to ‘conn’ is
          CockroachDB.


          Parameters: ‘conn’ (*note Connection: 34, *note
          AsyncConnection: 4a, *note PGconn: 1c1.) – the connection to
          check

 -- Class: psycopg.crdb.AsyncCrdbConnection (pgconn: PGconn,
          row_factory: AsyncRowFactory[Row] = <function tuple_row>)

     Wrapper for an async connection to a CockroachDB database.

     *note psycopg.AsyncConnection: 4a. subclass.

 -- Class: psycopg.crdb.CrdbConnectionInfo (pgconn: PGconn)

     *note ConnectionInfo: 1c3. subclass to get info about a CockroachDB
     database.

     The object is returned by the *note info: 1c2. attribute of *note
     CrdbConnection: 32d. and *note AsyncCrdbConnection: 32f.

     The object behaves like ‘ConnectionInfo’, with the following
     differences:

      -- Attribute: vendor

          The ‘CockroachDB’ string.

      -- Attribute: server_version

          Return the CockroachDB server version connected.

          Return a number in the PostgreSQL format (e.g.  21.2.10 ->
          210210).

 -- Data: psycopg.crdb.adapters

     The default adapters map establishing how Python and CockroachDB
     types are converted into each other.

     The map is used as a template when new connections are created,
     using *note psycopg.crdb.connect(): 327. (similarly to the way
     *note psycopg.adapters: 175. is used as template for new PostgreSQL
     connections).

     This registry contains only the types and adapters supported by
     CockroachDB. Several PostgreSQL types and adapters are missing or
     different from PostgreSQL, among which:

        - Composite types

        - ‘range’, ‘multirange’ types

        - The ‘hstore’ type

        - Geometric types

        - Nested arrays

        - Arrays of ‘jsonb’

        - The ‘cidr’ data type

        - The ‘json’ type is an alias for ‘jsonb’

        - The ‘int’ type is an alias for ‘int8’, not ‘int4’.


File: psycopg.info,  Node: _dns – DNS resolution utilities,  Prev: crdb – CockroachDB support,  Up: Psycopg 3 API

1.3.16 ‘_dns’ – DNS resolution utilities
----------------------------------------

This module contains a few experimental utilities to interact with the
DNS server before performing a connection.

     Warning: This module is experimental and its interface could change
     in the future, without warning or respect for the version scheme.
     It is provided here to allow experimentation before making it more
     stable.

     Warning: This module depends on the dnspython(1) package.  The
     package is currently not installed automatically as a Psycopg
     dependency and must be installed manually:

          $ pip install "dnspython >= 2.1"

 -- Function: psycopg._dns.resolve_srv (params)

     Apply SRV DNS lookup as defined in RFC 2782(2).


     Parameters: ‘params’ (‘dict’) – The input parameters, for instance
     as returned by *note conninfo_to_dict(): 2b3.


     Returns: An updated list of connection parameters.

     For every host defined in the ‘params["host"]’ list
     (comma-separated), perform SRV lookup if the host is in the form
     ‘_Service._Proto.Target’.  If lookup is successful, return a params
     dict with hosts and ports replaced with the looked-up entries.

     Raise *note OperationalError: 1ab. if no lookup is successful and
     no host (looked up or unchanged) could be returned.

     In addition to the rules defined by RFC 2782 about the host name
     pattern, perform SRV lookup also if the the port is the string
     ‘SRV’ (case insensitive).

          Warning: This is an experimental functionality.

          Note: One possible way to use this function automatically is
          to subclass *note Connection: 34, extending the *note
          _get_connection_params(): 336. method:

               import psycopg._dns  # not imported automatically

               class SrvCognizantConnection(psycopg.Connection):
                   @classmethod
                   def _get_connection_params(cls, conninfo, **kwargs):
                       params = super()._get_connection_params(conninfo, **kwargs)
                       params = psycopg._dns.resolve_srv(params)
                       return params

               # The name will be resolved to db1.example.com
               cnn = SrvCognizantConnection.connect("host=_postgres._tcp.db.psycopg.org")

 -- Function: async psycopg._dns.resolve_srv_async (params)

     Async equivalent of *note resolve_srv(): 335.

 -- Method: classmethod Connection._get_connection_params (conninfo:
          str, **kwargs: Any) -> Dict[str, str | int | None]

     Manipulate connection parameters before connecting.

          Warning: This is an experimental method.

     This method is a subclass hook allowing to manipulate the
     connection parameters before performing the connection.  Make sure
     to call the ‘super()’ implementation before further manipulation of
     the arguments:

          @classmethod
          def _get_connection_params(cls, conninfo, **kwargs):
              params = super()._get_connection_params(conninfo, **kwargs)
              # do something with the params
              return params

 -- Method: async classmethod AsyncConnection._get_connection_params
          (conninfo: str, **kwargs: Any) -> Dict[str, str | int | None]

     Manipulate connection parameters before connecting.

          Warning: This is an experimental method.

 -- Function: async psycopg._dns.resolve_hostaddr_async (params)

     Perform async DNS lookup of the hosts and return a new params dict.

     Deprecated since version 3.1: The use of this function is not
     necessary anymore, because *note psycopg.AsyncConnection.connect():
     35. performs non-blocking name resolution automatically.


     Parameters: ‘params’ (‘dict’) – The input parameters, for instance
     as returned by *note conninfo_to_dict(): 2b3.

     If a ‘host’ param is present but not ‘hostname’, resolve the host
     addresses dynamically.

     The function may change the input ‘host’, ‘hostname’, ‘port’ to
     allow connecting without further DNS lookups, eventually removing
     hosts that are not resolved, keeping the lists of hosts and ports
     consistent.

     Raise *note OperationalError: 1ab. if connection is not possible
     (e.g.  no host resolve, inconsistent lists length).

     See the PostgreSQL docs(3) for explanation of how these params are
     used, and how they support multiple entries.

          Warning: Before psycopg 3.1, this function doesn’t handle the
          ‘/etc/hosts’ file.

          Note: Starting from psycopg 3.1, a similar operation is
          performed automatically by
          ‘AsyncConnection._get_connection_params()’, so this function
          is unneeded.

          In psycopg 3.0, one possible way to use this function
          automatically is to subclass *note AsyncConnection: 4a,
          extending the *note _get_connection_params(): 338. method:

               import psycopg._dns  # not imported automatically

               class AsyncDnsConnection(psycopg.AsyncConnection):
                   @classmethod
                   async def _get_connection_params(cls, conninfo, **kwargs):
                       params = await super()._get_connection_params(conninfo, **kwargs)
                       params = await psycopg._dns.resolve_hostaddr_async(params)
                       return params

   ---------- Footnotes ----------

   (1) https://dnspython.readthedocs.io/

   (2) https://datatracker.ietf.org/doc/html/rfc2782.html

   (3) 
https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS


File: psycopg.info,  Node: Release notes,  Next: Indices and tables,  Prev: Psycopg 3 API,  Up: Documentation

1.4 Release notes
=================

* Menu:

* psycopg release notes::
* psycopg_pool release notes::


File: psycopg.info,  Node: psycopg release notes,  Next: psycopg_pool release notes,  Up: Release notes

1.4.1 ‘psycopg’ release notes
-----------------------------

* Menu:

* Current release::
* Psycopg 3.2: Psycopg 3 2.
* Psycopg 3.1: Psycopg 3 1.
* Psycopg 3.0: Psycopg 3 0.


File: psycopg.info,  Node: Current release,  Next: Psycopg 3 2,  Up: psycopg release notes

1.4.1.1 Current release
.......................

* Menu:

* Psycopg 3.2.12: Psycopg 3 2 12.
* Psycopg 3.2.11: Psycopg 3 2 11.
* Psycopg 3.2.10: Psycopg 3 2 10.
* Psycopg 3.2.9: Psycopg 3 2 9.
* Psycopg 3.2.8: Psycopg 3 2 8.
* Psycopg 3.2.7: Psycopg 3 2 7.
* Psycopg 3.2.6: Psycopg 3 2 6.
* Psycopg 3.2.5: Psycopg 3 2 5.
* Psycopg 3.2.4: Psycopg 3 2 4.
* Psycopg 3.2.3: Psycopg 3 2 3.
* Psycopg 3.2.2: Psycopg 3 2 2.
* Psycopg 3.2.1: Psycopg 3 2 1.


File: psycopg.info,  Node: Psycopg 3 2 12,  Next: Psycopg 3 2 11,  Up: Current release

1.4.1.2 Psycopg 3.2.12
......................

   - Allow copy to pass different types per column, as long as the
     database can convert them.  Regression introduced in 3.2.11 (ticket
     #1192(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1192


File: psycopg.info,  Node: Psycopg 3 2 11,  Next: Psycopg 3 2 10,  Prev: Psycopg 3 2 12,  Up: Current release

1.4.1.3 Psycopg 3.2.11
......................

   - Fix spurious readiness flags in some of the wait functions (ticket
     #1141(1)).

   - Fix high CPU usage using the ‘wait_c’ function on Windows (ticket
     #645(2)).

   - Fix bad data on error in binary copy (ticket #1147(3)).

   - Respect *note Copy.set_types(): d0. in TEXT copy in C version,
     consistently with the Python version (ticket #1153(4)).

   - Don’t raise warning, and don’t leak resources, if a builtin
     function is used as JSON dumper/loader function (ticket #1165(5)).

   - Improve performance of Python conversion on results loading (ticket
     #1155(6)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1141

   (2) https://github.com/psycopg/psycopg/issues/645

   (3) https://github.com/psycopg/psycopg/issues/1147

   (4) https://github.com/psycopg/psycopg/issues/1153

   (5) https://github.com/psycopg/psycopg/issues/1165

   (6) https://github.com/psycopg/psycopg/issues/1155


File: psycopg.info,  Node: Psycopg 3 2 10,  Next: Psycopg 3 2 9,  Prev: Psycopg 3 2 11,  Up: Current release

1.4.1.4 Psycopg 3.2.10
......................

   - Fix ‘TypeError’ shadowing CancelledError(1) upon task cancellation
     during pipeline execution (ticket #1005(2)).

   - Fix memory leak when lambda/local functions are used as argument
     for *note set_json_dumps(): 77, *note set_json_loads(): 78. (ticket
     #1108(3)).

   - Fix coordination of *note executemany(): 3b. with other concurrent
     operations on other cursors (ticket #1130(4)).

   - Fix leak receiving notifications if the *note notifies(): 11c.
     generator is not called (ticket #1091(5)).

          Warning: This bugfix required the introduction of a change in
          *note notifies reception: 116. behaviour.

          If a notification is received when a handler is registered via
          *note add_notify_handler(): 120. and the *note notifies():
          11c. generator is not running the notification will not be
          yielded by the generator.  This is a behaviour similar to
          before *note Psycopg 3.2.4: 340, but 'notifications are not
          lost if no handler is registered'.

          Using both the generator and handlers to receive notifications
          on the same connection is therefore deprecated and will now
          generate a runtime warning.

   - Add support for Python 3.14 (ticket #1053(6)).

   - Fix ‘psycopg_binary.__version__’.

   - Raise a warning if a GSSAPI connection is obtained using the
     ‘gssencmode=prefer’ libpq default (see ticket #1136(7)).

          Warning: In a future Psycopg version the default in the binary
          package will be changed to ‘disable’.  If you need to interact
          with the GSSAPI reliably you should explicitly set the
          ‘gssencmode’ parameter in the connection string or the
          ‘PGGSSENCMODE’ environment variable to ‘prefer’ or ‘require’.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/asyncio-exceptions.html#asyncio.CancelledError

   (2) https://github.com/psycopg/psycopg/issues/1005

   (3) https://github.com/psycopg/psycopg/issues/1108

   (4) https://github.com/psycopg/psycopg/issues/1130

   (5) https://github.com/psycopg/psycopg/issues/1091

   (6) https://github.com/psycopg/psycopg/issues/1053

   (7) https://github.com/psycopg/psycopg/issues/1136


File: psycopg.info,  Node: Psycopg 3 2 9,  Next: Psycopg 3 2 8,  Prev: Psycopg 3 2 10,  Up: Current release

1.4.1.5 Psycopg 3.2.9
.....................

   - Revert the libpq included in the binary packages from conda forge
     to vcpkg because GSS connection crashes (ticket #1088(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1088


File: psycopg.info,  Node: Psycopg 3 2 8,  Next: Psycopg 3 2 7,  Prev: Psycopg 3 2 9,  Up: Current release

1.4.1.6 Psycopg 3.2.8
.....................

   - Fix ‘DateFromTicks’ and ‘TimeFromTicks’ return values to return a
     date and a time referred to the UTC timezone rather than to the
     local timezone.  For consistency, ‘TimestampFromTicks’ to return a
     datetime in UTC rather than in the local timezone (ticket
     #1058(1)).

   - Fix *note rownumber: 1f1. after using *note scroll(): 210. on *note
     AsyncServerCursor: 169. (ticket #1066(2)).

   - Fix interval parsing with days or other parts and negative time in
     C module (ticket #1071(3)).

   - Don’t process further connection attempts after Ctrl-C (ticket
     #1077(4)).

   - Fix cursors to correctly iterate over rows even if their row
     factory returns None(5) (ticket #1073(6)).

   - Fix *note ConnectionInfo.port: 23a. when the port is specified as
     an empty string (ticket #1078(7)).

   - Report all the attempts error messages in the exception raised for
     a connection failure (ticket #1069(8)).

   - Improve logging on connection (ticket #1085(9)).

   - Add support for PostgreSQL 18 libpq (ticket #1082(10)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1058

   (2) https://github.com/psycopg/psycopg/issues/1066

   (3) https://github.com/psycopg/psycopg/issues/1071

   (4) https://github.com/psycopg/psycopg/issues/1077

   (5) https://docs.python.org/3/library/constants.html#None

   (6) https://github.com/psycopg/psycopg/issues/1073

   (7) https://github.com/psycopg/psycopg/issues/1078

   (8) https://github.com/psycopg/psycopg/issues/1069

   (9) https://github.com/psycopg/psycopg/issues/1085

   (10) https://github.com/psycopg/psycopg/issues/1082


File: psycopg.info,  Node: Psycopg 3 2 7,  Next: Psycopg 3 2 6,  Prev: Psycopg 3 2 8,  Up: Current release

1.4.1.7 Psycopg 3.2.7
.....................

   - Add SRID support to shapely dumpers/loaders (ticket #1028(1)).

   - Add support for binary hstore (ticket #1030(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1028

   (2) https://github.com/psycopg/psycopg/issues/1030


File: psycopg.info,  Node: Psycopg 3 2 6,  Next: Psycopg 3 2 5,  Prev: Psycopg 3 2 7,  Up: Current release

1.4.1.8 Psycopg 3.2.6
.....................

   - Fix connection semantic when using
     ‘target_session_attrs=prefer-standby’ (ticket #1021(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1021


File: psycopg.info,  Node: Psycopg 3 2 5,  Next: Psycopg 3 2 4,  Prev: Psycopg 3 2 6,  Up: Current release

1.4.1.9 Psycopg 3.2.5
.....................

   - 3x faster UUID loading thanks to C implementation (tickets #447(1),
     #998(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/447

   (2) https://github.com/psycopg/psycopg/issues/998


File: psycopg.info,  Node: Psycopg 3 2 4,  Next: Psycopg 3 2 3,  Prev: Psycopg 3 2 5,  Up: Current release

1.4.1.10 Psycopg 3.2.4
......................

   - Don’t lose notifies received whilst the *note notifies(): 11c.
     iterator is not running (ticket #962(1)).

          Warning: If you were using notifications to bridge the time
          between issuing a LISTEN on a channel and starting the
          iterator you might receive duplicate notifications.

   - Make sure that the notifies callback is called during the use of
     the *note notifies(): 11c. generator (ticket #972(2)).

   - Raise the correct error returned by the database (such as
     ‘AdminShutdown’ or ‘IdleInTransactionSessionTimeout’) instead of a
     generic *note OperationalError: 1ab. when a server error causes a
     client disconnection (ticket #988(3)).

   - Build macOS dependencies from sources instead using the Homebrew
     versions in order to avoid problems with ‘MACOSX_DEPLOYMENT_TARGET’
     (ticket #858(4)).

   - Bump libpq to 17.2 in Linux and macOS binary packages.

   - Bump libpq to 16.4 in Windows binary packages, using the vcpkg
     library(5) (ticket #966(6)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/962

   (2) https://github.com/psycopg/psycopg/issues/972

   (3) https://github.com/psycopg/psycopg/issues/988

   (4) https://github.com/psycopg/psycopg/issues/858

   (5) https://vcpkg.io/en/package/libpq

   (6) https://github.com/psycopg/psycopg/issues/966


File: psycopg.info,  Node: Psycopg 3 2 3,  Next: Psycopg 3 2 2,  Prev: Psycopg 3 2 4,  Up: Current release

1.4.1.11 Psycopg 3.2.3
......................

   - Release binary packages including PostgreSQL 17 libpq (ticket
     #852(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/852


File: psycopg.info,  Node: Psycopg 3 2 2,  Next: Psycopg 3 2 1,  Prev: Psycopg 3 2 3,  Up: Current release

1.4.1.12 Psycopg 3.2.2
......................

   - Drop ‘TypeDef’ specifications as string from public modules, as
     they cannot be composed by users as ‘typing’ objects previously
     could (ticket #860(1)).

   - Release Python 3.13 binary packages.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/860


File: psycopg.info,  Node: Psycopg 3 2 1,  Prev: Psycopg 3 2 2,  Up: Current release

1.4.1.13 Psycopg 3.2.1
......................

   - Fix packaging metadata breaking ‘[c]’, ‘[binary]’ dependencies
     (ticket #853(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/853


File: psycopg.info,  Node: Psycopg 3 2,  Next: Psycopg 3 1,  Prev: Current release,  Up: psycopg release notes

1.4.1.14 Psycopg 3.2
....................

New top-level features
......................

   - Add support for integer, floating point, boolean NumPy scalar
     types(1) (ticket #332(2)).

   - Add ‘timeout’ and ‘stop_after’ parameters to *note
     Connection.notifies(): 11c. (ticket 340(3)).

   - Allow dumpers to return ‘None’, to be converted to NULL (ticket
     #377(4)).

   - Add *note Raw query cursors: 162. to execute queries using
     placeholders in PostgreSQL format (‘$1’, ‘$2’…) (tickets #560(5),
     #839(6)).

   - Add *note capabilities: 1a5. object to *note inspect the libpq
     capabilities: 23f. (ticket #772(7)).

   - Add *note scalar_row: 270. to return scalar values from a query
     (ticket #723(8)).

   - Add *note cancel_safe(): 1c4. for encrypted and non-blocking
     cancellation when using libpq v17.  Use such method internally to
     implement ‘KeyboardInterrupt’ and ‘copy’ termination (ticket
     #754(9)).

   - The ‘context’ parameter of *note sql: 9. objects *note as_string():
     261. and *note as_bytes(): 267. methods is now optional (ticket
     #716(10)).

   - Add *note set_autocommit(): 1bd. on sync connections, and similar
     transaction control methods available on the async connections.

   - Add a ‘size’ parameter to *note stream(): 19b. to enable results
     retrieval in chunks instead of row-by-row (ticket #794(11)).

New libpq wrapper features
..........................

   - Add support for libpq functions to close prepared statements and
     portals introduced in libpq v17 (ticket #603(12)).

   - Add support for libpq encrypted and non-blocking query cancellation
     functions introduced in libpq v17 (ticket #754(13)).

   - Add support for libpq function to retrieve results in chunks
     introduced in libpq v17 (ticket #793(14)).

   - Add support for libpq function to change role passwords introduced
     in libpq v17 (ticket #818(15)).

Other changes
.............

   - Drop support for Python 3.7.

   - Prepared statements are now *note compatible with PgBouncer: 18f.
     (ticket #589(16)).

   - Disable receiving more than one result on the same cursor in
     pipeline mode, to iterate through *note nextset(): e7.  The
     behaviour was different than in non-pipeline mode and not totally
     reliable (ticket #604(17)).  The *note Cursor: 36. now only
     preserves the results set of the last *note execute(): 3a,
     consistently with non-pipeline mode.

* Menu:

* Psycopg 3.1.20: Psycopg 3 1 20.
* Psycopg 3.1.19: Psycopg 3 1 19.
* Psycopg 3.1.18: Psycopg 3 1 18.
* Psycopg 3.1.17: Psycopg 3 1 17.
* Psycopg 3.1.16: Psycopg 3 1 16.
* Psycopg 3.1.15: Psycopg 3 1 15.
* Psycopg 3.1.14: Psycopg 3 1 14.
* Psycopg 3.1.13: Psycopg 3 1 13.
* Psycopg 3.1.12: Psycopg 3 1 12.
* Psycopg 3.1.11: Psycopg 3 1 11.
* Psycopg 3.1.10: Psycopg 3 1 10.
* Psycopg 3.1.9: Psycopg 3 1 9.
* Psycopg 3.1.8: Psycopg 3 1 8.
* Psycopg 3.1.7: Psycopg 3 1 7.
* Psycopg 3.1.6: Psycopg 3 1 6.
* Psycopg 3.1.5: Psycopg 3 1 5.
* Psycopg 3.1.4: Psycopg 3 1 4.
* Psycopg 3.1.3: Psycopg 3 1 3.
* Psycopg 3.1.2: Psycopg 3 1 2.
* Psycopg 3.1.1: Psycopg 3 1 1.

   ---------- Footnotes ----------

   (1) 
https://numpy.org/doc/stable/reference/arrays.scalars.html#built-in-scalar-types

   (2) https://github.com/psycopg/psycopg/issues/332

   (3) https://github.com/psycopg/psycopg/issues/340

   (4) https://github.com/psycopg/psycopg/issues/377

   (5) https://github.com/psycopg/psycopg/issues/560

   (6) https://github.com/psycopg/psycopg/issues/839

   (7) https://github.com/psycopg/psycopg/issues/772

   (8) https://github.com/psycopg/psycopg/issues/723

   (9) https://github.com/psycopg/psycopg/issues/754

   (10) https://github.com/psycopg/psycopg/issues/716

   (11) https://github.com/psycopg/psycopg/issues/794

   (12) https://github.com/psycopg/psycopg/issues/603

   (13) https://github.com/psycopg/psycopg/issues/754

   (14) https://github.com/psycopg/psycopg/issues/793

   (15) https://github.com/psycopg/psycopg/issues/818

   (16) https://github.com/psycopg/psycopg/issues/589

   (17) https://github.com/psycopg/psycopg/issues/604


File: psycopg.info,  Node: Psycopg 3 1 20,  Next: Psycopg 3 1 19,  Up: Psycopg 3 2

1.4.1.15 Psycopg 3.1.20
.......................

   - Use the simple query protocol to execute COMMIT/ROLLBACK when
     possible.  This should make querying the PgBouncer admin database
     easier (ticket #820(1)).

   - Avoid unneeded escaping checks and memory over-allocation in text
     copy (ticket #829(2)).

   - Bundle binary package with OpenSSL 3.3.x (ticket #847(3)).

   - Drop macOS ARM64 binary packages for macOS versions before 14.0 and
     Python before 3.10 (not for our choice but for the lack of
     available CI runners; ticket #858(4))

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/820

   (2) https://github.com/psycopg/psycopg/issues/829

   (3) https://github.com/psycopg/psycopg/issues/847

   (4) https://github.com/psycopg/psycopg/issues/858


File: psycopg.info,  Node: Psycopg 3 1 19,  Next: Psycopg 3 1 18,  Prev: Psycopg 3 1 20,  Up: Psycopg 3 2

1.4.1.16 Psycopg 3.1.19
.......................

   - Fix unaligned access undefined behaviour in C extension (ticket
     #734(1)).

   - Fix excessive stripping of error message prefixes (ticket #752(2)).

   - Allow to specify the ‘connect_timeout’ connection parameter as
     float (ticket #796(3)).

   - Improve COPY performance on macOS (ticket #745(4)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/734

   (2) https://github.com/psycopg/psycopg/issues/752

   (3) https://github.com/psycopg/psycopg/issues/796

   (4) https://github.com/psycopg/psycopg/issues/745


File: psycopg.info,  Node: Psycopg 3 1 18,  Next: Psycopg 3 1 17,  Prev: Psycopg 3 1 19,  Up: Psycopg 3 2

1.4.1.17 Psycopg 3.1.18
.......................

   - Fix possible deadlock on pipeline exit (ticket #685(1)).

   - Fix overflow loading large intervals in C module (ticket #719(2)).

   - Fix compatibility with musl libc distributions affected by CPython
     issue #65821(3) (ticket #725(4)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/685

   (2) https://github.com/psycopg/psycopg/issues/719

   (3) https://github.com/python/cpython/issues/65821

   (4) https://github.com/psycopg/psycopg/issues/725


File: psycopg.info,  Node: Psycopg 3 1 17,  Next: Psycopg 3 1 16,  Prev: Psycopg 3 1 18,  Up: Psycopg 3 2

1.4.1.18 Psycopg 3.1.17
.......................

   - Fix multiple connection attempts when a host name resolve to
     multiple IP addresses (ticket #699(1)).

   - Use typing.Self(2) as a more correct return value annotation of
     context managers and other self-returning methods (see ticket
     #708(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/699

   (2) https://docs.python.org/3/library/typing.html#typing.Self

   (3) https://github.com/psycopg/psycopg/issues/708


File: psycopg.info,  Node: Psycopg 3 1 16,  Next: Psycopg 3 1 15,  Prev: Psycopg 3 1 17,  Up: Psycopg 3 2

1.4.1.19 Psycopg 3.1.16
.......................

   - Fix empty ports handling in async multiple connection attempts
     (ticket #703(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/703


File: psycopg.info,  Node: Psycopg 3 1 15,  Next: Psycopg 3 1 14,  Prev: Psycopg 3 1 16,  Up: Psycopg 3 2

1.4.1.20 Psycopg 3.1.15
.......................

   - Fix use of ‘service’ in connection string (regression in 3.1.13,
     ticket #694(1)).

   - Fix async connection to hosts resolving to multiple IP addresses
     (regression in 3.1.13, ticket #695(2)).

   - Respect the ‘PGCONNECT_TIMEOUT’ environment variable to determine
     the connection timeout.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/694

   (2) https://github.com/psycopg/psycopg/issues/695


File: psycopg.info,  Node: Psycopg 3 1 14,  Next: Psycopg 3 1 13,  Prev: Psycopg 3 1 15,  Up: Psycopg 3 2

1.4.1.21 Psycopg 3.1.14
.......................

   - Fix *note interaction with gevent: 10e. (ticket #527(1)).

   - Add support for PyPy (ticket #686(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/527

   (2) https://github.com/psycopg/psycopg/issues/686


File: psycopg.info,  Node: Psycopg 3 1 13,  Next: Psycopg 3 1 12,  Prev: Psycopg 3 1 14,  Up: Psycopg 3 2

1.4.1.22 Psycopg 3.1.13
.......................

   - Raise *note DataError: 6f. instead of whatever internal failure
     trying to dump a time(1) object with with a ‘tzinfo’ specified as
     ZoneInfo(2) (ambiguous offset, see ticket #652(3)).

   - Handle gracefully EINTR on signals instead of raising
     InterruptedError(4), consistently with PEP 475(5) guideline (ticket
     #667(6)).

   - Fix support for connection strings with multiple hosts/ports and
     for the ‘load_balance_hosts’ connection parameter (ticket #674(7)).

   - Fix memory leak receiving notifications in Python implementation
     (ticket #679(8)).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/datetime.html#datetime.time

   (2) https://docs.python.org/3/library/zoneinfo.html#zoneinfo.ZoneInfo

   (3) https://github.com/psycopg/psycopg/issues/652

   (4) 
https://docs.python.org/3/library/exceptions.html#InterruptedError

   (5) https://peps.python.org/pep-0475/

   (6) https://github.com/psycopg/psycopg/issues/667

   (7) https://github.com/psycopg/psycopg/issues/674

   (8) https://github.com/psycopg/psycopg/issues/679


File: psycopg.info,  Node: Psycopg 3 1 12,  Next: Psycopg 3 1 11,  Prev: Psycopg 3 1 13,  Up: Psycopg 3 2

1.4.1.23 Psycopg 3.1.12
.......................

   - Fix possible hanging if a connection is closed while querying
     (ticket #608(1)).

   - Fix memory leak when ‘register_*()’ functions are called repeatedly
     (ticket #647(2)).

   - Release Python 3.12 binary packages.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/608

   (2) https://github.com/psycopg/psycopg/issues/647


File: psycopg.info,  Node: Psycopg 3 1 11,  Next: Psycopg 3 1 10,  Prev: Psycopg 3 1 12,  Up: Psycopg 3 2

1.4.1.24 Psycopg 3.1.11
.......................

   - Avoid caching the parsing results of large queries to avoid
     excessive memory usage (ticket #628(1)).

   - Fix integer overflow in C/binary extension with OID > 2^31 (ticket
     #630(2)).

   - Fix loading of intervals with days and months or years (ticket
     #643(3)).

   - Work around excessive CPU usage on Windows (reported in ticket
     #645(4)).

   - Fix building on Solaris and derivatives (ticket #632(5)).

   - Fix possible lack of critical section guard in async *note
     executemany(): 203.

   - Fix missing pipeline fetch in async *note scroll(): 209.

   - Build binary packages with libpq 15.4, which allows group-readable
     permissions on the SSL certificate on the client (ticket #528(6)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/628

   (2) https://github.com/psycopg/psycopg/issues/630

   (3) https://github.com/psycopg/psycopg/issues/643

   (4) https://github.com/psycopg/psycopg/issues/645

   (5) https://github.com/psycopg/psycopg/issues/632

   (6) https://github.com/psycopg/psycopg/issues/528


File: psycopg.info,  Node: Psycopg 3 1 10,  Next: Psycopg 3 1 9,  Prev: Psycopg 3 1 11,  Up: Psycopg 3 2

1.4.1.25 Psycopg 3.1.10
.......................

   - Allow JSON dumpers to dump bytes(1) directly instead of str(2), for
     better compatibility with libraries like orjson and msgspec (ticket
     #569(3))

   - Fix prepared statement cache validation when exiting pipeline mode
     (or *note executemany(): 3b.) in case an error occurred within the
     pipeline (ticket #585(4)).

   - Fix *note connect(): 48. to avoid “leaking” an open *note PGconn:
     1c1. attached to the *note OperationalError: 1ab. in case of
     connection failure.  *note Error.pgconn: 27b. is now a shallow copy
     of the real libpq connection, and the latter is closed before the
     exception propagates (ticket #565(5)).

   - Fix possible (ignored) exception on objects deletion (ticket
     #591(6)).

   - Don’t clobber a Python exception raised during COPY FROM with the
     resulting ‘QueryCanceled’ raised as a consequence (ticket #593(7)).

   - Fix resetting *note Connection.read_only: b5. and *note deferrable:
     b6. to their default value using ‘None’ (ticket #612(8)).

   - Add support for Python 3.12.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#bytes

   (2) https://docs.python.org/3/library/stdtypes.html#str

   (3) https://github.com/psycopg/psycopg/issues/569

   (4) https://github.com/psycopg/psycopg/issues/585

   (5) https://github.com/psycopg/psycopg/issues/565

   (6) https://github.com/psycopg/psycopg/issues/591

   (7) https://github.com/psycopg/psycopg/issues/593

   (8) https://github.com/psycopg/psycopg/issues/612


File: psycopg.info,  Node: Psycopg 3 1 9,  Next: Psycopg 3 1 8,  Prev: Psycopg 3 1 10,  Up: Psycopg 3 2

1.4.1.26 Psycopg 3.1.9
......................

   - Fix ‘TypeInfo.fetch()’ using a connection in ‘sql_ascii’ encoding
     (ticket #503(1)).

   - Fix “filedescriptor out of range” using a large number of files
     open in Python implementation (ticket #532(2)).

   - Allow JSON dumpers to be registered on ‘dict’ or any other object,
     as was possible in psycopg2 (ticket #541(3)).

   - Fix canceling running queries on process interruption in async
     connections (ticket #543(4)).

   - Fix loading ROW values with different types in the same query using
     the binary protocol (ticket #545(5)).

   - Fix dumping recursive composite types (ticket #547(6)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/503

   (2) https://github.com/psycopg/psycopg/issues/532

   (3) https://github.com/psycopg/psycopg/issues/541

   (4) https://github.com/psycopg/psycopg/issues/543

   (5) https://github.com/psycopg/psycopg/issues/545

   (6) https://github.com/psycopg/psycopg/issues/547


File: psycopg.info,  Node: Psycopg 3 1 8,  Next: Psycopg 3 1 7,  Prev: Psycopg 3 1 9,  Up: Psycopg 3 2

1.4.1.27 Psycopg 3.1.8
......................

   - Don’t pollute server logs when types looked for by
     ‘TypeInfo.fetch()’ are not found (ticket #473(1)).

   - Set *note Cursor.rowcount: 1ec. to the number of rows of each
     result set from *note executemany(): 3b. when called with
     ‘returning=True’ (ticket #479(2)).

   - Fix ‘TypeInfo.fetch()’ when used with *note ClientCursor: de.
     (ticket #484(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/473

   (2) https://github.com/psycopg/psycopg/issues/479

   (3) https://github.com/psycopg/psycopg/issues/484


File: psycopg.info,  Node: Psycopg 3 1 7,  Next: Psycopg 3 1 6,  Prev: Psycopg 3 1 8,  Up: Psycopg 3 2

1.4.1.28 Psycopg 3.1.7
......................

   - Fix server-side cursors using row factories (ticket #464(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/464


File: psycopg.info,  Node: Psycopg 3 1 6,  Next: Psycopg 3 1 5,  Prev: Psycopg 3 1 7,  Up: Psycopg 3 2

1.4.1.29 Psycopg 3.1.6
......................

   - Fix ‘cursor.copy()’ with cursors using row factories (ticket
     #460(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/460


File: psycopg.info,  Node: Psycopg 3 1 5,  Next: Psycopg 3 1 4,  Prev: Psycopg 3 1 6,  Up: Psycopg 3 2

1.4.1.30 Psycopg 3.1.5
......................

   - Fix array loading slowness compared to psycopg2 (ticket #359(1)).

   - Improve performance around network communication (ticket #414(2)).

   - Return ‘bytes’ instead of ‘memoryview’ from ‘pq.Encoding’ methods
     (ticket #422(3)).

   - Fix *note Cursor.rownumber: 1f1. to return ‘None’ when the result
     has no row to fetch (ticket #437(4)).

   - Avoid error in Pyright caused by aliasing ‘TypeAlias’ (ticket
     #439(5)).

   - Fix *note Copy.set_types(): d0. used with ‘varchar’ and ‘name’
     types (ticket #452(6)).

   - Improve performance using *note Row factories: 4d. (ticket
     #457(7)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/359

   (2) https://github.com/psycopg/psycopg/issues/414

   (3) https://github.com/psycopg/psycopg/issues/422

   (4) https://github.com/psycopg/psycopg/issues/437

   (5) https://github.com/psycopg/psycopg/issues/439

   (6) https://github.com/psycopg/psycopg/issues/452

   (7) https://github.com/psycopg/psycopg/issues/457


File: psycopg.info,  Node: Psycopg 3 1 4,  Next: Psycopg 3 1 3,  Prev: Psycopg 3 1 5,  Up: Psycopg 3 2

1.4.1.31 Psycopg 3.1.4
......................

   - Include *note error classes: 1a7. defined in PostgreSQL 15.

   - Add support for Python 3.11 (ticket #305(1)).

   - Build binary packages with libpq from PostgreSQL 15.0.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/305


File: psycopg.info,  Node: Psycopg 3 1 3,  Next: Psycopg 3 1 2,  Prev: Psycopg 3 1 4,  Up: Psycopg 3 2

1.4.1.32 Psycopg 3.1.3
......................

   - Restore the state of the connection if *note Cursor.stream(): 19b.
     is terminated prematurely (ticket #382(1)).

   - Fix regression introduced in 3.1 with different named tuples
     mangling rules for non-ascii attribute names (ticket #386(2)).

   - Fix handling of queries with escaped percent signs (‘%%’) in *note
     ClientCursor: de. (ticket #399(3)).

   - Fix possible duplicated BEGIN statements emitted in pipeline mode
     (ticket #401(4)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/382

   (2) https://github.com/psycopg/psycopg/issues/386

   (3) https://github.com/psycopg/psycopg/issues/399

   (4) https://github.com/psycopg/psycopg/issues/401


File: psycopg.info,  Node: Psycopg 3 1 2,  Next: Psycopg 3 1 1,  Prev: Psycopg 3 1 3,  Up: Psycopg 3 2

1.4.1.33 Psycopg 3.1.2
......................

   - Fix handling of certain invalid time zones causing problems on
     Windows (ticket #371(1)).

   - Fix segfault occurring when a loader fails initialization (ticket
     #372(2)).

   - Fix invalid SAVEPOINT issued when entering *note
     Connection.transaction(): 47. within a pipeline using an implicit
     transaction (ticket #374(3)).

   - Fix queries with repeated named parameters in *note ClientCursor:
     de. (ticket #378(4)).

   - Distribute macOS arm64 (Apple M1) binary packages (ticket #344(5)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/371

   (2) https://github.com/psycopg/psycopg/issues/372

   (3) https://github.com/psycopg/psycopg/issues/374

   (4) https://github.com/psycopg/psycopg/issues/378

   (5) https://github.com/psycopg/psycopg/issues/344


File: psycopg.info,  Node: Psycopg 3 1 1,  Prev: Psycopg 3 1 2,  Up: Psycopg 3 2

1.4.1.34 Psycopg 3.1.1
......................

   - Work around broken Homebrew installation of the libpq in a
     non-standard path (ticket #364(1))

   - Fix possible “unrecognized service” error in async connection when
     no port is specified (ticket #366(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/364

   (2) https://github.com/psycopg/psycopg/issues/366


File: psycopg.info,  Node: Psycopg 3 1,  Next: Psycopg 3 0,  Prev: Psycopg 3 2,  Up: psycopg release notes

1.4.1.35 Psycopg 3.1
....................

   - Add *note Pipeline mode: 13. (ticket #74(1)).

   - Add *note Client-side-binding cursors: dd. (ticket #101(2)).

   - Add CockroachDB(3) support in *note psycopg.crdb: 5. (ticket
     #313(4)).

   - Add *note Two-Phase Commit: bb. support (ticket #72(5)).

   - Add *note Enum adaptation: 7f. (ticket #274(6)).

   - Add ‘returning’ parameter to *note executemany(): 3b. to retrieve
     query results (ticket #164(7)).

   - *note executemany(): 3b. performance improved by using batch mode
     internally (ticket #145(8)).

   - Add parameters to *note copy(): c8.

   - Add *note COPY Writer objects: 21c.

   - Resolve domain names asynchronously in *note
     AsyncConnection.connect(): 35. (ticket #259(9)).

   - Add *note pq.PGconn.trace(): 2e5. and related trace functions
     (ticket #167(10)).

   - Add ‘prepare_threshold’ parameter to *note Connection: 34. init
     (ticket #200(11)).

   - Add ‘cursor_factory’ parameter to *note Connection: 34. init.

   - Add *note Error.pgconn: 27b. and *note Error.pgresult: 27e.
     attributes (ticket #242(12)).

   - Restrict queries to be LiteralString(13) as per PEP 675(14) (ticket
     #323(15)).

   - Add explicit type cast to values converted by *note sql.Literal:
     265. (ticket #205(16)).

   - Drop support for Python 3.6.

* Menu:

* Psycopg 3.0.17: Psycopg 3 0 17.
* Psycopg 3.0.16: Psycopg 3 0 16.
* Psycopg 3.0.15: Psycopg 3 0 15.
* Psycopg 3.0.14: Psycopg 3 0 14.
* Psycopg 3.0.13: Psycopg 3 0 13.
* Psycopg 3.0.12: Psycopg 3 0 12.
* Psycopg 3.0.11: Psycopg 3 0 11.
* Psycopg 3.0.10: Psycopg 3 0 10.
* Psycopg 3.0.9: Psycopg 3 0 9.
* Psycopg 3.0.8: Psycopg 3 0 8.
* Psycopg 3.0.7: Psycopg 3 0 7.
* Psycopg 3.0.6: Psycopg 3 0 6.
* Psycopg 3.0.5: Psycopg 3 0 5.
* Psycopg 3.0.4: Psycopg 3 0 4.
* Psycopg 3.0.3: Psycopg 3 0 3.
* Psycopg 3.0.2: Psycopg 3 0 2.
* Psycopg 3.0.1: Psycopg 3 0 1.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/74

   (2) https://github.com/psycopg/psycopg/issues/101

   (3) https://www.cockroachlabs.com/

   (4) https://github.com/psycopg/psycopg/issues/313

   (5) https://github.com/psycopg/psycopg/issues/72

   (6) https://github.com/psycopg/psycopg/issues/274

   (7) https://github.com/psycopg/psycopg/issues/164

   (8) https://github.com/psycopg/psycopg/issues/145

   (9) https://github.com/psycopg/psycopg/issues/259

   (10) https://github.com/psycopg/psycopg/issues/167

   (11) https://github.com/psycopg/psycopg/issues/200

   (12) https://github.com/psycopg/psycopg/issues/242

   (13) 
https://docs.python.org/3/library/typing.html#typing.LiteralString

   (14) https://peps.python.org/pep-0675/

   (15) https://github.com/psycopg/psycopg/issues/323

   (16) https://github.com/psycopg/psycopg/issues/205


File: psycopg.info,  Node: Psycopg 3 0 17,  Next: Psycopg 3 0 16,  Up: Psycopg 3 1

1.4.1.36 Psycopg 3.0.17
.......................

   - Fix segfaults on fork on some Linux systems using ctypes(1)
     implementation (ticket #300(2)).

   - Load bytea as bytes, not memoryview, using ctypes(3)
     implementation.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/ctypes.html#module-ctypes

   (2) https://github.com/psycopg/psycopg/issues/300

   (3) https://docs.python.org/3/library/ctypes.html#module-ctypes


File: psycopg.info,  Node: Psycopg 3 0 16,  Next: Psycopg 3 0 15,  Prev: Psycopg 3 0 17,  Up: Psycopg 3 1

1.4.1.37 Psycopg 3.0.16
.......................

   - Fix missing *note rowcount: 1ec. after SHOW (ticket #343(1)).

   - Add scripts to build macOS arm64 packages (ticket #162(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/343

   (2) https://github.com/psycopg/psycopg/issues/162


File: psycopg.info,  Node: Psycopg 3 0 15,  Next: Psycopg 3 0 14,  Prev: Psycopg 3 0 16,  Up: Psycopg 3 1

1.4.1.38 Psycopg 3.0.15
.......................

   - Fix wrong escaping of unprintable chars in COPY (nonetheless
     correctly interpreted by PostgreSQL).

   - Restore the connection to usable state after an error in *note
     stream(): 19b.

   - Raise *note DataError: 6f. instead of OverflowError(1) loading
     binary intervals out-of-range.

   - Distribute ‘manylinux2014’ wheel packages (ticket #124(2)).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/exceptions.html#OverflowError

   (2) https://github.com/psycopg/psycopg/issues/124


File: psycopg.info,  Node: Psycopg 3 0 14,  Next: Psycopg 3 0 13,  Prev: Psycopg 3 0 15,  Up: Psycopg 3 1

1.4.1.39 Psycopg 3.0.14
.......................

   - Raise *note DataError: 6f. dumping arrays of mixed types (ticket
     #301(1)).

   - Fix handling of incorrect server results, with blank sqlstate
     (ticket #303(2)).

   - Fix bad Float4 conversion on ppc64le/musllinux (ticket #304(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/301

   (2) https://github.com/psycopg/psycopg/issues/303

   (3) https://github.com/psycopg/psycopg/issues/304


File: psycopg.info,  Node: Psycopg 3 0 13,  Next: Psycopg 3 0 12,  Prev: Psycopg 3 0 14,  Up: Psycopg 3 1

1.4.1.40 Psycopg 3.0.13
.......................

   - Fix *note Cursor.stream(): 19b. slowness (ticket #286(1)).

   - Fix oid for lists of integers, which might cause the server
     choosing bad plans (ticket #293(2)).

   - Make *note Connection.cancel(): 10d. on a closed connection a no-op
     instead of an error.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/286

   (2) https://github.com/psycopg/psycopg/issues/293


File: psycopg.info,  Node: Psycopg 3 0 12,  Next: Psycopg 3 0 11,  Prev: Psycopg 3 0 13,  Up: Psycopg 3 1

1.4.1.41 Psycopg 3.0.12
.......................

   - Allow bytearray(1)/memoryview(2) data too as *note Copy.write():
     d3. input (ticket #254(3)).

   - Fix dumping IntEnum(4) in text mode, Python implementation.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#bytearray

   (2) https://docs.python.org/3/library/stdtypes.html#memoryview

   (3) https://github.com/psycopg/psycopg/issues/254

   (4) https://docs.python.org/3/library/enum.html#enum.IntEnum


File: psycopg.info,  Node: Psycopg 3 0 11,  Next: Psycopg 3 0 10,  Prev: Psycopg 3 0 12,  Up: Psycopg 3 1

1.4.1.42 Psycopg 3.0.11
.......................

   - Fix *note DataError: 6f. loading arrays with dimensions information
     (ticket #253(1)).

   - Fix hanging during COPY in case of memory error (ticket #255(2)).

   - Fix error propagation from COPY worker thread (mentioned in ticket
     #255(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/253

   (2) https://github.com/psycopg/psycopg/issues/255

   (3) https://github.com/psycopg/psycopg/issues/255


File: psycopg.info,  Node: Psycopg 3 0 10,  Next: Psycopg 3 0 9,  Prev: Psycopg 3 0 11,  Up: Psycopg 3 1

1.4.1.43 Psycopg 3.0.10
.......................

   - Leave the connection in working state after interrupting a query
     with Ctrl-C (ticket #231(1)).

   - Fix *note Cursor.description: 13b. after a COPY … TO STDOUT
     operation (ticket #235(2)).

   - Fix building on FreeBSD and likely other BSD flavours (ticket
     #241(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/231

   (2) https://github.com/psycopg/psycopg/issues/235

   (3) https://github.com/psycopg/psycopg/issues/241


File: psycopg.info,  Node: Psycopg 3 0 9,  Next: Psycopg 3 0 8,  Prev: Psycopg 3 0 10,  Up: Psycopg 3 1

1.4.1.44 Psycopg 3.0.9
......................

   - Set *note Error.sqlstate: 27a. when an unknown code is received
     (ticket #225(1)).

   - Add the ‘tzdata’ package as a dependency on Windows in order to
     handle time zones (ticket #223(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/225

   (2) https://github.com/psycopg/psycopg/issues/223


File: psycopg.info,  Node: Psycopg 3 0 8,  Next: Psycopg 3 0 7,  Prev: Psycopg 3 0 9,  Up: Psycopg 3 1

1.4.1.45 Psycopg 3.0.8
......................

   - Decode connection errors in the ‘client_encoding’ specified in the
     connection string, if available (ticket #194(1)).

   - Fix possible warnings in objects deletion on interpreter shutdown
     (ticket #198(2)).

   - Don’t leave connections in ACTIVE state in case of error during
     COPY … TO STDOUT (ticket #203(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/194

   (2) https://github.com/psycopg/psycopg/issues/198

   (3) https://github.com/psycopg/psycopg/issues/203


File: psycopg.info,  Node: Psycopg 3 0 7,  Next: Psycopg 3 0 6,  Prev: Psycopg 3 0 8,  Up: Psycopg 3 1

1.4.1.46 Psycopg 3.0.7
......................

   - Fix crash in *note executemany(): 3b. with no input sequence
     (ticket #179(1)).

   - Fix wrong *note rowcount: 1ec. after an *note executemany(): 3b.
     returning no rows (ticket #178(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/179

   (2) https://github.com/psycopg/psycopg/issues/178


File: psycopg.info,  Node: Psycopg 3 0 6,  Next: Psycopg 3 0 5,  Prev: Psycopg 3 0 7,  Up: Psycopg 3 1

1.4.1.47 Psycopg 3.0.6
......................

   - Allow to use *note Cursor.description: 13b. if the connection is
     closed (ticket #172(1)).

   - Don’t raise exceptions on *note ServerCursor.close(): 1f8. if the
     connection is closed (ticket #173(2)).

   - Fail on *note Connection.cursor(): 37. if the connection is closed
     (ticket #174(3)).

   - Raise *note ProgrammingError: 1ae. if out-of-order exit from
     transaction contexts is detected (tickets #176(4), #177(5)).

   - Add ‘CHECK_STANDBY’ value to *note ConnStatus: 2f1. enum.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/172

   (2) https://github.com/psycopg/psycopg/issues/173

   (3) https://github.com/psycopg/psycopg/issues/174

   (4) https://github.com/psycopg/psycopg/issues/176

   (5) https://github.com/psycopg/psycopg/issues/177


File: psycopg.info,  Node: Psycopg 3 0 5,  Next: Psycopg 3 0 4,  Prev: Psycopg 3 0 6,  Up: Psycopg 3 1

1.4.1.48 Psycopg 3.0.5
......................

   - Fix possible “Too many open files” OS error, reported on macOS but
     possible on other platforms too (ticket #158(1)).

   - Don’t clobber exceptions if a transaction block exit with error and
     rollback fails (ticket #165(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/158

   (2) https://github.com/psycopg/psycopg/issues/165


File: psycopg.info,  Node: Psycopg 3 0 4,  Next: Psycopg 3 0 3,  Prev: Psycopg 3 0 5,  Up: Psycopg 3 1

1.4.1.49 Psycopg 3.0.4
......................

   - Allow to use the module with strict strings comparison (ticket
     #147(1)).

   - Fix segfault on Python 3.6 running in ‘-W error’ mode, related to
     ‘backport.zoneinfo’ (ticket #109(2)).
     <‘https://github.com/pganssle/zoneinfo/issues/109’>'__.

   - Build binary package with libpq versions not affected by
     CVE-2021-23222(3) (ticket #149(4)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/147

   (2) https://github.com/psycopg/psycopg/issues/109

   (3) https://www.postgresql.org/support/security/CVE-2021-23222/

   (4) https://github.com/psycopg/psycopg/issues/149


File: psycopg.info,  Node: Psycopg 3 0 3,  Next: Psycopg 3 0 2,  Prev: Psycopg 3 0 4,  Up: Psycopg 3 1

1.4.1.50 Psycopg 3.0.3
......................

   - Release musllinux binary packages, compatible with Alpine Linux
     (ticket #141(1)).

   - Reduce size of binary package by stripping debug symbols (ticket
     #142(2)).

   - Include typing information in the ‘psycopg_binary’ package.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/141

   (2) https://github.com/psycopg/psycopg/issues/142


File: psycopg.info,  Node: Psycopg 3 0 2,  Next: Psycopg 3 0 1,  Prev: Psycopg 3 0 3,  Up: Psycopg 3 1

1.4.1.51 Psycopg 3.0.2
......................

   - Fix type hint for *note sql.SQL.join(): 262. (ticket #127(1)).

   - Fix type hint for *note Connection.notifies(): 11c. (ticket
     #128(2)).

   - Fix call to ‘MultiRange.__setitem__()’ with a non-iterable value
     and a slice, now raising a TypeError(3) (ticket #129(4)).

   - Fix disable cursors methods after close() (ticket #125(5)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/127

   (2) https://github.com/psycopg/psycopg/issues/128

   (3) https://docs.python.org/3/library/exceptions.html#TypeError

   (4) https://github.com/psycopg/psycopg/issues/129

   (5) https://github.com/psycopg/psycopg/issues/125


File: psycopg.info,  Node: Psycopg 3 0 1,  Prev: Psycopg 3 0 2,  Up: Psycopg 3 1

1.4.1.52 Psycopg 3.0.1
......................

   - Fix use of the wrong dumper reusing cursors with the same query but
     different parameter types (ticket #112(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/112


File: psycopg.info,  Node: Psycopg 3 0,  Prev: Psycopg 3 1,  Up: psycopg release notes

1.4.1.53 Psycopg 3.0
....................

First stable release.  Changed from 3.0b1:

   - Add *note Geometry adaptation using Shapely: a4. (ticket #80(1)).

   - Add *note Multirange adaptation: 9c. (ticket #75(2)).

   - Add *note pq.__build_version__: 2a. constant.

   - Don’t use the extended protocol with COPY, (tickets #78(3),
     #82(4)).

   - Add ‘context’ parameter to *note connect(): 33. (ticket #83(5)).

   - Fix selection of dumper by oid after *note set_types(): d0.

   - Drop ‘Connection.client_encoding’.  Use *note
     ConnectionInfo.encoding: 67. to read it, and a ‘SET’ statement to
     change it.

   - Add binary packages for Python 3.10 (ticket #103(6)).

* Menu:

* Psycopg 3.0b1: Psycopg 3 0b1.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/80

   (2) https://github.com/psycopg/psycopg/issues/75

   (3) https://github.com/psycopg/psycopg/issues/78

   (4) https://github.com/psycopg/psycopg/issues/82

   (5) https://github.com/psycopg/psycopg/issues/83

   (6) https://github.com/psycopg/psycopg/issues/103


File: psycopg.info,  Node: Psycopg 3 0b1,  Up: Psycopg 3 0

1.4.1.54 Psycopg 3.0b1
......................

   - First public release on PyPI.


File: psycopg.info,  Node: psycopg_pool release notes,  Prev: psycopg release notes,  Up: Release notes

1.4.2 ‘psycopg_pool’ release notes
----------------------------------

* Menu:

* Future releases::
* Current release: Current release<2>.
* psycopg_pool 3.2.0: psycopg_pool 3 2 0.
* psycopg_pool 3.1.0: psycopg_pool 3 1 0.
* psycopg_pool 3.0: psycopg_pool 3 0.


File: psycopg.info,  Node: Future releases,  Next: Current release<2>,  Up: psycopg_pool release notes

1.4.2.1 Future releases
.......................

* Menu:

* psycopg_pool 3.2.7 (unreleased): psycopg_pool 3 2 7 unreleased.


File: psycopg.info,  Node: psycopg_pool 3 2 7 unreleased,  Up: Future releases

1.4.2.2 psycopg_pool 3.2.7 (unreleased)
.......................................

   - Fix infinite loop with connections modified to return on close
     (ticket #1124(1)).

   - Fix request of excessive connections upon connection close failing
     and retrying (ticket #1176(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1124

   (2) https://github.com/psycopg/psycopg/issues/1176


File: psycopg.info,  Node: Current release<2>,  Next: psycopg_pool 3 2 0,  Prev: Future releases,  Up: psycopg_pool release notes

1.4.2.3 Current release
.......................

* Menu:

* psycopg_pool 3.2.6: psycopg_pool 3 2 6.
* psycopg_pool 3.2.5: psycopg_pool 3 2 5.
* psycopg_pool 3.2.4: psycopg_pool 3 2 4.
* psycopg_pool 3.2.3: psycopg_pool 3 2 3.
* psycopg_pool 3.2.2: psycopg_pool 3 2 2.
* psycopg_pool 3.2.1: psycopg_pool 3 2 1.


File: psycopg.info,  Node: psycopg_pool 3 2 6,  Next: psycopg_pool 3 2 5,  Up: Current release<2>

1.4.2.4 psycopg_pool 3.2.6
..........................

   - Reset transaction status of connection failing check (ticket
     #1014(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1014


File: psycopg.info,  Node: psycopg_pool 3 2 5,  Next: psycopg_pool 3 2 4,  Prev: psycopg_pool 3 2 6,  Up: Current release<2>

1.4.2.5 psycopg_pool 3.2.5
..........................

   - Fix spurious warning logging on pool shrinking (ticket #1001(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/1001


File: psycopg.info,  Node: psycopg_pool 3 2 4,  Next: psycopg_pool 3 2 3,  Prev: psycopg_pool 3 2 5,  Up: Current release<2>

1.4.2.6 psycopg_pool 3.2.4
..........................

   - Add a hint to the warning printed if threads fail to stop during
     ‘__del__’, which has been reported happening during interpreter
     shutdown on Python 3.13 (see ticket #954(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/954


File: psycopg.info,  Node: psycopg_pool 3 2 3,  Next: psycopg_pool 3 2 2,  Prev: psycopg_pool 3 2 4,  Up: Current release<2>

1.4.2.7 psycopg_pool 3.2.3
..........................

   - Add metadata to declare compatibility with Python 3.13.


File: psycopg.info,  Node: psycopg_pool 3 2 2,  Next: psycopg_pool 3 2 1,  Prev: psycopg_pool 3 2 3,  Up: Current release<2>

1.4.2.8 psycopg_pool 3.2.2
..........................

   - Raise a RuntimeWarning(1) instead of a DeprecationWarning(2) if an
     async pool is open in the constructor.

   - Fix connections possibly left in the pool after closing (ticket
     #784(3)).

   - Use an empty query instead of ‘SELECT 1’ to check connections
     (ticket #790(4)).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/exceptions.html#RuntimeWarning

   (2) 
https://docs.python.org/3/library/exceptions.html#DeprecationWarning

   (3) https://github.com/psycopg/psycopg/issues/784

   (4) https://github.com/psycopg/psycopg/issues/790


File: psycopg.info,  Node: psycopg_pool 3 2 1,  Prev: psycopg_pool 3 2 2,  Up: Current release<2>

1.4.2.9 psycopg_pool 3.2.1
..........................

   - Respect the ‘timeout’ parameter on *note connection(): 12d. when
     ‘check’ fails.  Also avoid a busy-loop of checking; separate check
     attempts using an exponential backoff (ticket #709(1)).

   - Use typing.Self(2) as a more correct return value annotation of
     context managers and other self-returning methods (see ticket
     708(3)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/709

   (2) https://docs.python.org/3/library/typing.html#typing.Self

   (3) https://github.com/psycopg/psycopg/issues/708


File: psycopg.info,  Node: psycopg_pool 3 2 0,  Next: psycopg_pool 3 1 0,  Prev: Current release<2>,  Up: psycopg_pool release notes

1.4.2.10 psycopg_pool 3.2.0
...........................

   - Add support for async ‘reconnect_failed’ callbacks in *note
     AsyncConnectionPool: 142. (ticket #520(1)).

   - Add ‘check’ parameter to the pool constructor and *note
     check_connection(): 152. method.  (ticket #656(2)).

   - Make connection pool classes generic on the connection type (ticket
     #559(3)).

   - Raise a warning if sync pools rely an implicit ‘open=True’ and the
     pool context is not used.  In the future the default will become
     ‘False’ (ticket #659(4)).

   - Raise a warning if async pools are opened in the constructor.  In
     the future it will become an error.  (ticket #659(5)).

* Menu:

* psycopg_pool 3.1.9: psycopg_pool 3 1 9.
* psycopg_pool 3.1.8: psycopg_pool 3 1 8.
* psycopg_pool 3.1.7: psycopg_pool 3 1 7.
* psycopg_pool 3.1.6: psycopg_pool 3 1 6.
* psycopg_pool 3.1.5: psycopg_pool 3 1 5.
* psycopg_pool 3.1.4: psycopg_pool 3 1 4.
* psycopg_pool 3.1.3: psycopg_pool 3 1 3.
* psycopg_pool 3.1.2: psycopg_pool 3 1 2.
* psycopg_pool 3.1.1: psycopg_pool 3 1 1.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/520

   (2) https://github.com/psycopg/psycopg/issues/656

   (3) https://github.com/psycopg/psycopg/issues/559

   (4) https://github.com/psycopg/psycopg/issues/659

   (5) https://github.com/psycopg/psycopg/issues/659


File: psycopg.info,  Node: psycopg_pool 3 1 9,  Next: psycopg_pool 3 1 8,  Up: psycopg_pool 3 2 0

1.4.2.11 psycopg_pool 3.1.9
...........................

   - Fix the return type annotation of ‘NullConnectionPool.__enter__()’
     (ticket #540(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/540


File: psycopg.info,  Node: psycopg_pool 3 1 8,  Next: psycopg_pool 3 1 7,  Prev: psycopg_pool 3 1 9,  Up: psycopg_pool 3 2 0

1.4.2.12 psycopg_pool 3.1.8
...........................

   - Enforce connections’ ‘max_lifetime’ on *note check(): 15a. (ticket
     #482(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/482


File: psycopg.info,  Node: psycopg_pool 3 1 7,  Next: psycopg_pool 3 1 6,  Prev: psycopg_pool 3 1 8,  Up: psycopg_pool 3 2 0

1.4.2.13 psycopg_pool 3.1.7
...........................

   - Fix handling of tasks cancelled while waiting in async pool queue
     (ticket #503(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/503


File: psycopg.info,  Node: psycopg_pool 3 1 6,  Next: psycopg_pool 3 1 5,  Prev: psycopg_pool 3 1 7,  Up: psycopg_pool 3 2 0

1.4.2.14 psycopg_pool 3.1.6
...........................

   - Declare all parameters in pools constructors, instead of using
     ‘**kwargs’ (ticket #493(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/493


File: psycopg.info,  Node: psycopg_pool 3 1 5,  Next: psycopg_pool 3 1 4,  Prev: psycopg_pool 3 1 6,  Up: psycopg_pool 3 2 0

1.4.2.15 psycopg_pool 3.1.5
...........................

   - Make sure that ‘ConnectionPool.check()’ refills an empty pool
     (ticket #438(1)).

   - Avoid error in Pyright caused by aliasing ‘TypeAlias’ (ticket
     #439(2)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/438

   (2) https://github.com/psycopg/psycopg/issues/439


File: psycopg.info,  Node: psycopg_pool 3 1 4,  Next: psycopg_pool 3 1 3,  Prev: psycopg_pool 3 1 5,  Up: psycopg_pool 3 2 0

1.4.2.16 psycopg_pool 3.1.4
...........................

   - Fix async pool exhausting connections, happening if the pool is
     created before the event loop is started (ticket #219(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/219


File: psycopg.info,  Node: psycopg_pool 3 1 3,  Next: psycopg_pool 3 1 2,  Prev: psycopg_pool 3 1 4,  Up: psycopg_pool 3 2 0

1.4.2.17 psycopg_pool 3.1.3
...........................

   - Add support for Python 3.11 (ticket #305(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/305


File: psycopg.info,  Node: psycopg_pool 3 1 2,  Next: psycopg_pool 3 1 1,  Prev: psycopg_pool 3 1 3,  Up: psycopg_pool 3 2 0

1.4.2.18 psycopg_pool 3.1.2
...........................

   - Fix possible failure to reconnect after losing connection from the
     server (ticket #370(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/370


File: psycopg.info,  Node: psycopg_pool 3 1 1,  Prev: psycopg_pool 3 1 2,  Up: psycopg_pool 3 2 0

1.4.2.19 psycopg_pool 3.1.1
...........................

   - Fix race condition on pool creation which might result in the pool
     not filling (ticket #230(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/230


File: psycopg.info,  Node: psycopg_pool 3 1 0,  Next: psycopg_pool 3 0,  Prev: psycopg_pool 3 2 0,  Up: psycopg_pool release notes

1.4.2.20 psycopg_pool 3.1.0
...........................

   - Add *note Null connection pools: 14b. (ticket #148(1)).

   - Add *note ConnectionPool.open(): 148. and ‘open’ parameter to the
     pool constructor (ticket #151(2)).

   - Drop support for Python 3.6.

* Menu:

* psycopg_pool 3.0.3: psycopg_pool 3 0 3.
* psycopg_pool 3.0.2: psycopg_pool 3 0 2.
* psycopg_pool 3.0.1: psycopg_pool 3 0 1.

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/148

   (2) https://github.com/psycopg/psycopg/issues/151


File: psycopg.info,  Node: psycopg_pool 3 0 3,  Next: psycopg_pool 3 0 2,  Up: psycopg_pool 3 1 0

1.4.2.21 psycopg_pool 3.0.3
...........................

   - Raise ‘ValueError’ if *note ConnectionPool: 12c. ‘min_size’ and
     ‘max_size’ are both set to 0 (instead of hanging).

   - Raise *note PoolClosed: 29e. calling *note wait(): 145. on a closed
     pool.


File: psycopg.info,  Node: psycopg_pool 3 0 2,  Next: psycopg_pool 3 0 1,  Prev: psycopg_pool 3 0 3,  Up: psycopg_pool 3 1 0

1.4.2.22 psycopg_pool 3.0.2
...........................

   - Remove dependency on the internal ‘psycopg._compat’ module.


File: psycopg.info,  Node: psycopg_pool 3 0 1,  Prev: psycopg_pool 3 0 2,  Up: psycopg_pool 3 1 0

1.4.2.23 psycopg_pool 3.0.1
...........................

   - Don’t leave connections idle in transaction after calling *note
     check(): 15a. (ticket #144(1)).

   ---------- Footnotes ----------

   (1) https://github.com/psycopg/psycopg/issues/144


File: psycopg.info,  Node: psycopg_pool 3 0,  Prev: psycopg_pool 3 1 0,  Up: psycopg_pool release notes

1.4.2.24 psycopg_pool 3.0
.........................

   - First release on PyPI.


File: psycopg.info,  Node: Indices and tables,  Prev: Release notes,  Up: Documentation

1.5 Indices and tables
======================

   * genindex

   * modindex


File: psycopg.info,  Node: Python Module Index,  Next: Index,  Prev: Documentation,  Up: Top

Python Module Index
*******************

* Menu:

* psycopg: 0.
* psycopg._dns: 1.
* psycopg.abc: 2.
* psycopg.adapt: 3.
* psycopg.conninfo: 4.
* psycopg.crdb: 5.
* psycopg.errors: 6.
* psycopg.pq: 7.
* psycopg.rows: 8.
* psycopg.sql: 9.
* psycopg.types: a.
* psycopg_pool: b.


File: psycopg.info,  Node: Index,  Prev: Python Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* __build_version__ (in module psycopg.pq): Module content.   (line  29)
* __call__() (psycopg.rows.RowFactory method): Formal rows protocols.
                                                              (line  43)
* __call__() (psycopg.rows.RowMaker method): Formal rows protocols.
                                                              (line  23)
* __getitem__() (psycopg.types.TypesRegistry method): Types information.
                                                              (line 117)
* __impl__ (in module psycopg.pq):       Module content.      (line   6)
* _get_connection_params() (psycopg.AsyncConnection class method): _dns – DNS resolution utilities.
                                                              (line  83)
* _get_connection_params() (psycopg.Connection class method): _dns – DNS resolution utilities.
                                                              (line  65)
* _query (psycopg.Cursor attribute):     The Cursor class.    (line 362)
* ABORTED (psycopg.pq.PipelineStatus attribute): Enumerations.
                                                              (line 111)
* ACTIVE (psycopg.pq.TransactionStatus attribute): Enumerations.
                                                              (line  55)
* Adaptation:                            Binary parameters and results.
                                                              (line  47)
* Adaptation <1>:                        Enum adaptation.     (line 171)
* Adaptation; numbers:                   Booleans adaptation. (line  14)
* AdaptContext (class in psycopg.abc):   abc – Psycopg abstract classes.
                                                              (line 172)
* adapters (in module psycopg.crdb):     CockroachDB-specific objects.
                                                              (line  67)
* adapters (in module psycopg):          The psycopg module.  (line  65)
* adapters (psycopg.abc.AdaptContext property): abc – Psycopg abstract classes.
                                                              (line 188)
* AdaptersMap (class in psycopg.adapt):  Other objects used in adaptations.
                                                              (line  19)
* add_notice_handler() (psycopg.Connection method): The Connection class.
                                                              (line 486)
* add_notify_handler() (psycopg.Connection method): The Connection class.
                                                              (line 464)
* args_row() (in module psycopg.rows):   rows – row factory implementations.
                                                              (line 106)
* as_bytes() (psycopg.sql.Composable method): sql objects.    (line  45)
* as_string() (psycopg.sql.Composable method): sql objects.   (line  30)
* AsyncClientCursor (class in psycopg):  Async cursor classes.
                                                              (line 119)
* AsyncConnection (class in psycopg):    The AsyncConnection class.
                                                              (line   6)
* AsyncConnectionPool (class in psycopg_pool): The AsyncConnectionPool class.
                                                              (line  14)
* AsyncCopy (class in psycopg):          Main Copy objects.   (line  95)
* AsyncCrdbConnection (class in psycopg.crdb): CockroachDB-specific objects.
                                                              (line  38)
* AsyncCursor (class in psycopg):        Async cursor classes.
                                                              (line  10)
* Asynchronous; Notifications:           Gevent support.      (line  17)
* Asynchronous; Notifications <1>:       Server messages.     (line  51)
* asyncio:                               Concurrent operations.
                                                              (line  62)
* AsyncLibpqWriter (class in psycopg.copy): Writer objects.   (line  79)
* AsyncNullConnectionPool (class in psycopg_pool): Null connection pools<2>.
                                                              (line  78)
* AsyncPipeline (class in psycopg):      Pipeline-related objects.
                                                              (line  25)
* AsyncRawCursor (class in psycopg):     Async cursor classes.
                                                              (line 204)
* AsyncRawServerCursor (class in psycopg): Async cursor classes.
                                                              (line 213)
* AsyncRowFactory (class in psycopg.rows): Formal rows protocols.
                                                              (line  48)
* AsyncServerCursor (class in psycopg):  Async cursor classes.
                                                              (line 128)
* AsyncTransaction (class in psycopg):   Transaction-related objects.
                                                              (line  40)
* AsyncWriter (class in psycopg.copy):   Writer objects.      (line  61)
* AUTO (psycopg.adapt.PyFormat attribute): Other objects used in adaptations.
                                                              (line  13)
* autocommit (psycopg.Connection attribute): The Connection class.
                                                              (line 274)
* backend_pid (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  55)
* BAD (psycopg.pq.ConnStatus attribute): Enumerations.        (line  23)
* BAD_RESPONSE (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  82)
* BaseRowFactory (class in psycopg.rows): Formal rows protocols.
                                                              (line  52)
* BINARY (psycopg.adapt.PyFormat attribute): Other objects used in adaptations.
                                                              (line  17)
* BINARY (psycopg.pq.Format attribute):  Enumerations.        (line 123)
* Binary string:                         Strings adaptation.  (line  62)
* Binary; Parameters:                    Danger SQL injection.
                                                              (line  71)
* Binding; Client-Side:                  sql – SQL string composition.
                                                              (line   6)
* blocking() (psycopg.pq.PGcancelConn method): Objects wrapping libpq structures and functions.
                                                              (line 149)
* Boolean; Adaptation:                   Adapting basic Python types.
                                                              (line  14)
* bqual (psycopg.Xid attribute):         Two-Phase Commit related objects.
                                                              (line  27)
* broken (psycopg.Connection attribute): The Connection class.
                                                              (line  93)
* bytea; Adaptation:                     Strings adaptation.  (line  63)
* bytearray; Adaptation:                 Strings adaptation.  (line  63)
* bytes; Adaptation:                     Strings adaptation.  (line  63)
* cancel_conn() (psycopg.pq.PGconn method): Objects wrapping libpq structures and functions.
                                                              (line  22)
* cancel_safe() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 119)
* cancel_safe() (psycopg.Connection method): The Connection class.
                                                              (line 387)
* cancel() (psycopg.Connection method):  The Connection class.
                                                              (line 419)
* cancel() (psycopg.pq.PGcancel method): Objects wrapping libpq structures and functions.
                                                              (line 180)
* CancellationTimeout:                   Other Psycopg errors.
                                                              (line  18)
* Capabilities (class in psycopg):       Libpq capabilities information.
                                                              (line   6)
* capabilities (in module psycopg):      The psycopg module.  (line  25)
* change_password() (psycopg.pq.PGconn method): Objects wrapping libpq structures and functions.
                                                              (line  59)
* channel (psycopg.Notify attribute):    Notifications.       (line  12)
* check_connection() (psycopg_pool.AsyncConnectionPool static method): The AsyncConnectionPool class.
                                                              (line 169)
* check_connection() (psycopg_pool.ConnectionPool static method): The ConnectionPool class.
                                                              (line 252)
* check() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 162)
* check() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 245)
* check() (psycopg_pool.NullConnectionPool method): Null connection pools<2>.
                                                              (line  70)
* class_row() (in module psycopg.rows):  rows – row factory implementations.
                                                              (line  69)
* ClientCursor (class in psycopg):       The ClientCursor class.
                                                              (line  11)
* close() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 119)
* close() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 193)
* close() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  34)
* close() (psycopg.AsyncCursor method):  Async cursor classes.
                                                              (line  23)
* close() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 141)
* close() (psycopg.Connection method):   The Connection class.
                                                              (line  77)
* close() (psycopg.Cursor method):       The Cursor class.    (line  24)
* close() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line  53)
* closed (psycopg.Connection attribute): The Connection class.
                                                              (line  89)
* closed (psycopg.Cursor attribute):     The Cursor class.    (line  36)
* Column (class in psycopg):             The description Column object.
                                                              (line   6)
* column_name (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* COLUMN_NAME (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* COMMAND_OK (psycopg.pq.ExecStatus attribute): Enumerations. (line  74)
* commit() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  85)
* commit() (psycopg.Connection method):  The Connection class.
                                                              (line 231)
* Composable (class in psycopg.sql):     sql objects.         (line  15)
* Composed (class in psycopg.sql):       sql objects.         (line 235)
* Composite types; Data types:           Adapting other PostgreSQL types.
                                                              (line  10)
* CompositeInfo (class in psycopg.types.composite): Composite types casting.
                                                              (line  15)
* connect() (in module psycopg.crdb):    CockroachDB-specific objects.
                                                              (line   6)
* connect() (in module psycopg):         The psycopg module.  (line  10)
* connect() (psycopg.AsyncConnection class method): The AsyncConnection class.
                                                              (line  19)
* connect() (psycopg.Connection class method): The Connection class.
                                                              (line  20)
* Connection (class in psycopg):         The Connection class.
                                                              (line   6)
* connection (psycopg.abc.AdaptContext property): abc – Psycopg abstract classes.
                                                              (line 192)
* connection (psycopg.AsyncCursor attribute): Async cursor classes.
                                                              (line  21)
* connection (psycopg.AsyncTransaction attribute): Transaction-related objects.
                                                              (line  45)
* connection (psycopg.Cursor attribute): The Cursor class.    (line  20)
* connection (psycopg.Transaction attribute): Transaction-related objects.
                                                              (line  36)
* Connection; '!with':                   Shortcuts.           (line  44)
* Connection; Pool:                      psycopg_pool – Connection pool implementations.
                                                              (line   6)
* connection() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line  82)
* connection() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 149)
* ConnectionInfo (class in psycopg):     Connection information.
                                                              (line   6)
* ConnectionPool (class in psycopg_pool): The ConnectionPool class.
                                                              (line   6)
* ConnectionTimeout:                     Other Psycopg errors.
                                                              (line   9)
* Conninfo (class in psycopg.pq):        Objects wrapping libpq structures and functions.
                                                              (line 128)
* conninfo_to_dict() (in module psycopg.conninfo): conninfo – manipulate connection strings.
                                                              (line   9)
* ConnStatus (class in psycopg.pq):      Enumerations.        (line   6)
* constraint_name (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* CONSTRAINT_NAME (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* context (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* CONTEXT (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* Copy (class in psycopg):               Main Copy objects.   (line   6)
* COPY_BOTH (psycopg.pq.ExecStatus attribute): Enumerations.  (line  88)
* COPY_IN (psycopg.pq.ExecStatus attribute): Enumerations.    (line  80)
* COPY_OUT (psycopg.pq.ExecStatus attribute): Enumerations.   (line  78)
* COPY; SQL command:                     Two-Phase Commit protocol support.
                                                              (line  48)
* copy() (psycopg.AsyncCursor method):   Async cursor classes.
                                                              (line  46)
* copy() (psycopg.Cursor method):        The Cursor class.    (line 149)
* CrdbConnection (class in psycopg.crdb): CockroachDB-specific objects.
                                                              (line  20)
* CrdbConnectionInfo (class in psycopg.crdb): CockroachDB-specific objects.
                                                              (line  45)
* Ctrl-C:                                with async connections.
                                                              (line  42)
* Cursor:                                Pool stats.          (line  57)
* Cursor (class in psycopg):             The Cursor class.    (line   6)
* cursor_factory (psycopg.AsyncConnection attribute): The AsyncConnection class.
                                                              (line  58)
* cursor_factory (psycopg.Connection attribute): The Connection class.
                                                              (line 146)
* Cursor; Client-binding:                Client-side cursors. (line  24)
* Cursor; Client-side:                   Cursor types.        (line  51)
* Cursor; Named:                         Simple query protocol.
                                                              (line  32)
* Cursor; Server-side:                   Simple query protocol.
                                                              (line  33)
* cursor() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  43)
* cursor() (psycopg.Connection method):  The Connection class.
                                                              (line 101)
* Data types; Adaptation:                Binary parameters and results.
                                                              (line  46)
* Data types; Adaptation <1>:            Enum adaptation.     (line 170)
* database (psycopg.Xid attribute):      Two-Phase Commit related objects.
                                                              (line  44)
* DatabaseError:                         DB-API exceptions.   (line  78)
* DataError:                             DB-API exceptions.   (line  82)
* datatype_name (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* DATATYPE_NAME (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* DateStyle:                             Dates and times limits in Python.
                                                              (line  25)
* dbname (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 130)
* Decimal; Adaptation:                   Booleans adaptation. (line  13)
* DEFAULT (in module psycopg.sql):       Utility functions.   (line  20)
* deferrable (psycopg.Connection attribute): The Connection class.
                                                              (line 323)
* description (psycopg.Cursor attribute): The Cursor class.   (line 332)
* diag (psycopg.Error attribute):        DB-API exceptions.   (line  34)
* Diagnostic (class in psycopg.errors):  Error diagnostics.   (line   6)
* DiagnosticField (class in psycopg.pq): Enumerations.        (line 125)
* dict_row() (in module psycopg.rows):   rows – row factory implementations.
                                                              (line  27)
* dict; Adaptation:                      Multirange adaptation.
                                                              (line  98)
* disconnections:                        Notifies handlers.   (line  22)
* display_size (psycopg.Column attribute): The description Column object.
                                                              (line  32)
* dsn (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  12)
* dump() (psycopg.abc.Dumper method):    abc – Psycopg abstract classes.
                                                              (line  36)
* dump() (psycopg.adapt.Dumper method):  Dumpers and loaders. (line  15)
* Dumper (class in psycopg.abc):         abc – Psycopg abstract classes.
                                                              (line   9)
* Dumper (class in psycopg.adapt):       Dumpers and loaders. (line   6)
* EMPTY_QUERY (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  72)
* encoding (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 157)
* Encoding; SQL_ASCII:                   Numbers adaptation.  (line  34)
* encrypt_password() (psycopg.pq.PGconn method): Objects wrapping libpq structures and functions.
                                                              (line  48)
* enum (psycopg.types.enum.EnumInfo attribute): Enum adaptation.
                                                              (line  58)
* EnumInfo (class in psycopg.types.enum): Enum adaptation.    (line  44)
* environment variable; PATH:            Local installation.  (line  21)
* environment variable; PGCONNECT_TIMEOUT: Psycopg 3 1 15.    (line  12)
* environment variable; PGGSSENCMODE:    Psycopg 3 2 10.      (line  43)
* environment variable; PSYCOPG_IMPL:    Handling dependencies.
                                                              (line  25)
* environment variable; PSYCOPG_IMPL <1>: pq module implementations.
                                                              (line  32)
* environment variable; PSYCOPG_IMPL <2>: Module content.     (line  13)
* Error:                                 DB-API exceptions.   (line  24)
* error_message (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  81)
* error_message() (in module psycopg.pq): Module content.     (line  40)
* Error; Class:                          errors – Package exceptions.
                                                              (line   6)
* Escaping (class in psycopg.pq):        Objects wrapping libpq structures and functions.
                                                              (line 132)
* Example; Usage:                        Basic module usage.  (line  11)
* Exceptions; DB-API:                    errors – Package exceptions.
                                                              (line   8)
* Exceptions; PostgreSQL:                Other Psycopg errors.
                                                              (line  31)
* ExecStatus (class in psycopg.pq):      Enumerations.        (line  63)
* execute() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  70)
* execute() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  35)
* execute() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 150)
* execute() (psycopg.Connection method): The Connection class.
                                                              (line 175)
* execute() (psycopg.Cursor method):     The Cursor class.    (line  43)
* execute() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line  69)
* executemany() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  41)
* executemany() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 156)
* executemany() (psycopg.Cursor method): The Cursor class.    (line  79)
* executemany() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line 100)
* FAILED (psycopg.pq.PollingStatus attribute): Enumerations.  (line  36)
* FATAL_ERROR (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  86)
* fetch() (psycopg.types.TypeInfo class method): Types information.
                                                              (line  54)
* fetchall() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  92)
* fetchall() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 179)
* fetchall() (psycopg.Cursor method):    The Cursor class.    (line 291)
* fetchall() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line 123)
* fetchmany() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  83)
* fetchmany() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 170)
* fetchmany() (psycopg.Cursor method):   The Cursor class.    (line 281)
* fetchmany() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line 114)
* fetchone() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  74)
* fetchone() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 161)
* fetchone() (psycopg.Cursor method):    The Cursor class.    (line 271)
* fetchone() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line 105)
* fileno() (psycopg.Connection method):  The Connection class.
                                                              (line 508)
* FileWriter (class in psycopg.copy):    Writer objects.      (line  43)
* finish() (psycopg.copy.AsyncWriter method): Writer objects. (line  72)
* finish() (psycopg.copy.Writer method): Writer objects.      (line  30)
* finish() (psycopg.pq.PGcancelConn method): Objects wrapping libpq structures and functions.
                                                              (line 156)
* Float; Adaptation:                     Booleans adaptation. (line  14)
* Format (class in psycopg.pq):          Enumerations.        (line 113)
* format (psycopg.abc.Dumper attribute): abc – Psycopg abstract classes.
                                                              (line  29)
* format (psycopg.abc.Loader attribute): abc – Psycopg abstract classes.
                                                              (line 157)
* format (psycopg.adapt.Dumper attribute): Dumpers and loaders.
                                                              (line  26)
* format (psycopg.adapt.Loader attribute): Dumpers and loaders.
                                                              (line  73)
* format (psycopg.Cursor attribute):     The Cursor class.    (line 225)
* format_id (psycopg.Xid attribute):     Two-Phase Commit related objects.
                                                              (line  15)
* format() (psycopg.sql.SQL method):     sql objects.         (line  90)
* free() (psycopg.pq.PGcancel method):   Objects wrapping libpq structures and functions.
                                                              (line 171)
* geometry; Data types:                  Hstore adaptation.   (line  59)
* get_by_subtype() (psycopg.types.TypesRegistry method): Types information.
                                                              (line 161)
* get_cancel() (psycopg.pq.PGconn method): Objects wrapping libpq structures and functions.
                                                              (line  28)
* get_dumper_by_oid() (psycopg.adapt.AdaptersMap method): Other objects used in adaptations.
                                                              (line 132)
* get_dumper() (psycopg.adapt.AdaptersMap method): Other objects used in adaptations.
                                                              (line 116)
* get_key() (psycopg.abc.Dumper method): abc – Psycopg abstract classes.
                                                              (line  79)
* get_key() (psycopg.adapt.Dumper method): Dumpers and loaders.
                                                              (line  39)
* get_loader() (psycopg.adapt.AdaptersMap method): Other objects used in adaptations.
                                                              (line 147)
* get_oid() (psycopg.types.TypesRegistry method): Types information.
                                                              (line 147)
* get_parameters() (psycopg.ConnectionInfo method): Connection information.
                                                              (line  86)
* get_stats() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 265)
* get() (psycopg.types.TypesRegistry method): Types information.
                                                              (line 136)
* getconn() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 182)
* getconn() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 280)
* gevent:                                Interrupting async operations.
                                                              (line  26)
* gtrid (psycopg.Xid attribute):         Two-Phase Commit related objects.
                                                              (line  19)
* has_cancel_safe() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  68)
* has_encrypt_password() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  41)
* has_hostaddr() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  48)
* has_pipeline() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  55)
* has_send_close_prepared() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  85)
* has_set_trace_flags() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  61)
* has_stream_chunked() (psycopg.Capabilities method): Libpq capabilities information.
                                                              (line  78)
* host (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 106)
* hostaddr (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 116)
* hstore; Data types:                    Multirange adaptation.
                                                              (line  99)
* Identifier (class in psycopg.sql):     sql objects.         (line 154)
* IDLE (psycopg.pq.TransactionStatus attribute): Enumerations.
                                                              (line  53)
* idle in transaction:                   Geometry adaptation using Shapely.
                                                              (line  81)
* INERROR (psycopg.pq.TransactionStatus attribute): Enumerations.
                                                              (line  59)
* InFailedSqlTransaction:                Geometry adaptation using Shapely.
                                                              (line  82)
* info (psycopg.Connection attribute):   The Connection class.
                                                              (line 349)
* Integer; Adaptation:                   Booleans adaptation. (line  14)
* IntegrityError:                        DB-API exceptions.   (line  97)
* InterfaceError:                        DB-API exceptions.   (line  73)
* internal_position (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* INTERNAL_POSITION (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* internal_query (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* INTERNAL_QUERY (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* internal_size (psycopg.Column attribute): The description Column object.
                                                              (line  36)
* InternalError:                         DB-API exceptions.   (line 104)
* IntervalStyle:                         Dates and times limits in Python.
                                                              (line  24)
* INTRANS (psycopg.pq.TransactionStatus attribute): Enumerations.
                                                              (line  57)
* is_crdb() (psycopg.crdb.CrdbConnection class method): CockroachDB-specific objects.
                                                              (line  27)
* is_supported() (psycopg.Pipeline class method): Pipeline-related objects.
                                                              (line  20)
* isempty (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  48)
* isolation_level (psycopg.Connection attribute): The Connection class.
                                                              (line 292)
* IsolationLevel (class in psycopg):     Transaction-related objects.
                                                              (line   8)
* itersize (psycopg.ServerCursor attribute): The ServerCursor class.
                                                              (line 144)
* join() (psycopg.sql.Composed method):  sql objects.         (line 258)
* join() (psycopg.sql.SQL method):       sql objects.         (line 134)
* Json (class in psycopg.types.json):    JSON adapters.       (line   8)
* Jsonb (class in psycopg.types.json):   JSON adapters.       (line  11)
* kwargs_row() (in module psycopg.rows): rows – row factory implementations.
                                                              (line 116)
* labels (psycopg.types.enum.EnumInfo attribute): Enum adaptation.
                                                              (line  53)
* libpq:                                 pq – libpq wrapper module.
                                                              (line   6)
* LibpqWriter (class in psycopg.copy):   Writer objects.      (line  37)
* LISTEN; SQL command:                   Gevent support.      (line  17)
* LISTEN; SQL command <1>:               Server messages.     (line  51)
* Literal (class in psycopg.sql):        sql objects.         (line 183)
* load() (psycopg.abc.Loader method):    abc – Psycopg abstract classes.
                                                              (line 164)
* load() (psycopg.adapt.Loader method):  Dumpers and loaders. (line  68)
* Loader (class in psycopg.abc):         abc – Psycopg abstract classes.
                                                              (line 138)
* Loader (class in psycopg.adapt):       Dumpers and loaders. (line  60)
* lookup() (in module psycopg.errors):   SQLSTATE exceptions. (line  34)
* lower (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  52)
* lower_inc (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  60)
* lower_inf (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  68)
* make_conninfo() (in module psycopg.conninfo): conninfo – manipulate connection strings.
                                                              (line  32)
* max_size (psycopg_pool.ConnectionPool attribute): The ConnectionPool class.
                                                              (line 235)
* memoryview; Adaptation:                Strings adaptation.  (line  63)
* message_detail (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* MESSAGE_DETAIL (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* message_hint (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* MESSAGE_HINT (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* message_primary (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* MESSAGE_PRIMARY (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* min_size (psycopg_pool.ConnectionPool attribute): The ConnectionPool class.
                                                              (line 233)
* module; psycopg:                       The psycopg module.  (line  10)
* module; psycopg_pool:                  psycopg_pool – Connection pool implementations.
                                                              (line   6)
* module; psycopg._dns:                  _dns – DNS resolution utilities.
                                                              (line   6)
* module; psycopg.abc:                   abc – Psycopg abstract classes.
                                                              (line   9)
* module; psycopg.adapt:                 adapt – Types adaptation.
                                                              (line   6)
* module; psycopg.conninfo:              conninfo – manipulate connection strings.
                                                              (line   9)
* module; psycopg.crdb:                  crdb – CockroachDB support.
                                                              (line   6)
* module; psycopg.errors:                errors – Package exceptions.
                                                              (line   6)
* module; psycopg.pq:                    pq – libpq wrapper module.
                                                              (line   6)
* module; psycopg.rows:                  rows – row factory implementations.
                                                              (line   6)
* module; psycopg.sql:                   sql – SQL string composition.
                                                              (line   6)
* module; psycopg.types:                 types – Types information and adapters.
                                                              (line   6)
* mogrify() (psycopg.ClientCursor method): The ClientCursor class.
                                                              (line  23)
* Multirange (class in psycopg.types.multirange): Multirange adaptation.
                                                              (line  14)
* MultirangeInfo (class in psycopg.types.multirange): Multirange adaptation.
                                                              (line  48)
* name (psycopg_pool.ConnectionPool attribute): The ConnectionPool class.
                                                              (line 228)
* name (psycopg.Column attribute):       The description Column object.
                                                              (line  14)
* name (psycopg.ServerCursor attribute): The ServerCursor class.
                                                              (line  25)
* namedtuple_row() (in module psycopg.rows): rows – row factory implementations.
                                                              (line  41)
* namedtuple; Adaptation:                Adapting other PostgreSQL types.
                                                              (line  10)
* needs_password (psycopg.pq.PGconn attribute): Objects wrapping libpq structures and functions.
                                                              (line  35)
* News:                                  Release notes.       (line   6)
* News <1>:                              Psycopg 3 0b1.       (line   7)
* nextset() (psycopg.Cursor method):     The Cursor class.    (line 299)
* NO_ATTEMPT (psycopg.pq.Ping attribute): Enumerations.       (line 170)
* NO_RESPONSE (psycopg.pq.Ping attribute): Enumerations.      (line 168)
* NONFATAL_ERROR (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  84)
* notifies() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 141)
* notifies() (psycopg.Connection method): The Connection class.
                                                              (line 440)
* Notify (class in psycopg):             Notifications.       (line   6)
* NOTIFY; SQL command:                   Gevent support.      (line  16)
* NOTIFY; SQL command <1>:               Server messages.     (line  50)
* NotSupportedError:                     DB-API exceptions.   (line 118)
* NULL (in module psycopg.sql):          Utility functions.   (line  20)
* NullConnectionPool (class in psycopg_pool): Null connection pools<2>.
                                                              (line  16)
* Objects; Adaptation:                   Binary parameters and results.
                                                              (line  47)
* Objects; Adaptation <1>:               Enum adaptation.     (line 171)
* OFF (psycopg.pq.PipelineStatus attribute): Enumerations.    (line 107)
* oid (psycopg.abc.Dumper attribute):    abc – Psycopg abstract classes.
                                                              (line  64)
* OK (psycopg.pq.ConnStatus attribute):  Enumerations.        (line  21)
* OK (psycopg.pq.Ping attribute):        Enumerations.        (line 164)
* OK (psycopg.pq.PollingStatus attribute): Enumerations.      (line  42)
* ON (psycopg.pq.PipelineStatus attribute): Enumerations.     (line 109)
* open() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 102)
* open() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 173)
* OperationalError:                      DB-API exceptions.   (line  88)
* options (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 142)
* owner (psycopg.Xid attribute):         Two-Phase Commit related objects.
                                                              (line  38)
* parameter_status() (psycopg.ConnectionInfo method): Connection information.
                                                              (line 147)
* password (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 138)
* PATH:                                  Local installation.  (line  21)
* payload (psycopg.Notify attribute):    Notifications.       (line  17)
* PgBouncer:                             Server-side binding. (line  74)
* PgBouncer <1>:                         Client-side-binding cursors.
                                                              (line  58)
* PGcancel (class in psycopg.pq):        Objects wrapping libpq structures and functions.
                                                              (line 165)
* PGcancelConn (class in psycopg.pq):    Objects wrapping libpq structures and functions.
                                                              (line 136)
* PGconn (class in psycopg.pq):          Objects wrapping libpq structures and functions.
                                                              (line   8)
* pgconn (psycopg.Connection attribute): The Connection class.
                                                              (line 341)
* pgconn (psycopg.Error attribute):      DB-API exceptions.   (line  46)
* pgconn_ptr (psycopg.pq.PGconn attribute): Objects wrapping libpq structures and functions.
                                                              (line  12)
* PGCONNECT_TIMEOUT:                     Psycopg 3 1 15.      (line  12)
* PGGSSENCMODE:                          Psycopg 3 2 10.      (line  43)
* PGresult (class in psycopg.pq):        Objects wrapping libpq structures and functions.
                                                              (line 113)
* pgresult (psycopg.Cursor attribute):   The Cursor class.    (line 320)
* pgresult (psycopg.Error attribute):    DB-API exceptions.   (line  60)
* pgresult_ptr (psycopg.pq.PGresult attribute): Objects wrapping libpq structures and functions.
                                                              (line 117)
* pid (psycopg.Notify attribute):        Notifications.       (line  21)
* Ping (class in psycopg.pq):            Enumerations.        (line 155)
* Pipeline (class in psycopg):           Pipeline-related objects.
                                                              (line   8)
* PIPELINE_ABORTED (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  94)
* pipeline_status (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  50)
* PIPELINE_SYNC (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  92)
* pipeline() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  76)
* pipeline() (psycopg.Connection method): The Connection class.
                                                              (line 205)
* PipelineAborted:                       Other Psycopg errors.
                                                              (line  25)
* PipelineStatus (class in psycopg.pq):  Enumerations.        (line  98)
* Placeholder (class in psycopg.sql):    sql objects.         (line 206)
* PollingStatus (class in psycopg.pq):   Enumerations.        (line  25)
* PoolClosed (class in psycopg_pool):    Pool exceptions.     (line  12)
* PoolTimeout (class in psycopg_pool):   Pool exceptions.     (line   6)
* pop_stats() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 269)
* port (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 126)
* Portal:                                Simple query protocol.
                                                              (line  33)
* PostGIS; Data types:                   Hstore adaptation.   (line  58)
* precision (psycopg.Column attribute):  The description Column object.
                                                              (line  40)
* prepare_threshold (psycopg.Connection attribute): The Connection class.
                                                              (line 354)
* prepared (psycopg.Xid attribute):      Two-Phase Commit related objects.
                                                              (line  31)
* Prepared statements:                   Dumpers and loaders life cycle.
                                                              (line  57)
* prepared_max (psycopg.Connection attribute): The Connection class.
                                                              (line 368)
* ProgrammingError:                      DB-API exceptions.   (line 111)
* PSYCOPG_IMPL:                          Handling dependencies.
                                                              (line  25)
* PSYCOPG_IMPL <1>:                      pq module implementations.
                                                              (line  32)
* PSYCOPG_IMPL <2>:                      Module content.      (line  13)
* psycopg.types.shapely.register_shapely() (in module psycopg): Geometry adaptation using Shapely.
                                                              (line  25)
* psycopg2; Differences:                 Example copying a table across servers.
                                                              (line  25)
* putconn() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 194)
* putconn() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 292)
* PyFormat (class in psycopg.adapt):     Other objects used in adaptations.
                                                              (line   6)
* Python Enhancement Proposals; PEP 0484: Static Typing.      (line   6)
* Python Enhancement Proposals; PEP 475: Psycopg 3 1 13.      (line  11)
* Python Enhancement Proposals; PEP 675: Checking literal strings in queries.
                                                              (line   7)
* Python Enhancement Proposals; PEP 675 <1>: The Cursor class.
                                                              (line  77)
* Python Enhancement Proposals; PEP 675 <2>: sql objects.     (line  88)
* Python Enhancement Proposals; PEP 675 <3>: Psycopg 3 1.     (line  41)
* python_type (psycopg.types.composite.CompositeInfo attribute): Composite types casting.
                                                              (line  25)
* Query protocol; advanced:              Server-side binding. (line  73)
* Query protocol; simple:                Client-side-binding cursors.
                                                              (line  58)
* Query; Parameters:                     Connection logging.  (line  46)
* quote() (in module psycopg.sql):       Utility functions.   (line   6)
* quote() (psycopg.abc.Dumper method):   abc – Psycopg abstract classes.
                                                              (line  50)
* quote() (psycopg.adapt.Dumper method): Dumpers and loaders. (line  32)
* Range (class in psycopg.types.range):  Range adaptation.    (line  14)
* range; Data types:                     Composite types casting.
                                                              (line  95)
* range; Data types <1>:                 Range adaptation.    (line 128)
* RangeInfo (class in psycopg.types.range): Range adaptation. (line  84)
* RawCursor (class in psycopg):          The RawCursor and RawServerCursor class.
                                                              (line  11)
* RawServerCursor (class in psycopg):    The RawCursor and RawServerCursor class.
                                                              (line  21)
* READ_COMMITTED (psycopg.IsolationLevel attribute): Transaction-related objects.
                                                              (line  20)
* read_only (psycopg.Connection attribute): The Connection class.
                                                              (line 308)
* read_row() (psycopg.AsyncCopy method): Main Copy objects.   (line 153)
* read_row() (psycopg.Copy method):      Main Copy objects.   (line  65)
* READ_UNCOMMITTED (psycopg.IsolationLevel attribute): Transaction-related objects.
                                                              (line  18)
* read() (psycopg.AsyncCopy method):     Main Copy objects.   (line 132)
* read() (psycopg.Copy method):          Main Copy objects.   (line  44)
* READING (psycopg.pq.PollingStatus attribute): Enumerations. (line  38)
* register_composite() (in module psycopg.types.composite): Composite types casting.
                                                              (line  30)
* register_dumper() (psycopg.adapt.AdaptersMap method): Other objects used in adaptations.
                                                              (line  64)
* register_enum() (in module psycopg.types.enum): Enum adaptation.
                                                              (line  63)
* register_hstore() (in module psycopg.types.hstore): Hstore adaptation.
                                                              (line  26)
* register_loader() (psycopg.adapt.AdaptersMap method): Other objects used in adaptations.
                                                              (line  92)
* register_multirange() (in module psycopg.types.multirange): Multirange adaptation.
                                                              (line  58)
* register_range() (in module psycopg.types.range): Range adaptation.
                                                              (line  93)
* register() (psycopg.types.TypeInfo method): Types information.
                                                              (line  79)
* REGRESS_MODE (psycopg.pq.Trace attribute): Enumerations.    (line 183)
* REJECT (psycopg.pq.Ping attribute):    Enumerations.        (line 166)
* Release notes:                         Release notes.       (line   6)
* Release notes <1>:                     Psycopg 3 0b1.       (line   8)
* remove_notice_handler() (psycopg.Connection method): The Connection class.
                                                              (line 499)
* remove_notify_handler() (psycopg.Connection method): The Connection class.
                                                              (line 477)
* REPEATABLE_READ (psycopg.IsolationLevel attribute): Transaction-related objects.
                                                              (line  22)
* resize() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 157)
* resize() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 240)
* resize() (psycopg_pool.NullConnectionPool method): Null connection pools<2>.
                                                              (line  63)
* resolve_hostaddr_async() (in module psycopg._dns): _dns – DNS resolution utilities.
                                                              (line  90)
* resolve_srv_async() (in module psycopg._dns): _dns – DNS resolution utilities.
                                                              (line  61)
* resolve_srv() (in module psycopg._dns): _dns – DNS resolution utilities.
                                                              (line  20)
* RFC; RFC 2782:                         _dns – DNS resolution utilities.
                                                              (line  22)
* Rollback:                              Transaction-related objects.
                                                              (line  47)
* rollback() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  89)
* rollback() (psycopg.Connection method): The Connection class.
                                                              (line 235)
* row factories:                         Checking literal strings in queries.
                                                              (line  42)
* Row Factory:                           Row factories.       (line  63)
* Row Maker:                             Row factories.       (line  63)
* row_factory (psycopg.AsyncConnection attribute): The AsyncConnection class.
                                                              (line  68)
* row_factory (psycopg.Connection attribute): The Connection class.
                                                              (line 161)
* row_factory (psycopg.Cursor attribute): The Cursor class.   (line 260)
* rowcount (psycopg.Cursor attribute):   The Cursor class.    (line 348)
* RowFactory (class in psycopg.rows):    Formal rows protocols.
                                                              (line  28)
* RowMaker (class in psycopg.rows):      Formal rows protocols.
                                                              (line   9)
* rownumber (psycopg.Cursor attribute):  The Cursor class.    (line 356)
* rows() (psycopg.AsyncCopy method):     Main Copy objects.   (line 142)
* rows() (psycopg.Copy method):          Main Copy objects.   (line  53)
* savepoint_name (psycopg.Transaction attribute): Transaction-related objects.
                                                              (line  31)
* scalar_row() (in module psycopg.rows): rows – row factory implementations.
                                                              (line  55)
* scale (psycopg.Column attribute):      The description Column object.
                                                              (line  44)
* schema_name (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SCHEMA_NAME (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* scroll() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  99)
* scroll() (psycopg.AsyncServerCursor method): Async cursor classes.
                                                              (line 191)
* scroll() (psycopg.Cursor method):      The Cursor class.    (line 308)
* scroll() (psycopg.ServerCursor method): The ServerCursor class.
                                                              (line 149)
* scrollable (psycopg.ServerCursor attribute): The ServerCursor class.
                                                              (line  29)
* Security:                              execute arguments.   (line  90)
* SERIALIZABLE (psycopg.IsolationLevel attribute): Transaction-related objects.
                                                              (line  24)
* server_cursor_factory (psycopg.AsyncConnection attribute): The AsyncConnection class.
                                                              (line  63)
* server_cursor_factory (psycopg.Connection attribute): The Connection class.
                                                              (line 153)
* server_version (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  69)
* server_version (psycopg.crdb.CrdbConnectionInfo attribute): CockroachDB-specific objects.
                                                              (line  60)
* ServerCursor (class in psycopg):       The ServerCursor class.
                                                              (line  11)
* set_autocommit() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 162)
* set_autocommit() (psycopg.Connection method): The Connection class.
                                                              (line 282)
* set_deferrable() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 175)
* set_deferrable() (psycopg.Connection method): The Connection class.
                                                              (line 332)
* set_isolation_level() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 166)
* set_isolation_level() (psycopg.Connection method): The Connection class.
                                                              (line 301)
* set_json_dumps() (in module psycopg.types.json): JSON adapters.
                                                              (line  23)
* set_json_loads() (in module psycopg.types.json): JSON adapters.
                                                              (line  45)
* set_read_only() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 171)
* set_read_only() (psycopg.Connection method): The Connection class.
                                                              (line 317)
* set_trace_flags() (psycopg.pq.PGconn method): Objects wrapping libpq structures and functions.
                                                              (line  76)
* set_types() (psycopg.Copy method):     Main Copy objects.   (line  76)
* severity (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SEVERITY (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* severity_nonlocalized (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SEVERITY_NONLOCALIZED (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* SINGLE_TUPLE (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  90)
* source_file (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SOURCE_FILE (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* source_function (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SOURCE_FUNCTION (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* source_line (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SOURCE_LINE (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* SQL (class in psycopg.sql):            sql objects.         (line  61)
* SQL injection:                         execute arguments.   (line  89)
* sqlstate (psycopg.Error attribute):    DB-API exceptions.   (line  39)
* sqlstate (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* SQLSTATE (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* start() (psycopg.pq.PGcancelConn method): Objects wrapping libpq structures and functions.
                                                              (line 142)
* statement_position (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* STATEMENT_POSITION (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* status (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  25)
* statusmessage (psycopg.Cursor attribute): The Cursor class. (line 339)
* stream() (psycopg.AsyncCursor method): Async cursor classes.
                                                              (line  57)
* stream() (psycopg.Cursor method):      The Cursor class.    (line 173)
* Strings; Adaptation:                   Numbers adaptation.  (line  35)
* SUPPRESS_TIMESTAMPS (psycopg.pq.Trace attribute): Enumerations.
                                                              (line 181)
* sync() (psycopg.AsyncPipeline method): Pipeline-related objects.
                                                              (line  32)
* sync() (psycopg.Pipeline method):      Pipeline-related objects.
                                                              (line  15)
* table_name (psycopg.errors.Diagnostic attribute): Error diagnostics.
                                                              (line  22)
* TABLE_NAME (psycopg.pq.DiagnosticField attribute): Enumerations.
                                                              (line 131)
* TEXT (psycopg.adapt.PyFormat attribute): Other objects used in adaptations.
                                                              (line  15)
* TEXT (psycopg.pq.Format attribute):    Enumerations.        (line 121)
* threads:                               More advanced topics.
                                                              (line  10)
* timezone (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  99)
* TooManyRequests (class in psycopg_pool): Pool exceptions.   (line  18)
* tpc_begin() (psycopg.Connection method): The Connection class.
                                                              (line 539)
* tpc_commit() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 184)
* tpc_commit() (psycopg.Connection method): The Connection class.
                                                              (line 578)
* tpc_prepare() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 179)
* tpc_prepare() (psycopg.Connection method): The Connection class.
                                                              (line 561)
* tpc_recover() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 193)
* tpc_recover() (psycopg.Connection method): The Connection class.
                                                              (line 632)
* tpc_rollback() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line 188)
* tpc_rollback() (psycopg.Connection method): The Connection class.
                                                              (line 607)
* Trace (class in psycopg.pq):           Enumerations.        (line 172)
* trace() (psycopg.pq.PGconn method):    Objects wrapping libpq structures and functions.
                                                              (line  69)
* Transaction (class in psycopg):        Transaction-related objects.
                                                              (line  26)
* transaction_status (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  37)
* transaction() (psycopg.AsyncConnection method): The AsyncConnection class.
                                                              (line  93)
* transaction() (psycopg.Connection method): The Connection class.
                                                              (line 239)
* Transactions management:               Geometry adaptation using Shapely.
                                                              (line  82)
* TransactionStatus (class in psycopg.pq): Enumerations.      (line  44)
* Transformer (class in psycopg.adapt):  Other objects used in adaptations.
                                                              (line 161)
* tuple_row() (in module psycopg.rows):  rows – row factory implementations.
                                                              (line  13)
* tuple; Adaptation:                     Adapting other PostgreSQL types.
                                                              (line  10)
* TUPLES_CHUNK (psycopg.pq.ExecStatus attribute): Enumerations.
                                                              (line  96)
* TUPLES_OK (psycopg.pq.ExecStatus attribute): Enumerations.  (line  76)
* Two-phase commit; Transaction:         Transaction characteristics.
                                                              (line  39)
* type_code (psycopg.Column attribute):  The description Column object.
                                                              (line  18)
* type_display (psycopg.Column attribute): The description Column object.
                                                              (line  22)
* TypeInfo (class in psycopg.types):     Types information.   (line  47)
* types (psycopg.adapt.AdaptersMap attribute): Other objects used in adaptations.
                                                              (line 108)
* TypesRegistry (class in psycopg.types): Types information.  (line 105)
* Unicode; Adaptation:                   Numbers adaptation.  (line  35)
* UNKNOWN (psycopg.pq.TransactionStatus attribute): Enumerations.
                                                              (line  61)
* untrace() (psycopg.pq.PGconn method):  Objects wrapping libpq structures and functions.
                                                              (line  85)
* upgrade() (psycopg.abc.Dumper method): abc – Psycopg abstract classes.
                                                              (line 121)
* upgrade() (psycopg.adapt.Dumper method): Dumpers and loaders.
                                                              (line  50)
* upper (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  56)
* upper_inc (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  64)
* upper_inf (psycopg.types.range.Range attribute): Range adaptation.
                                                              (line  72)
* used_password (psycopg.pq.PGconn attribute): Objects wrapping libpq structures and functions.
                                                              (line  42)
* user (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line 134)
* vendor (psycopg.ConnectionInfo attribute): Connection information.
                                                              (line  60)
* vendor (psycopg.crdb.CrdbConnectionInfo attribute): CockroachDB-specific objects.
                                                              (line  56)
* version() (in module psycopg.pq):      Module content.      (line  15)
* wait() (psycopg_pool.AsyncConnectionPool method): The AsyncConnectionPool class.
                                                              (line 142)
* wait() (psycopg_pool.ConnectionPool method): The ConnectionPool class.
                                                              (line 213)
* wait() (psycopg_pool.NullConnectionPool method): Null connection pools<2>.
                                                              (line  52)
* Warning:                               DB-API exceptions.   (line  67)
* with:                                  Asynchronous operations.
                                                              (line  43)
* withhold (psycopg.ServerCursor attribute): The ServerCursor class.
                                                              (line  42)
* write_row() (psycopg.AsyncCopy method): Main Copy objects.  (line 120)
* write_row() (psycopg.Copy method):     Main Copy objects.   (line  28)
* write() (psycopg.AsyncCopy method):    Main Copy objects.   (line 124)
* write() (psycopg.Copy method):         Main Copy objects.   (line  36)
* write() (psycopg.copy.AsyncWriter method): Writer objects.  (line  68)
* write() (psycopg.copy.Writer method):  Writer objects.      (line  26)
* Writer (class in psycopg.copy):        Writer objects.      (line  19)
* WRITING (psycopg.pq.PollingStatus attribute): Enumerations. (line  40)
* Xid (class in psycopg):                Two-Phase Commit related objects.
                                                              (line   6)
* xid() (psycopg.Connection method):     The Connection class.
                                                              (line 527)


Tag Table:
Node: Top359
Ref: index doc565
Ref: c565
Ref: Top-Footnote-110800
Ref: Top-Footnote-210836
Ref: Top-Footnote-310868
Ref: Top-Footnote-410906
Node: Documentation10956
Ref: index db-api-2-011050
Ref: 1611050
Ref: index documentation11050
Ref: 1711050
Ref: index psycopg-3-postgresql-database-adapter-for-python11050
Ref: 1811050
Node: Getting started with Psycopg 311212
Ref: basic/index doc11322
Ref: 1911322
Ref: basic/index basic11322
Ref: 1a11322
Ref: basic/index getting-started-with-psycopg-311322
Ref: 1b11322
Node: Installation11975
Ref: basic/install doc12082
Ref: 1f12082
Ref: basic/install id112082
Ref: 2012082
Ref: basic/install installation12082
Ref: 1c12082
Node: Supported systems12654
Ref: basic/install id212749
Ref: 2312749
Ref: basic/install supported-systems12749
Ref: 2112749
Ref: Supported systems-Footnote-113892
Ref: Supported systems-Footnote-213947
Node: Binary installation13998
Ref: basic/install binary-install14120
Ref: 2414120
Ref: basic/install binary-installation14120
Ref: 2514120
Ref: Binary installation-Footnote-116114
Node: Local installation16169
Ref: basic/install id616298
Ref: 2b16298
Ref: basic/install local-installation16298
Ref: 2716298
Node: Pure Python installation17392
Ref: basic/install id717532
Ref: 2c17532
Ref: basic/install pure-python-installation17532
Ref: 2817532
Ref: Pure Python installation-Footnote-118446
Node: Installing the connection pool18514
Ref: basic/install installing-the-connection-pool18657
Ref: 2d18657
Ref: basic/install pool-installation18657
Ref: 2e18657
Node: Handling dependencies19130
Ref: basic/install handling-dependencies19240
Ref: 2f19240
Ref: Handling dependencies-Footnote-120479
Node: Basic module usage20551
Ref: basic/usage doc20700
Ref: 3020700
Ref: basic/usage basic-module-usage20700
Ref: 3120700
Ref: basic/usage module-usage20700
Ref: 2220700
Ref: Basic module usage-Footnote-121144
Ref: Basic module usage-Footnote-221194
Ref: Basic module usage-Footnote-321264
Node: Main objects in Psycopg 321329
Ref: basic/usage main-objects-in-psycopg-321428
Ref: 3221428
Ref: basic/usage usage21428
Ref: 1d21428
Ref: Main objects in Psycopg 3-Footnote-124339
Node: Shortcuts24409
Ref: basic/usage shortcuts24535
Ref: 4324535
Node: Connection context25758
Ref: basic/usage connection-context25891
Ref: 4525891
Ref: basic/usage with-connection25891
Ref: 4625891
Ref: Connection context-Footnote-128419
Node: Adapting psycopg to your program28472
Ref: basic/usage adapting-psycopg-to-your-program28614
Ref: 4c28614
Ref: Adapting psycopg to your program-Footnote-129453
Node: Connection logging29523
Ref: basic/usage connection-logging29638
Ref: 4f29638
Ref: basic/usage logging29638
Ref: 5029638
Ref: Connection logging-Footnote-132304
Ref: Connection logging-Footnote-232374
Node: Passing parameters to SQL queries32463
Ref: basic/params doc32627
Ref: 5132627
Ref: basic/params id232627
Ref: 5232627
Ref: basic/params passing-parameters-to-sql-queries32627
Ref: 5332627
Ref: basic/params query-parameters32627
Ref: 4032627
Node: execute arguments33112
Ref: basic/params execute-arguments33229
Ref: 5433229
Ref: basic/params sql-injection35434
Ref: 5535434
Ref: basic/params id135434
Ref: 5635434
Node: Danger SQL injection37289
Ref: basic/params danger-sql-injection37444
Ref: 5737444
Ref: Danger SQL injection-Footnote-140559
Ref: Danger SQL injection-Footnote-240611
Node: Binary parameters and results40641
Ref: basic/params binary-data40770
Ref: 1440770
Ref: basic/params binary-parameters-and-results40770
Ref: 5940770
Ref: Binary parameters and results-Footnote-142993
Node: Adapting basic Python types43062
Ref: basic/adapt doc43239
Ref: 5e43239
Ref: basic/adapt adapting-basic-python-types43239
Ref: 5f43239
Ref: basic/adapt types-adaptation43239
Ref: 4143239
Node: Booleans adaptation43904
Ref: basic/adapt adapt-bool44015
Ref: 6044015
Ref: basic/adapt booleans-adaptation44015
Ref: 6144015
Ref: Booleans adaptation-Footnote-144380
Ref: Booleans adaptation-Footnote-244442
Ref: Booleans adaptation-Footnote-344512
Node: Numbers adaptation44592
Ref: basic/adapt adapt-numbers44730
Ref: 6244730
Ref: basic/adapt numbers-adaptation44730
Ref: 6344730
Ref: Numbers adaptation-Footnote-146058
Ref: Numbers adaptation-Footnote-246136
Ref: Numbers adaptation-Footnote-346197
Ref: Numbers adaptation-Footnote-446260
Ref: Numbers adaptation-Footnote-546331
Ref: Numbers adaptation-Footnote-646413
Node: Strings adaptation46502
Ref: basic/adapt adapt-string46638
Ref: 6546638
Ref: basic/adapt strings-adaptation46638
Ref: 6646638
Ref: Strings adaptation-Footnote-149115
Ref: Strings adaptation-Footnote-249187
Ref: Strings adaptation-Footnote-349247
Ref: Strings adaptation-Footnote-449319
Ref: Strings adaptation-Footnote-549382
Node: Binary adaptation49444
Ref: basic/adapt adapt-binary49588
Ref: 6849588
Ref: basic/adapt binary-adaptation49588
Ref: 6949588
Ref: Binary adaptation-Footnote-150175
Ref: Binary adaptation-Footnote-250237
Ref: Binary adaptation-Footnote-350303
Ref: Binary adaptation-Footnote-450370
Node: Date/time types adaptation50439
Ref: basic/adapt adapt-date50580
Ref: 6a50580
Ref: basic/adapt date-time-types-adaptation50580
Ref: 6b50580
Ref: Date/time types adaptation-Footnote-153577
Ref: Date/time types adaptation-Footnote-253648
Ref: Date/time types adaptation-Footnote-353718
Ref: Date/time types adaptation-Footnote-453792
Ref: Date/time types adaptation-Footnote-553862
Ref: Date/time types adaptation-Footnote-653938
Ref: Date/time types adaptation-Footnote-754027
Ref: Date/time types adaptation-Footnote-854101
Ref: Date/time types adaptation-Footnote-954192
Ref: Date/time types adaptation-Footnote-1054266
Ref: Date/time types adaptation-Footnote-1154339
Node: Dates and times limits in Python54421
Ref: basic/adapt date-time-limits54560
Ref: 6d54560
Ref: basic/adapt dates-and-times-limits-in-python54560
Ref: 6e54560
Ref: Dates and times limits in Python-Footnote-155364
Ref: Dates and times limits in Python-Footnote-255436
Node: DateStyle and IntervalStyle limits55510
Ref: basic/adapt datestyle55649
Ref: 7155649
Ref: basic/adapt datestyle-and-intervalstyle-limits55649
Ref: 7255649
Ref: DateStyle and IntervalStyle limits-Footnote-156635
Ref: DateStyle and IntervalStyle limits-Footnote-256725
Node: JSON adaptation56819
Ref: basic/adapt adapt-json56959
Ref: 7356959
Ref: basic/adapt json-adaptation56959
Ref: 7456959
Ref: JSON adaptation-Footnote-159356
Ref: JSON adaptation-Footnote-259423
Ref: JSON adaptation-Footnote-359486
Node: Lists adaptation59549
Ref: basic/adapt adapt-list59678
Ref: 7959678
Ref: basic/adapt lists-adaptation59678
Ref: 7a59678
Ref: Lists adaptation-Footnote-160794
Ref: Lists adaptation-Footnote-260855
Ref: Lists adaptation-Footnote-360915
Node: UUID adaptation61006
Ref: basic/adapt adapt-uuid61149
Ref: 7b61149
Ref: basic/adapt uuid-adaptation61149
Ref: 7c61149
Ref: UUID adaptation-Footnote-161566
Ref: UUID adaptation-Footnote-261628
Node: Network data types adaptation61695
Ref: basic/adapt adapt-network61837
Ref: 7d61837
Ref: basic/adapt network-data-types-adaptation61837
Ref: 7e61837
Ref: Network data types adaptation-Footnote-162786
Ref: Network data types adaptation-Footnote-262860
Ref: Network data types adaptation-Footnote-362947
Ref: Network data types adaptation-Footnote-463027
Ref: Network data types adaptation-Footnote-563109
Ref: Network data types adaptation-Footnote-663189
Ref: Network data types adaptation-Footnote-763269
Ref: Network data types adaptation-Footnote-863351
Node: Enum adaptation63431
Ref: basic/adapt adapt-enum63549
Ref: 7f63549
Ref: basic/adapt enum-adaptation63549
Ref: 8063549
Ref: basic/adapt psycopg types enum EnumInfo65260
Ref: 8165260
Ref: basic/adapt psycopg types enum EnumInfo labels65584
Ref: 8665584
Ref: basic/adapt psycopg types enum EnumInfo enum65718
Ref: 8765718
Ref: basic/adapt psycopg types enum register_enum65873
Ref: 8265873
Ref: Enum adaptation-Footnote-169800
Ref: Enum adaptation-Footnote-269862
Node: Adapting other PostgreSQL types69936
Ref: basic/pgtypes doc70103
Ref: 8870103
Ref: basic/pgtypes adapting-other-postgresql-types70103
Ref: 8970103
Ref: basic/pgtypes extra-adaptation70103
Ref: 8a70103
Node: Composite types casting70473
Ref: basic/pgtypes adapt-composite70590
Ref: 8b70590
Ref: basic/pgtypes composite-types-casting70590
Ref: 8c70590
Ref: basic/pgtypes psycopg types composite CompositeInfo71051
Ref: 8d71051
Ref: basic/pgtypes psycopg types composite CompositeInfo python_type71446
Ref: 8f71446
Ref: basic/pgtypes psycopg types composite register_composite71618
Ref: 8e71618
Ref: Composite types casting-Footnote-174057
Ref: Composite types casting-Footnote-274133
Node: Range adaptation74216
Ref: basic/pgtypes adapt-range74363
Ref: 9074363
Ref: basic/pgtypes range-adaptation74363
Ref: 9174363
Ref: basic/pgtypes psycopg types range Range74812
Ref: 9274812
Ref: basic/pgtypes psycopg types range Range isempty76270
Ref: 9376270
Ref: basic/pgtypes psycopg types range Range lower76344
Ref: 9476344
Ref: basic/pgtypes psycopg types range Range upper76445
Ref: 9576445
Ref: basic/pgtypes psycopg types range Range lower_inc76546
Ref: 9676546
Ref: basic/pgtypes psycopg types range Range upper_inc76644
Ref: 9776644
Ref: basic/pgtypes psycopg types range Range lower_inf76742
Ref: 9876742
Ref: basic/pgtypes psycopg types range Range upper_inf76838
Ref: 9976838
Ref: basic/pgtypes psycopg types range RangeInfo77344
Ref: 9a77344
Ref: basic/pgtypes psycopg types range register_range77673
Ref: 9b77673
Ref: Range adaptation-Footnote-178958
Ref: Range adaptation-Footnote-279022
Ref: Range adaptation-Footnote-379091
Ref: Range adaptation-Footnote-479190
Node: Multirange adaptation79260
Ref: basic/pgtypes adapt-multirange79401
Ref: 9c79401
Ref: basic/pgtypes multirange-adaptation79401
Ref: 9d79401
Ref: basic/pgtypes psycopg types multirange Multirange79811
Ref: 9e79811
Ref: basic/pgtypes psycopg types multirange MultirangeInfo81438
Ref: 9f81438
Ref: basic/pgtypes psycopg types multirange register_multirange81813
Ref: a081813
Ref: Multirange adaptation-Footnote-183276
Ref: Multirange adaptation-Footnote-283340
Ref: Multirange adaptation-Footnote-383444
Ref: Multirange adaptation-Footnote-483540
Ref: Multirange adaptation-Footnote-583609
Node: Hstore adaptation83679
Ref: basic/pgtypes adapt-hstore83837
Ref: a183837
Ref: basic/pgtypes hstore-adaptation83837
Ref: a283837
Ref: basic/pgtypes psycopg types hstore register_hstore84818
Ref: a384818
Ref: Hstore adaptation-Footnote-185898
Node: Geometry adaptation using Shapely85965
Ref: basic/pgtypes adapt-shapely86093
Ref: a486093
Ref: basic/pgtypes geometry-adaptation-using-shapely86093
Ref: a586093
Ref: basic/pgtypes psycopg psycopg types shapely register_shapely87142
Ref: a687142
Ref: Geometry adaptation using Shapely-Footnote-189091
Ref: Geometry adaptation using Shapely-Footnote-289120
Ref: Geometry adaptation using Shapely-Footnote-389167
Ref: Geometry adaptation using Shapely-Footnote-489212
Node: Transactions management89297
Ref: basic/transactions doc89464
Ref: a789464
Ref: basic/transactions transactions89464
Ref: 4289464
Ref: basic/transactions transactions-management89464
Ref: a889464
Node: Autocommit transactions93589
Ref: basic/transactions autocommit93702
Ref: a993702
Ref: basic/transactions autocommit-transactions93702
Ref: ac93702
Ref: Autocommit transactions-Footnote-195214
Node: Transaction contexts95273
Ref: basic/transactions transaction-context95422
Ref: aa95422
Ref: basic/transactions transaction-contexts95422
Ref: ad95422
Node: Nested transactions98658
Ref: basic/transactions id298735
Ref: af98735
Ref: basic/transactions nested-transactions98735
Ref: ae98735
Ref: Nested transactions-Footnote-1101007
Node: Transaction characteristics101074
Ref: basic/transactions id4101233
Ref: b1101233
Ref: basic/transactions transaction-characteristics101233
Ref: b2101233
Ref: Transaction characteristics-Footnote-1102899
Ref: Transaction characteristics-Footnote-2102972
Ref: Transaction characteristics-Footnote-3103082
Node: Two-Phase Commit protocol support103173
Ref: basic/transactions two-phase-commit103303
Ref: bb103303
Ref: basic/transactions two-phase-commit-protocol-support103303
Ref: bc103303
Ref: Two-Phase Commit protocol support-Footnote-1105359
Ref: Two-Phase Commit protocol support-Footnote-2105447
Ref: Two-Phase Commit protocol support-Footnote-3105495
Node: Using COPY TO and COPY FROM105532
Ref: basic/copy doc105693
Ref: c5105693
Ref: basic/copy copy105693
Ref: e105693
Ref: basic/copy id10105693
Ref: c6105693
Ref: basic/copy using-copy-to-and-copy-from105693
Ref: c7105693
Ref: Using COPY TO and COPY FROM-Footnote-1107365
Node: Writing data row-by-row107427
Ref: basic/copy copy-in-row107547
Ref: ca107547
Ref: basic/copy writing-data-row-by-row107547
Ref: cb107547
Node: Reading data row-by-row108555
Ref: basic/copy copy-out-row108706
Ref: cd108706
Ref: basic/copy reading-data-row-by-row108706
Ref: ce108706
Node: Copying block-by-block109700
Ref: basic/copy copy-block109839
Ref: d1109839
Ref: basic/copy copying-block-by-block109839
Ref: d2109839
Node: Binary copy110978
Ref: basic/copy binary-copy111119
Ref: d4111119
Ref: basic/copy copy-binary111119
Ref: d5111119
Node: Asynchronous copy support112104
Ref: basic/copy asynchronous-copy-support112261
Ref: d6112261
Ref: basic/copy copy-async112261
Ref: d7112261
Node: Example copying a table across servers113016
Ref: basic/copy example-copying-a-table-across-servers113153
Ref: d9113153
Node: Differences from psycopg2114247
Ref: basic/from_pg2 doc114376
Ref: da114376
Ref: basic/from_pg2 differences-from-psycopg2114376
Ref: db114376
Ref: basic/from_pg2 from-psycopg2114376
Ref: 1e114376
Node: Server-side binding115436
Ref: basic/from_pg2 id1115550
Ref: dc115550
Ref: basic/from_pg2 server-side-binding115550
Ref: 11115550
Ref: Server-side binding-Footnote-1118347
Ref: Server-side binding-Footnote-2118437
Node: Extended query Protocol118519
Ref: basic/from_pg2 advanced-query-protocol118679
Ref: e0118679
Ref: basic/from_pg2 extended-query-protocol118679
Ref: e1118679
Ref: Extended query Protocol-Footnote-1119173
Ref: Extended query Protocol-Footnote-2119265
Node: Multiple statements in the same query119324
Ref: basic/from_pg2 multi-statements119515
Ref: e3119515
Ref: basic/from_pg2 multiple-statements-in-the-same-query119515
Ref: e4119515
Node: Multiple results returned from multiple statements121575
Ref: basic/from_pg2 multi-results121763
Ref: e5121763
Ref: basic/from_pg2 multiple-results-returned-from-multiple-statements121763
Ref: e6121763
Node: Different cast rules122767
Ref: basic/from_pg2 difference-cast-rules122951
Ref: e8122951
Ref: basic/from_pg2 different-cast-rules122951
Ref: e9122951
Node: You cannot use IN %s with a tuple123519
Ref: basic/from_pg2 in-and-tuple123673
Ref: ea123673
Ref: basic/from_pg2 you-cannot-use-in-s-with-a-tuple123673
Ref: eb123673
Ref: You cannot use IN %s with a tuple-Footnote-1124600
Node: You cannot use IS %s124691
Ref: basic/from_pg2 is-null124843
Ref: ec124843
Ref: basic/from_pg2 you-cannot-use-is-s124843
Ref: ed124843
Ref: You cannot use IS %s-Footnote-1126020
Node: Cursors subclasses126094
Ref: basic/from_pg2 cursors-subclasses126240
Ref: ee126240
Ref: basic/from_pg2 diff-cursors126240
Ref: ef126240
Ref: Cursors subclasses-Footnote-1127124
Ref: Cursors subclasses-Footnote-2127205
Ref: Cursors subclasses-Footnote-3127288
Node: Different adaptation system127365
Ref: basic/from_pg2 diff-adapt127519
Ref: f2127519
Ref: basic/from_pg2 different-adaptation-system127519
Ref: f3127519
Node: Copy is no longer file-based128166
Ref: basic/from_pg2 copy-is-no-longer-file-based128317
Ref: f4128317
Ref: basic/from_pg2 diff-copy128317
Ref: f5128317
Ref: Copy is no longer file-based-Footnote-1129002
Node: with connection129055
Ref: basic/from_pg2 diff-with129195
Ref: 3f129195
Ref: basic/from_pg2 with-connection129195
Ref: f6129195
Ref: with connection-Footnote-1129923
Node: callproc is gone129976
Ref: basic/from_pg2 callproc-is-gone130111
Ref: f7130111
Ref: basic/from_pg2 diff-callproc130111
Ref: f8130111
Node: client_encoding is gone130474
Ref: basic/from_pg2 client-encoding-is-gone130667
Ref: f9130667
Ref: basic/from_pg2 diff-client-encoding130667
Ref: fa130667
Node: Transaction characteristics attributes don’t affect autocommit sessions131127
Ref: basic/from_pg2 transaction-characteristics-and-autocommit131338
Ref: b3131338
Ref: basic/from_pg2 transaction-characteristics-attributes-don-t-affect-autocommit-sessions131338
Ref: fb131338
Ref: Transaction characteristics attributes don’t affect autocommit sessions-Footnote-1132073
Node: No default infinity dates handling132183
Ref: basic/from_pg2 infinity-datetime132396
Ref: fc132396
Ref: basic/from_pg2 no-default-infinity-dates-handling132396
Ref: fd132396
Ref: No default infinity dates handling-Footnote-1133571
Ref: No default infinity dates handling-Footnote-2133645
Ref: No default infinity dates handling-Footnote-3133719
Node: What’s new in Psycopg 3133791
Ref: basic/from_pg2 what-s-new-in-psycopg-3133922
Ref: fe133922
Ref: basic/from_pg2 whats-new133922
Ref: ff133922
Node: More advanced topics134341
Ref: advanced/index doc134473
Ref: 100134473
Ref: advanced/index advanced134473
Ref: 101134473
Ref: advanced/index more-advanced-topics134473
Ref: 102134473
Node: Concurrent operations134877
Ref: advanced/async doc134978
Ref: 103134978
Ref: advanced/async concurrency134978
Ref: 104134978
Ref: advanced/async concurrent-operations134978
Ref: 105134978
Ref: Concurrent operations-Footnote-1138150
Ref: Concurrent operations-Footnote-2138250
Node: Asynchronous operations138337
Ref: advanced/async async138450
Ref: d138450
Ref: advanced/async asynchronous-operations138450
Ref: 106138450
Ref: Asynchronous operations-Footnote-1140227
Ref: Asynchronous operations-Footnote-2140297
Ref: Asynchronous operations-Footnote-3140370
Ref: Asynchronous operations-Footnote-4140458
Ref: Asynchronous operations-Footnote-5140550
Ref: Asynchronous operations-Footnote-6140642
Node: with async connections140737
Ref: advanced/async async-with140888
Ref: 4b140888
Ref: advanced/async with-async-connections140888
Ref: 109140888
Node: Interrupting async operations142481
Ref: advanced/async async-ctrl-c142623
Ref: 10b142623
Ref: advanced/async interrupting-async-operations142623
Ref: 10c142623
Ref: Interrupting async operations-Footnote-1143848
Node: Gevent support143927
Ref: advanced/async gevent144062
Ref: 10e144062
Ref: advanced/async gevent-support144062
Ref: 10f144062
Ref: Gevent support-Footnote-1144608
Ref: Gevent support-Footnote-2144640
Ref: Gevent support-Footnote-3144708
Ref: Gevent support-Footnote-4144789
Node: Server messages144867
Ref: advanced/async async-messages144999
Ref: 110144999
Ref: advanced/async server-messages144999
Ref: 111144999
Ref: Server messages-Footnote-1147056
Ref: Server messages-Footnote-2147164
Ref: Server messages-Footnote-3147246
Node: Asynchronous notifications147346
Ref: advanced/async async-notify147488
Ref: 116147488
Ref: advanced/async asynchronous-notifications147488
Ref: 117147488
Ref: Asynchronous notifications-Footnote-1148658
Ref: Asynchronous notifications-Footnote-2148722
Ref: Asynchronous notifications-Footnote-3148786
Node: Notifies generator148850
Ref: advanced/async id10148958
Ref: 11b148958
Ref: advanced/async notifies-generator148958
Ref: 119148958
Ref: Notifies generator-Footnote-1151149
Node: Notifies handlers151204
Ref: advanced/async id11151312
Ref: 11f151312
Ref: advanced/async notifies-handlers151312
Ref: 11a151312
Node: Detecting disconnections152014
Ref: advanced/async detecting-disconnections152132
Ref: 121152132
Ref: advanced/async disconnections152132
Ref: 122152132
Ref: Detecting disconnections-Footnote-1154560
Ref: Detecting disconnections-Footnote-2154634
Ref: Detecting disconnections-Footnote-3154704
Ref: Detecting disconnections-Footnote-4154777
Node: Static Typing154867
Ref: advanced/typing doc154990
Ref: 124154990
Ref: advanced/typing id1154990
Ref: 125154990
Ref: advanced/typing static-typing154990
Ref: 10154990
Ref: Static Typing-Footnote-1155595
Ref: Static Typing-Footnote-2155637
Node: Generic types155667
Ref: advanced/typing generic-types155761
Ref: 126155761
Ref: advanced/typing mypy155761
Ref: 127155761
Ref: Generic types-Footnote-1156885
Node: Type of rows returned156954
Ref: advanced/typing row-factory-static157075
Ref: 128157075
Ref: advanced/typing type-of-rows-returned157075
Ref: 129157075
Node: Generic pool types157857
Ref: advanced/typing generic-pool-types158009
Ref: 12a158009
Ref: advanced/typing pool-generic158009
Ref: 12b158009
Node: Example returning records as Pydantic models159932
Ref: advanced/typing example-pydantic160098
Ref: 12e160098
Ref: advanced/typing example-returning-records-as-pydantic-models160098
Ref: 12f160098
Ref: Example returning records as Pydantic models-Footnote-1162106
Node: Checking literal strings in queries162151
Ref: advanced/typing checking-literal-strings-in-queries162290
Ref: 130162290
Ref: advanced/typing literal-string162290
Ref: 58162290
Ref: Checking literal strings in queries-Footnote-1164093
Ref: Checking literal strings in queries-Footnote-2164135
Ref: Checking literal strings in queries-Footnote-3164187
Ref: Checking literal strings in queries-Footnote-4164219
Node: Row factories164277
Ref: advanced/rows doc164395
Ref: 132164395
Ref: advanced/rows id1164395
Ref: 133164395
Ref: advanced/rows pyre164395
Ref: 134164395
Ref: advanced/rows row-factories164395
Ref: 4d164395
Node: Creating new row factories166787
Ref: advanced/rows creating-new-row-factories166864
Ref: 13a166864
Ref: advanced/rows row-factory-create166864
Ref: 139166864
Node: Connection pools168724
Ref: advanced/pool doc168841
Ref: 13f168841
Ref: advanced/pool connection-pools168841
Ref: f168841
Ref: advanced/pool id1168841
Ref: 140168841
Ref: Connection pools-Footnote-1169895
Node: Basic connection pool usage169949
Ref: advanced/pool basic-connection-pool-usage170057
Ref: 141170057
Node: Pool startup check172007
Ref: advanced/pool pool-startup-check172146
Ref: 143172146
Node: Connections life cycle172857
Ref: advanced/pool connections-life-cycle172996
Ref: 146172996
Node: Other ways to create a pool175223
Ref: advanced/pool other-ways-to-create-a-pool175365
Ref: 147175365
Ref: Other ways to create a pool-Footnote-1177734
Ref: Other ways to create a pool-Footnote-2177802
Node: Null connection pools177865
Ref: advanced/pool null-connection-pools178011
Ref: 14a178011
Ref: advanced/pool null-pool178011
Ref: 14b178011
Node: Pool connection and sizing180340
Ref: advanced/pool pool-connection-and-sizing180477
Ref: 14d180477
Ref: Pool connection and sizing-Footnote-1182194
Node: What’s the right size for the pool?182291
Ref: advanced/pool what-s-the-right-size-for-the-pool182392
Ref: 14e182392
Ref: What’s the right size for the pool?-Footnote-1182905
Node: Connection quality182981
Ref: advanced/pool connection-quality183120
Ref: 151183120
Ref: Connection quality-Footnote-1184288
Node: Pool operations logging184389
Ref: advanced/pool pool-logging184512
Ref: 153184512
Ref: advanced/pool pool-operations-logging184512
Ref: 154184512
Ref: Pool operations logging-Footnote-1187446
Node: Pool stats187516
Ref: advanced/pool id7187612
Ref: 155187612
Ref: advanced/pool pool-stats187612
Ref: 156187612
Ref: Pool stats-Footnote-1190383
Ref: Pool stats-Footnote-2190416
Node: Cursor types190447
Ref: advanced/cursors doc190580
Ref: 15b190580
Ref: advanced/cursors cursor-types190580
Ref: 15c190580
Ref: advanced/cursors id1190580
Ref: 15d190580
Ref: Cursor types-Footnote-1193570
Node: Client-side cursors193640
Ref: advanced/cursors client-side-cursors193745
Ref: 15e193745
Ref: advanced/cursors id2193745
Ref: 164193745
Node: Client-side-binding cursors194793
Ref: advanced/cursors client-side-binding-cursors194926
Ref: dd194926
Ref: advanced/cursors id3194926
Ref: 165194926
Ref: Client-side-binding cursors-Footnote-1197517
Node: Simple query protocol197582
Ref: advanced/cursors id4197668
Ref: 167197668
Ref: advanced/cursors simple-query-protocol197668
Ref: e2197668
Ref: Simple query protocol-Footnote-1198854
Ref: Simple query protocol-Footnote-2198949
Node: Server-side cursors199008
Ref: advanced/cursors id7199139
Ref: 168199139
Ref: advanced/cursors server-side-cursors199139
Ref: 160199139
Ref: Server-side cursors-Footnote-1200972
Ref: Server-side cursors-Footnote-2201037
Ref: Server-side cursors-Footnote-3201100
Node: “Stealing” an existing cursor201162
Ref: advanced/cursors cursor-steal201252
Ref: 16b201252
Ref: advanced/cursors stealing-an-existing-cursor201252
Ref: 16c201252
Ref: “Stealing” an existing cursor-Footnote-1202321
Node: Raw query cursors202390
Ref: advanced/cursors id9202485
Ref: 16e202485
Ref: advanced/cursors raw-query-cursors202485
Ref: 162202485
Node: Data adaptation configuration204038
Ref: advanced/adapt doc204174
Ref: 171204174
Ref: advanced/adapt adaptation204174
Ref: 4e204174
Ref: advanced/adapt data-adaptation-configuration204174
Ref: 172204174
Ref: Data adaptation configuration-Footnote-1207560
Node: Writing a custom adapter XML207639
Ref: advanced/adapt adapt-example-xml207783
Ref: 17b207783
Ref: advanced/adapt writing-a-custom-adapter-xml207783
Ref: 17c207783
Ref: Writing a custom adapter XML-Footnote-1210678
Ref: Writing a custom adapter XML-Footnote-2210744
Node: Example converting empty strings to NULL210843
Ref: advanced/adapt adapt-example-null-str211038
Ref: 180211038
Ref: advanced/adapt example-converting-empty-strings-to-null211038
Ref: 181211038
Node: Example PostgreSQL numeric to Python float211909
Ref: advanced/adapt adapt-example-float212106
Ref: 64212106
Ref: advanced/adapt example-postgresql-numeric-to-python-float212106
Ref: 182212106
Ref: Example PostgreSQL numeric to Python float-Footnote-1213429
Node: Example handling infinity date213500
Ref: advanced/adapt adapt-example-inf-date213687
Ref: 70213687
Ref: advanced/adapt example-handling-infinity-date213687
Ref: 183213687
Ref: Example handling infinity date-Footnote-1215512
Node: Dumpers and loaders life cycle215586
Ref: advanced/adapt dumpers-and-loaders-life-cycle215722
Ref: 184215722
Node: Prepared statements218415
Ref: advanced/prepare doc218560
Ref: 18b218560
Ref: advanced/prepare id1218560
Ref: 18c218560
Ref: advanced/prepare prepared-statements218560
Ref: 12218560
Ref: Prepared statements-Footnote-1220492
Ref: Prepared statements-Footnote-2220557
Ref: Prepared statements-Footnote-3220638
Node: Using prepared statements with PgBouncer220725
Ref: advanced/prepare pgbouncer220822
Ref: 18f220822
Ref: advanced/prepare using-prepared-statements-with-pgbouncer220822
Ref: 190220822
Ref: Using prepared statements with PgBouncer-Footnote-1222078
Ref: Using prepared statements with PgBouncer-Footnote-2222113
Ref: Using prepared statements with PgBouncer-Footnote-3222172
Node: Pipeline mode support222242
Ref: advanced/pipeline doc222349
Ref: 192222349
Ref: advanced/pipeline pipeline-mode222349
Ref: 13222349
Ref: advanced/pipeline pipeline-mode-support222349
Ref: 193222349
Ref: Pipeline mode support-Footnote-1224113
Ref: Pipeline mode support-Footnote-2224186
Node: Client-server messages flow224278
Ref: advanced/pipeline client-server-messages-flow224392
Ref: 195224392
Ref: Client-server messages flow-Footnote-1228974
Node: Pipeline mode usage229041
Ref: advanced/pipeline pipeline-mode-usage229186
Ref: 196229186
Ref: advanced/pipeline pipeline-usage229186
Ref: 197229186
Node: Synchronization points231250
Ref: advanced/pipeline pipeline-sync231383
Ref: 194231383
Ref: advanced/pipeline synchronization-points231383
Ref: 19c231383
Node: The fine prints234328
Ref: advanced/pipeline the-fine-prints234433
Ref: 19e234433
Node: Psycopg 3 API235206
Ref: api/index doc235321
Ref: 1a0235321
Ref: api/index psycopg-3-api235321
Ref: 1a1235321
Ref: api/index api235358
Ref: 1a2235358
Node: The psycopg module236147
Ref: api/module doc236243
Ref: 1a3236243
Ref: api/module the-psycopg-module236243
Ref: 1a4236243
Ref: api/module module-psycopg236456
Ref: 0236456
Ref: api/module psycopg connect236456
Ref: 48236456
Ref: api/module psycopg capabilities237079
Ref: 1a5237079
Ref: api/module psycopg adapters238372
Ref: 175238372
Ref: The psycopg module-Footnote-1239019
Ref: The psycopg module-Footnote-2239069
Ref: The psycopg module-Footnote-3239136
Node: Connection classes239197
Ref: api/connections doc239316
Ref: 1b1239316
Ref: api/connections connection-classes239316
Ref: 1b2239316
Node: The Connection class239909
Ref: api/connections the-connection-class240019
Ref: 1b3240019
Ref: api/connections psycopg Connection240086
Ref: 34240086
Ref: api/connections psycopg Connection connect240661
Ref: 33240661
Ref: api/connections psycopg Connection close242954
Ref: 49242954
Ref: api/connections psycopg Connection closed243277
Ref: 1b5243277
Ref: api/connections psycopg Connection broken243356
Ref: 1b6243356
Ref: api/connections psycopg Connection cursor243613
Ref: 37243613
Ref: api/connections psycopg Connection cursor_factory245304
Ref: df245304
Ref: api/connections psycopg Connection server_cursor_factory245530
Ref: 1b9245530
Ref: api/connections psycopg Connection row_factory245793
Ref: 135245793
Ref: api/connections psycopg Connection execute246257
Ref: 44246257
Ref: api/connections psycopg Connection pipeline247535
Ref: 198247535
Ref: api/connections psycopg Connection commit248384
Ref: 38248384
Ref: api/connections psycopg Connection rollback248479
Ref: 39248479
Ref: api/connections psycopg Connection transaction248579
Ref: 47248579
Ref: api/connections psycopg Connection autocommit249770
Ref: ab249770
Ref: api/connections psycopg Connection set_autocommit250035
Ref: 1bd250035
Ref: api/connections psycopg Connection isolation_level250339
Ref: b4250339
Ref: api/connections psycopg Connection set_isolation_level250615
Ref: b8250615
Ref: api/connections psycopg Connection read_only250808
Ref: b5250808
Ref: api/connections psycopg Connection set_read_only251078
Ref: 1be251078
Ref: api/connections psycopg Connection deferrable251234
Ref: b6251234
Ref: api/connections psycopg Connection set_deferrable251508
Ref: 1bf251508
Ref: api/connections psycopg Connection pgconn251769
Ref: 1c0251769
Ref: api/connections psycopg Connection info252061
Ref: 1c2252061
Ref: api/connections psycopg Connection prepare_threshold252181
Ref: 18d252181
Ref: api/connections psycopg Connection prepared_max252593
Ref: 18e252593
Ref: api/connections psycopg Connection cancel_safe253213
Ref: 1c4253213
Ref: api/connections psycopg Connection cancel254512
Ref: 10d254512
Ref: api/connections psycopg Connection notifies255348
Ref: 11c255348
Ref: api/connections psycopg Connection add_notify_handler256270
Ref: 120256270
Ref: api/connections psycopg Connection remove_notify_handler256719
Ref: 1c7256719
Ref: api/connections psycopg Connection add_notice_handler257046
Ref: 113257046
Ref: api/connections psycopg Connection remove_notice_handler257485
Ref: 1c8257485
Ref: api/connections psycopg Connection fileno257822
Ref: 123257822
Ref: api/connections tpc-methods258097
Ref: c4258097
Ref: api/connections psycopg Connection xid258338
Ref: bd258338
Ref: api/connections psycopg Connection tpc_begin258806
Ref: be258806
Ref: api/connections psycopg Connection tpc_prepare259743
Ref: bf259743
Ref: api/connections psycopg Connection tpc_commit260266
Ref: c0260266
Ref: api/connections psycopg Connection tpc_rollback261362
Ref: c1261362
Ref: api/connections psycopg Connection tpc_recover262224
Ref: c2262224
Ref: The Connection class-Footnote-1263295
Ref: The Connection class-Footnote-2263364
Ref: The Connection class-Footnote-3263434
Ref: The Connection class-Footnote-4263519
Ref: The Connection class-Footnote-5263607
Ref: The Connection class-Footnote-6263673
Ref: The Connection class-Footnote-7263735
Ref: The Connection class-Footnote-8263797
Ref: The Connection class-Footnote-9263907
Ref: The Connection class-Footnote-10264017
Ref: The Connection class-Footnote-11264129
Ref: The Connection class-Footnote-12264198
Ref: The Connection class-Footnote-13264267
Ref: The Connection class-Footnote-14264345
Ref: The Connection class-Footnote-15264435
Ref: The Connection class-Footnote-16264504
Ref: The Connection class-Footnote-17264580
Ref: The Connection class-Footnote-18264641
Ref: The Connection class-Footnote-19264727
Ref: The Connection class-Footnote-20264788
Ref: The Connection class-Footnote-21264870
Ref: The Connection class-Footnote-22264931
Ref: The Connection class-Footnote-23265015
Ref: The Connection class-Footnote-24265053
Node: The AsyncConnection class265138
Ref: api/connections the-asyncconnection-class265248
Ref: 1d1265248
Ref: api/connections psycopg AsyncConnection265325
Ref: 4a265325
Ref: api/connections psycopg AsyncConnection connect265792
Ref: 35265792
Ref: api/connections psycopg AsyncConnection close266551
Ref: 1d2266551
Ref: api/connections psycopg AsyncConnection cursor266887
Ref: 10a266887
Ref: api/connections psycopg AsyncConnection cursor_factory267423
Ref: 1d3267423
Ref: api/connections psycopg AsyncConnection server_cursor_factory267567
Ref: 1d4267567
Ref: api/connections psycopg AsyncConnection row_factory267730
Ref: 1d5267730
Ref: api/connections psycopg AsyncConnection execute267797
Ref: 1d7267797
Ref: api/connections psycopg AsyncConnection pipeline268046
Ref: 1d8268046
Ref: api/connections psycopg AsyncConnection commit268306
Ref: 1d9268306
Ref: api/connections psycopg AsyncConnection rollback268407
Ref: 1da268407
Ref: api/connections psycopg AsyncConnection transaction268513
Ref: 1db268513
Ref: api/connections psycopg AsyncConnection cancel_safe269332
Ref: 1dd269332
Ref: api/connections psycopg AsyncConnection notifies270194
Ref: 1de270194
Ref: api/connections psycopg AsyncConnection set_autocommit270949
Ref: 1bc270949
Ref: api/connections psycopg AsyncConnection set_isolation_level271073
Ref: b7271073
Ref: api/connections psycopg AsyncConnection set_read_only271239
Ref: 1df271239
Ref: api/connections psycopg AsyncConnection set_deferrable271368
Ref: 1e0271368
Ref: api/connections psycopg AsyncConnection tpc_prepare271499
Ref: 1e1271499
Ref: api/connections psycopg AsyncConnection tpc_commit271640
Ref: 1e2271640
Ref: api/connections psycopg AsyncConnection tpc_rollback271766
Ref: 1e3271766
Ref: api/connections psycopg AsyncConnection tpc_recover271912
Ref: 1e4271912
Ref: The AsyncConnection class-Footnote-1272000
Ref: The AsyncConnection class-Footnote-2272062
Node: Cursor classes272124
Ref: api/cursors doc272245
Ref: 1e5272245
Ref: api/cursors cursor-classes272245
Ref: 1e6272245
Node: The Cursor class273192
Ref: api/cursors the-cursor-class273291
Ref: 1e7273291
Ref: api/cursors psycopg Cursor273350
Ref: 36273350
Ref: api/cursors psycopg Cursor connection274039
Ref: 1e8274039
Ref: api/cursors psycopg Cursor close274142
Ref: 1e9274142
Ref: api/cursors psycopg Cursor closed274488
Ref: 1ea274488
Ref: api/cursors psycopg Cursor execute274621
Ref: 3a274621
Ref: api/cursors psycopg Cursor executemany276117
Ref: 3b276117
Ref: api/cursors psycopg Cursor copy279373
Ref: c8279373
Ref: api/cursors psycopg Cursor stream280194
Ref: 19b280194
Ref: api/cursors psycopg Cursor format282745
Ref: 1eb282745
Ref: api/cursors psycopg Cursor row_factory283873
Ref: 136283873
Ref: api/cursors psycopg Cursor fetchone284272
Ref: 3c284272
Ref: api/cursors psycopg Cursor fetchmany284525
Ref: 3d284525
Ref: api/cursors psycopg Cursor fetchall284822
Ref: 3e284822
Ref: api/cursors psycopg Cursor nextset285031
Ref: e7285031
Ref: api/cursors psycopg Cursor scroll285394
Ref: 16a285394
Ref: api/cursors psycopg Cursor pgresult285925
Ref: 13c285925
Ref: api/cursors psycopg Cursor description286349
Ref: 13b286349
Ref: api/cursors psycopg Cursor statusmessage286545
Ref: 1f0286545
Ref: api/cursors psycopg Cursor rowcount286872
Ref: 1ec286872
Ref: api/cursors psycopg Cursor rownumber287138
Ref: 1f1287138
Ref: api/cursors psycopg Cursor _query287288
Ref: 1f2287288
Ref: The Cursor class-Footnote-1288853
Ref: The Cursor class-Footnote-2288918
Ref: The Cursor class-Footnote-3288988
Ref: The Cursor class-Footnote-4289050
Ref: The Cursor class-Footnote-5289092
Ref: The Cursor class-Footnote-6289144
Ref: The Cursor class-Footnote-7289214
Ref: The Cursor class-Footnote-8289292
Ref: The Cursor class-Footnote-9289370
Node: The ClientCursor class289432
Ref: api/cursors the-clientcursor-class289562
Ref: 1f3289562
Ref: api/cursors psycopg ClientCursor289709
Ref: de289709
Ref: api/cursors psycopg ClientCursor mogrify290248
Ref: 1f4290248
Node: The ServerCursor class290804
Ref: api/cursors the-servercursor-class290957
Ref: 1f5290957
Ref: api/cursors psycopg ServerCursor291097
Ref: 15f291097
Ref: api/cursors psycopg ServerCursor name291832
Ref: 1f6291832
Ref: api/cursors psycopg ServerCursor scrollable291893
Ref: 1b7291893
Ref: api/cursors psycopg ServerCursor withhold292267
Ref: 1b8292267
Ref: api/cursors psycopg ServerCursor close292550
Ref: 1f8292550
Ref: api/cursors psycopg ServerCursor execute293148
Ref: 16d293148
Ref: api/cursors psycopg ServerCursor executemany294508
Ref: 1f9294508
Ref: api/cursors psycopg ServerCursor fetchone294692
Ref: 1fa294692
Ref: api/cursors psycopg ServerCursor fetchmany294929
Ref: 1fb294929
Ref: api/cursors psycopg ServerCursor fetchall295210
Ref: 1fc295210
Ref: api/cursors psycopg ServerCursor itersize295948
Ref: 1fd295948
Ref: api/cursors psycopg ServerCursor scroll296093
Ref: 1f7296093
Ref: The ServerCursor class-Footnote-1297224
Ref: The ServerCursor class-Footnote-2297289
Ref: The ServerCursor class-Footnote-3297354
Ref: The ServerCursor class-Footnote-4297419
Ref: The ServerCursor class-Footnote-5297482
Ref: The ServerCursor class-Footnote-6297543
Node: The RawCursor and RawServerCursor class297606
Ref: api/cursors the-rawcursor-and-rawservercursor-class297757
Ref: 1fe297757
Ref: api/cursors psycopg RawCursor297937
Ref: 161297937
Ref: api/cursors psycopg RawServerCursor298333
Ref: 163298333
Node: Async cursor classes298819
Ref: api/cursors async-cursor-classes298939
Ref: 1ff298939
Ref: api/cursors psycopg AsyncCursor299185
Ref: 107299185
Ref: api/cursors psycopg AsyncCursor connection299684
Ref: 200299684
Ref: api/cursors psycopg AsyncCursor close299744
Ref: 201299744
Ref: api/cursors psycopg AsyncCursor execute300053
Ref: 202300053
Ref: api/cursors psycopg AsyncCursor executemany300283
Ref: 203300283
Ref: api/cursors psycopg AsyncCursor copy300482
Ref: 204300482
Ref: api/cursors psycopg AsyncCursor stream300865
Ref: 205300865
Ref: api/cursors psycopg AsyncCursor fetchone301483
Ref: 206301483
Ref: api/cursors psycopg AsyncCursor fetchmany301726
Ref: 207301726
Ref: api/cursors psycopg AsyncCursor fetchall302013
Ref: 208302013
Ref: api/cursors psycopg AsyncCursor scroll302212
Ref: 209302212
Ref: api/cursors psycopg AsyncClientCursor302917
Ref: 166302917
Ref: api/cursors psycopg AsyncServerCursor303259
Ref: 169303259
Ref: api/cursors psycopg AsyncServerCursor close303906
Ref: 20a303906
Ref: api/cursors psycopg AsyncServerCursor execute304173
Ref: 20b304173
Ref: api/cursors psycopg AsyncServerCursor executemany304395
Ref: 20c304395
Ref: api/cursors psycopg AsyncServerCursor fetchone304585
Ref: 20d304585
Ref: api/cursors psycopg AsyncServerCursor fetchmany304828
Ref: 20e304828
Ref: api/cursors psycopg AsyncServerCursor fetchall305115
Ref: 20f305115
Ref: api/cursors psycopg AsyncServerCursor scroll305452
Ref: 210305452
Ref: api/cursors psycopg AsyncRawCursor306004
Ref: 16f306004
Ref: api/cursors psycopg AsyncRawServerCursor306342
Ref: 170306342
Node: COPY-related objects306784
Ref: api/copy doc306910
Ref: 211306910
Ref: api/copy copy-related-objects306910
Ref: 212306910
Node: Main Copy objects307458
Ref: api/copy main-copy-objects307556
Ref: 214307556
Ref: api/copy psycopg Copy307609
Ref: c9307609
Ref: api/copy psycopg Copy write_row308390
Ref: cc308390
Ref: api/copy psycopg Copy write308677
Ref: d3308677
Ref: api/copy psycopg Copy read308970
Ref: 215308970
Ref: api/copy psycopg Copy rows309287
Ref: cf309287
Ref: api/copy psycopg Copy read_row309699
Ref: 216309699
Ref: api/copy psycopg Copy set_types310072
Ref: d0310072
Ref: api/copy psycopg AsyncCopy310934
Ref: d8310934
Ref: api/copy psycopg AsyncCopy write_row311901
Ref: 217311901
Ref: api/copy psycopg AsyncCopy write312036
Ref: 218312036
Ref: api/copy psycopg AsyncCopy read312335
Ref: 219312335
Ref: api/copy psycopg AsyncCopy rows312679
Ref: 21a312679
Ref: api/copy psycopg AsyncCopy read_row313063
Ref: 21b313063
Ref: Main Copy objects-Footnote-1313474
Node: Writer objects313544
Ref: api/copy copy-writers313642
Ref: 21c313642
Ref: api/copy writer-objects313642
Ref: 21d313642
Ref: api/copy psycopg copy Writer314224
Ref: 21f314224
Ref: api/copy psycopg copy Writer write314438
Ref: 221314438
Ref: api/copy psycopg copy Writer finish314537
Ref: 222314537
Ref: api/copy psycopg copy LibpqWriter314750
Ref: 21e314750
Ref: api/copy psycopg copy FileWriter314943
Ref: 213314943
Ref: api/copy psycopg copy AsyncWriter315636
Ref: 220315636
Ref: api/copy psycopg copy AsyncWriter write315859
Ref: 223315859
Ref: api/copy psycopg copy AsyncWriter finish315964
Ref: 224315964
Ref: api/copy psycopg copy AsyncLibpqWriter316183
Ref: 225316183
Node: Other top-level objects316333
Ref: api/objects doc316475
Ref: 226316475
Ref: api/objects other-top-level-objects316475
Ref: 227316475
Node: Connection information316758
Ref: api/objects connection-information316880
Ref: 228316880
Ref: api/objects psycopg ConnectionInfo316943
Ref: 1c3316943
Ref: api/objects psycopg ConnectionInfo dsn317102
Ref: 229317102
Ref: api/objects psycopg ConnectionInfo status317650
Ref: 22c317650
Ref: api/objects psycopg ConnectionInfo transaction_status318216
Ref: 1cc318216
Ref: api/objects psycopg ConnectionInfo pipeline_status318809
Ref: 232318809
Ref: api/objects psycopg ConnectionInfo backend_pid318944
Ref: 233318944
Ref: api/objects psycopg ConnectionInfo vendor319098
Ref: 234319098
Ref: api/objects psycopg ConnectionInfo server_version319338
Ref: 235319338
Ref: api/objects psycopg ConnectionInfo error_message319845
Ref: 236319845
Ref: api/objects psycopg ConnectionInfo get_parameters320010
Ref: 22b320010
Ref: api/objects psycopg ConnectionInfo timezone320561
Ref: 6c320561
Ref: api/objects psycopg ConnectionInfo host320750
Ref: 237320750
Ref: api/objects psycopg ConnectionInfo hostaddr321113
Ref: 238321113
Ref: api/objects psycopg ConnectionInfo port321462
Ref: 23a321462
Ref: api/objects psycopg ConnectionInfo dbname321558
Ref: 23b321558
Ref: api/objects psycopg ConnectionInfo user321657
Ref: 23c321657
Ref: api/objects psycopg ConnectionInfo password321752
Ref: 22a321752
Ref: api/objects psycopg ConnectionInfo options321850
Ref: 23d321850
Ref: api/objects psycopg ConnectionInfo parameter_status321984
Ref: 23e321984
Ref: api/objects psycopg ConnectionInfo encoding322348
Ref: 67322348
Ref: Connection information-Footnote-1323091
Ref: Connection information-Footnote-2323168
Ref: Connection information-Footnote-3323256
Ref: Connection information-Footnote-4323348
Ref: Connection information-Footnote-5323429
Ref: Connection information-Footnote-6323513
Ref: Connection information-Footnote-7323596
Ref: Connection information-Footnote-8323670
Ref: Connection information-Footnote-9323749
Ref: Connection information-Footnote-10323823
Ref: Connection information-Footnote-11323896
Ref: Connection information-Footnote-12323972
Ref: Connection information-Footnote-13324048
Ref: Connection information-Footnote-14324127
Ref: Connection information-Footnote-15324190
Ref: Connection information-Footnote-16324277
Ref: Connection information-Footnote-17324355
Node: Libpq capabilities information324419
Ref: api/objects capabilities324579
Ref: 23f324579
Ref: api/objects libpq-capabilities-information324579
Ref: 240324579
Ref: api/objects psycopg Capabilities324658
Ref: 1a6324658
Ref: api/objects psycopg Capabilities has_encrypt_password326060
Ref: 241326060
Ref: api/objects psycopg Capabilities has_hostaddr326274
Ref: 239326274
Ref: api/objects psycopg Capabilities has_pipeline326487
Ref: 19f326487
Ref: api/objects psycopg Capabilities has_set_trace_flags326667
Ref: 242326667
Ref: api/objects psycopg Capabilities has_cancel_safe326888
Ref: 1c6326888
Ref: api/objects psycopg Capabilities has_stream_chunked327254
Ref: 1ed327254
Ref: api/objects psycopg Capabilities has_send_close_prepared327521
Ref: 191327521
Ref: Libpq capabilities information-Footnote-1327884
Node: The description Column object327961
Ref: api/objects the-description-column-object328112
Ref: 244328112
Ref: api/objects psycopg Column328197
Ref: 1ef328197
Ref: api/objects psycopg Column name328442
Ref: 245328442
Ref: api/objects psycopg Column type_code328503
Ref: 246328503
Ref: api/objects psycopg Column type_display328576
Ref: 247328576
Ref: api/objects psycopg Column display_size328876
Ref: 248328876
Ref: api/objects psycopg Column internal_size328980
Ref: 249328980
Ref: api/objects psycopg Column precision329088
Ref: 24a329088
Ref: api/objects psycopg Column scale329178
Ref: 24b329178
Ref: The description Column object-Footnote-1329311
Node: Notifications329373
Ref: api/objects notifications329518
Ref: 24c329518
Ref: api/objects psycopg Notify329563
Ref: 118329563
Ref: api/objects psycopg Notify channel329727
Ref: 24d329727
Ref: api/objects psycopg Notify payload329849
Ref: 24e329849
Ref: api/objects psycopg Notify pid329939
Ref: 24f329939
Ref: Notifications-Footnote-1330079
Ref: Notifications-Footnote-2330139
Ref: Notifications-Footnote-3330199
Node: Pipeline-related objects330260
Ref: api/objects pipeline-related-objects330403
Ref: 250330403
Ref: api/objects psycopg Pipeline330521
Ref: 199330521
Ref: api/objects psycopg Pipeline sync330730
Ref: 19d330730
Ref: api/objects psycopg Pipeline is_supported330876
Ref: 251330876
Ref: api/objects psycopg AsyncPipeline331022
Ref: 252331022
Ref: api/objects psycopg AsyncPipeline sync331247
Ref: 253331247
Node: Transaction-related objects331399
Ref: api/objects transaction-related-objects331561
Ref: 254331561
Ref: api/objects psycopg IsolationLevel331707
Ref: 255331707
Ref: api/objects psycopg IsolationLevel READ_UNCOMMITTED332041
Ref: 256332041
Ref: api/objects psycopg IsolationLevel READ_COMMITTED332083
Ref: 257332083
Ref: api/objects psycopg IsolationLevel REPEATABLE_READ332123
Ref: b9332123
Ref: api/objects psycopg IsolationLevel SERIALIZABLE332164
Ref: ba332164
Ref: api/objects psycopg Transaction332202
Ref: 1bb332202
Ref: api/objects psycopg Transaction savepoint_name332324
Ref: 258332324
Ref: api/objects psycopg Transaction connection332453
Ref: 259332453
Ref: api/objects psycopg AsyncTransaction332535
Ref: 1dc332535
Ref: api/objects psycopg AsyncTransaction connection332668
Ref: 25a332668
Ref: api/objects psycopg Rollback332700
Ref: b0332700
Ref: Transaction-related objects-Footnote-1333665
Node: Two-Phase Commit related objects333734
Ref: api/objects two-phase-commit-related-objects333863
Ref: 25b333863
Ref: api/objects psycopg Xid333946
Ref: c3333946
Ref: api/objects psycopg Xid format_id334209
Ref: 1c9334209
Ref: api/objects psycopg Xid gtrid334317
Ref: 1ca334317
Ref: api/objects psycopg Xid bqual334627
Ref: 1cb334627
Ref: api/objects psycopg Xid prepared334730
Ref: 1ce334730
Ref: api/objects psycopg Xid owner334951
Ref: 1cf334951
Ref: api/objects psycopg Xid database335116
Ref: 1d0335116
Ref: Two-Phase Commit related objects-Footnote-1335333
Ref: Two-Phase Commit related objects-Footnote-2335394
Ref: Two-Phase Commit related objects-Footnote-3335456
Ref: Two-Phase Commit related objects-Footnote-4335516
Ref: Two-Phase Commit related objects-Footnote-5335576
Ref: Two-Phase Commit related objects-Footnote-6335638
Ref: Two-Phase Commit related objects-Footnote-7335700
Ref: Two-Phase Commit related objects-Footnote-8335760
Ref: Two-Phase Commit related objects-Footnote-9335822
Ref: Two-Phase Commit related objects-Footnote-10335882
Node: sql – SQL string composition335945
Ref: api/sql doc336103
Ref: 25c336103
Ref: api/sql sql-sql-string-composition336103
Ref: 25d336103
Ref: api/sql module-psycopg sql336184
Ref: 9336184
Node: Module usage338194
Ref: api/sql module-usage338294
Ref: 25e338294
Node: sql objects339715
Ref: api/sql sql-objects339841
Ref: 263339841
Ref: api/sql psycopg sql Composable340478
Ref: 260340478
Ref: api/sql psycopg sql Composable as_string341119
Ref: 261341119
Ref: api/sql psycopg sql Composable as_bytes341691
Ref: 267341691
Ref: api/sql psycopg sql SQL342274
Ref: 131342274
Ref: api/sql psycopg sql SQL format343499
Ref: 25f343499
Ref: api/sql psycopg sql SQL join345285
Ref: 262345285
Ref: api/sql psycopg sql Identifier345994
Ref: 264345994
Ref: api/sql psycopg sql Literal347039
Ref: 265347039
Ref: api/sql psycopg sql Placeholder347895
Ref: 266347895
Ref: api/sql psycopg sql Composed349083
Ref: 1ba349083
Ref: api/sql psycopg sql Composed join350000
Ref: 268350000
Ref: sql objects-Footnote-1350531
Ref: sql objects-Footnote-2350595
Ref: sql objects-Footnote-3350651
Ref: sql objects-Footnote-4350715
Ref: sql objects-Footnote-5350771
Ref: sql objects-Footnote-6350847
Ref: sql objects-Footnote-7350889
Node: Utility functions350985
Ref: api/sql utility-functions351090
Ref: 269351090
Ref: api/sql psycopg sql quote351143
Ref: 26a351143
Ref: api/sql psycopg sql NULL351735
Ref: 26b351735
Ref: api/sql psycopg sql DEFAULT351762
Ref: 26c351762
Node: rows – row factory implementations351846
Ref: api/rows doc352010
Ref: 26d352010
Ref: api/rows module-psycopg rows352010
Ref: 8352010
Ref: api/rows psycopg-rows352010
Ref: 26e352010
Ref: api/rows rows-row-factory-implementations352010
Ref: 26f352010
Ref: api/rows psycopg rows tuple_row352371
Ref: 1b4352371
Ref: api/rows psycopg rows dict_row352838
Ref: f0352838
Ref: api/rows psycopg rows namedtuple_row353259
Ref: f1353259
Ref: api/rows psycopg rows scalar_row353736
Ref: 270353736
Ref: api/rows psycopg rows class_row354099
Ref: 137354099
Ref: api/rows psycopg rows args_row355282
Ref: 138355282
Ref: api/rows psycopg rows kwargs_row355621
Ref: 271355621
Ref: rows – row factory implementations-Footnote-1356028
Node: Formal rows protocols356111
Ref: api/rows formal-rows-protocols356206
Ref: 272356206
Ref: api/rows psycopg rows RowMaker356371
Ref: 13e356371
Ref: api/rows psycopg rows RowMaker __call__356872
Ref: 273356872
Ref: api/rows psycopg rows RowFactory357020
Ref: 13d357020
Ref: api/rows psycopg rows RowFactory __call__357638
Ref: 274357638
Ref: api/rows psycopg rows AsyncRowFactory357807
Ref: 1d6357807
Ref: api/rows psycopg rows BaseRowFactory357918
Ref: 275357918
Ref: Formal rows protocols-Footnote-1358338
Node: errors – Package exceptions358375
Ref: api/errors doc358557
Ref: 276358557
Ref: api/errors errors-package-exceptions358557
Ref: 277358557
Ref: api/errors module-psycopg errors358557
Ref: 6358557
Node: DB-API exceptions358785
Ref: api/errors db-api-exceptions358895
Ref: 278358895
Ref: api/errors dbapi-exceptions358895
Ref: 279358895
Ref: api/errors psycopg Error359553
Ref: 1a9359553
Ref: api/errors psycopg Error diag359852
Ref: 115359852
Ref: api/errors psycopg Error sqlstate359977
Ref: 27a359977
Ref: api/errors psycopg Error pgconn360216
Ref: 27b360216
Ref: api/errors psycopg Error pgresult360764
Ref: 27e360764
Ref: api/errors psycopg Warning360952
Ref: 1a8360952
Ref: api/errors psycopg InterfaceError361105
Ref: 1aa361105
Ref: api/errors psycopg DatabaseError361231
Ref: 112361231
Ref: api/errors psycopg DataError361337
Ref: 6f361337
Ref: api/errors psycopg OperationalError361503
Ref: 1ab361503
Ref: api/errors psycopg IntegrityError361860
Ref: 1ac361860
Ref: api/errors psycopg InternalError362037
Ref: 1ad362037
Ref: api/errors psycopg ProgrammingError362247
Ref: 1ae362247
Ref: api/errors psycopg NotSupportedError362474
Ref: 1af362474
Ref: DB-API exceptions-Footnote-1362672
Ref: DB-API exceptions-Footnote-2362732
Ref: DB-API exceptions-Footnote-3362794
Ref: DB-API exceptions-Footnote-4362856
Node: Other Psycopg errors362918
Ref: api/errors other-psycopg-errors362993
Ref: 27f362993
Ref: api/errors psycopg errors ConnectionTimeout363138
Ref: 280363138
Ref: api/errors psycopg errors CancellationTimeout363426
Ref: 1c5363426
Ref: api/errors psycopg errors PipelineAborted363615
Ref: 19a363615
Node: Error diagnostics363800
Ref: api/errors error-diagnostics363938
Ref: 281363938
Ref: api/errors psycopg errors Diagnostic363991
Ref: 114363991
Ref: api/errors psycopg errors Diagnostic column_name364603
Ref: 282364603
Ref: api/errors psycopg errors Diagnostic constraint_name364635
Ref: 283364635
Ref: api/errors psycopg errors Diagnostic context364671
Ref: 284364671
Ref: api/errors psycopg errors Diagnostic datatype_name364699
Ref: 285364699
Ref: api/errors psycopg errors Diagnostic internal_position364733
Ref: 286364733
Ref: api/errors psycopg errors Diagnostic internal_query364771
Ref: 287364771
Ref: api/errors psycopg errors Diagnostic message_detail364806
Ref: 288364806
Ref: api/errors psycopg errors Diagnostic message_hint364841
Ref: 289364841
Ref: api/errors psycopg errors Diagnostic message_primary364874
Ref: 28a364874
Ref: api/errors psycopg errors Diagnostic schema_name364910
Ref: 28b364910
Ref: api/errors psycopg errors Diagnostic severity364942
Ref: 28c364942
Ref: api/errors psycopg errors Diagnostic severity_nonlocalized364971
Ref: 28d364971
Ref: api/errors psycopg errors Diagnostic source_file365013
Ref: 28e365013
Ref: api/errors psycopg errors Diagnostic source_function365045
Ref: 28f365045
Ref: api/errors psycopg errors Diagnostic source_line365081
Ref: 290365081
Ref: api/errors psycopg errors Diagnostic sqlstate365113
Ref: 291365113
Ref: api/errors psycopg errors Diagnostic statement_position365142
Ref: 292365142
Ref: api/errors psycopg errors Diagnostic table_name365181
Ref: 293365181
Ref: Error diagnostics-Footnote-1365518
Node: SQLSTATE exceptions365603
Ref: api/errors id1365715
Ref: 294365715
Ref: api/errors sqlstate-exceptions365715
Ref: 1a7365715
Ref: api/errors psycopg errors lookup367117
Ref: 296367117
Ref: SQLSTATE exceptions-Footnote-1367778
Ref: SQLSTATE exceptions-Footnote-2367865
Node: List of known exceptions367952
Ref: api/errors exceptions-list368033
Ref: 295368033
Ref: api/errors list-of-known-exceptions368033
Ref: 297368033
Node: psycopg_pool – Connection pool implementations413092
Ref: api/pool doc413280
Ref: 298413280
Ref: api/pool psycopg-pool-connection-pool-implementations413280
Ref: 299413280
Ref: api/pool module-psycopg_pool413397
Ref: b413397
Ref: psycopg_pool – Connection pool implementations-Footnote-1415190
Node: The ConnectionPool class415260
Ref: api/pool the-connectionpool-class415394
Ref: 29b415394
Ref: api/pool psycopg_pool ConnectionPool415469
Ref: 12c415469
Ref: api/pool psycopg_pool ConnectionPool connection423226
Ref: 12d423226
Ref: api/pool psycopg_pool ConnectionPool open424206
Ref: 148424206
Ref: api/pool psycopg_pool ConnectionPool close425015
Ref: 149425015
Ref: api/pool psycopg_pool ConnectionPool wait425832
Ref: 145425832
Ref: api/pool psycopg_pool ConnectionPool name426493
Ref: 29f426493
Ref: api/pool psycopg_pool ConnectionPool min_size426625
Ref: 158426625
Ref: api/pool psycopg_pool ConnectionPool max_size426655
Ref: 159426655
Ref: api/pool psycopg_pool ConnectionPool resize426809
Ref: 150426809
Ref: api/pool psycopg_pool ConnectionPool check426957
Ref: 15a426957
Ref: api/pool psycopg_pool ConnectionPool check_connection427186
Ref: 152427186
Ref: api/pool psycopg_pool ConnectionPool get_stats427622
Ref: 14f427622
Ref: api/pool psycopg_pool ConnectionPool pop_stats427725
Ref: 157427725
Ref: api/pool psycopg_pool ConnectionPool getconn428032
Ref: 29c428032
Ref: api/pool psycopg_pool ConnectionPool putconn428528
Ref: 2a0428528
Ref: The ConnectionPool class-Footnote-1428869
Node: Pool exceptions428929
Ref: api/pool pool-exceptions429101
Ref: 2a1429101
Ref: api/pool psycopg_pool PoolTimeout429150
Ref: 144429150
Ref: api/pool psycopg_pool PoolClosed429301
Ref: 29e429301
Ref: api/pool psycopg_pool TooManyRequests429438
Ref: 29d429438
Node: The AsyncConnectionPool class429608
Ref: api/pool the-asyncconnectionpool-class429780
Ref: 2a2429780
Ref: api/pool psycopg_pool AsyncConnectionPool430260
Ref: 142430260
Ref: api/pool psycopg_pool AsyncConnectionPool connection433408
Ref: 2a3433408
Ref: api/pool psycopg_pool AsyncConnectionPool open434240
Ref: 2a4434240
Ref: api/pool psycopg_pool AsyncConnectionPool close435007
Ref: 2a6435007
Ref: api/pool psycopg_pool AsyncConnectionPool wait435934
Ref: 2a5435934
Ref: api/pool psycopg_pool AsyncConnectionPool resize436595
Ref: 2a7436595
Ref: api/pool psycopg_pool AsyncConnectionPool check436749
Ref: 2a8436749
Ref: api/pool psycopg_pool AsyncConnectionPool check_connection436984
Ref: 2a9436984
Ref: api/pool psycopg_pool AsyncConnectionPool getconn437427
Ref: 2aa437427
Ref: api/pool psycopg_pool AsyncConnectionPool putconn437930
Ref: 2ab437930
Node: Null connection pools<2>438242
Ref: api/pool null-connection-pools438390
Ref: 2ac438390
Ref: api/pool psycopg_pool NullConnectionPool438845
Ref: 14c438845
Ref: api/pool psycopg_pool NullConnectionPool wait440593
Ref: 2ad440593
Ref: api/pool psycopg_pool NullConnectionPool resize440975
Ref: 2ae440975
Ref: api/pool psycopg_pool NullConnectionPool check441192
Ref: 2af441192
Ref: api/pool psycopg_pool AsyncNullConnectionPool441460
Ref: 29a441460
Node: conninfo – manipulate connection strings442763
Ref: api/conninfo doc442948
Ref: 2b0442948
Ref: api/conninfo conninfo-manipulate-connection-strings442948
Ref: 2b1442948
Ref: api/conninfo psycopg-conninfo442948
Ref: 2b2442948
Ref: api/conninfo module-psycopg conninfo443144
Ref: 4443144
Ref: api/conninfo psycopg conninfo conninfo_to_dict443144
Ref: 2b3443144
Ref: api/conninfo psycopg conninfo make_conninfo443895
Ref: 2b4443895
Ref: conninfo – manipulate connection strings-Footnote-1444632
Ref: conninfo – manipulate connection strings-Footnote-2444717
Node: adapt – Types adaptation444802
Ref: api/adapt doc444979
Ref: 2b5444979
Ref: api/adapt adapt-types-adaptation444979
Ref: 2b6444979
Ref: api/adapt module-psycopg adapt444979
Ref: 3444979
Node: Dumpers and loaders445669
Ref: api/adapt abstract-base-class445794
Ref: 2b7445794
Ref: api/adapt dumpers-and-loaders445794
Ref: 2b8445794
Ref: api/adapt psycopg adapt Dumper445853
Ref: 5c445853
Ref: api/adapt psycopg adapt Dumper dump446205
Ref: 2b9446205
Ref: api/adapt psycopg adapt Dumper format446564
Ref: 2ba446564
Ref: api/adapt psycopg adapt Dumper quote446785
Ref: 2bb446785
Ref: api/adapt psycopg adapt Dumper get_key447118
Ref: 2bc447118
Ref: api/adapt psycopg adapt Dumper upgrade447619
Ref: 2bd447619
Ref: api/adapt psycopg adapt Loader448012
Ref: 5d448012
Ref: api/adapt psycopg adapt Loader load448354
Ref: 2be448354
Ref: api/adapt psycopg adapt Loader format448505
Ref: 2bf448505
Ref: Dumpers and loaders-Footnote-1448764
Ref: Dumpers and loaders-Footnote-2448835
Node: Other objects used in adaptations448906
Ref: api/adapt other-objects-used-in-adaptations449031
Ref: 2c0449031
Ref: api/adapt psycopg adapt PyFormat449118
Ref: 2c1449118
Ref: api/adapt psycopg adapt PyFormat AUTO449331
Ref: 185449331
Ref: api/adapt psycopg adapt PyFormat TEXT449363
Ref: 2c2449363
Ref: api/adapt psycopg adapt PyFormat BINARY449395
Ref: 2c3449395
Ref: api/adapt psycopg adapt AdaptersMap449429
Ref: 176449429
Ref: api/adapt psycopg adapt AdaptersMap register_dumper451441
Ref: 186451441
Ref: api/adapt psycopg adapt AdaptersMap register_loader452637
Ref: 2c5452637
Ref: api/adapt psycopg adapt AdaptersMap types453134
Ref: 1b0453134
Ref: api/adapt psycopg adapt AdaptersMap get_dumper453352
Ref: 2c6453352
Ref: api/adapt psycopg adapt AdaptersMap get_dumper_by_oid453816
Ref: 2c4453816
Ref: api/adapt psycopg adapt AdaptersMap get_loader454202
Ref: 2c7454202
Ref: api/adapt psycopg adapt Transformer454545
Ref: 17a454545
Node: types – Types information and adapters455048
Ref: api/types doc455215
Ref: 2c8455215
Ref: api/types module-psycopg types455215
Ref: a455215
Ref: api/types psycopg-types455215
Ref: 2c9455215
Ref: api/types types-types-information-and-adapters455215
Ref: 2ca455215
Node: Types information455865
Ref: api/types types-information455982
Ref: 2cb455982
Ref: api/types psycopg types TypeInfo457660
Ref: 85457660
Ref: api/types psycopg types TypeInfo fetch457950
Ref: 83457950
Ref: api/types psycopg types TypeInfo register458777
Ref: 84458777
Ref: api/types psycopg types TypesRegistry460011
Ref: 17f460011
Ref: api/types psycopg types TypesRegistry __getitem__460496
Ref: 2cc460496
Ref: api/types psycopg types TypesRegistry get461049
Ref: 2cd461049
Ref: api/types psycopg types TypesRegistry get_oid461377
Ref: 2ce461377
Ref: api/types psycopg types TypesRegistry get_by_subtype461750
Ref: 2cf461750
Node: JSON adapters462417
Ref: api/types id1462534
Ref: 2d0462534
Ref: api/types json-adapters462534
Ref: 2d1462534
Ref: api/types psycopg types json Json462626
Ref: 75462626
Ref: api/types psycopg types json Jsonb462734
Ref: 76462734
Ref: api/types psycopg types json set_json_dumps463157
Ref: 77463157
Ref: api/types psycopg types json set_json_loads463942
Ref: 78463942
Ref: JSON adapters-Footnote-1464631
Ref: JSON adapters-Footnote-2464694
Node: abc – Psycopg abstract classes464757
Ref: api/abc doc464925
Ref: 2d2464925
Ref: api/abc abc-psycopg-abstract-classes464925
Ref: 2d3464925
Ref: api/abc module-psycopg abc465096
Ref: 2465096
Ref: api/abc psycopg abc Dumper465096
Ref: 177465096
Ref: api/abc psycopg abc Dumper format465797
Ref: 2d4465797
Ref: api/abc psycopg abc Dumper dump466004
Ref: 17e466004
Ref: api/abc psycopg abc Dumper quote466449
Ref: 2d5466449
Ref: api/abc psycopg abc Dumper oid466983
Ref: 179466983
Ref: api/abc psycopg abc Dumper get_key467577
Ref: 187467577
Ref: api/abc psycopg abc Dumper upgrade469343
Ref: 188469343
Ref: api/abc psycopg abc Loader469956
Ref: 178469956
Ref: api/abc psycopg abc Loader format470644
Ref: 2d6470644
Ref: api/abc psycopg abc Loader load470854
Ref: 17d470854
Ref: api/abc psycopg abc AdaptContext471068
Ref: 174471068
Ref: api/abc psycopg abc AdaptContext adapters471585
Ref: 173471585
Ref: api/abc psycopg abc AdaptContext connection471700
Ref: 2d7471700
Ref: abc – Psycopg abstract classes-Footnote-1471960
Ref: abc – Psycopg abstract classes-Footnote-2472022
Ref: abc – Psycopg abstract classes-Footnote-3472083
Ref: abc – Psycopg abstract classes-Footnote-4472153
Ref: abc – Psycopg abstract classes-Footnote-5472227
Ref: abc – Psycopg abstract classes-Footnote-6472288
Ref: abc – Psycopg abstract classes-Footnote-7472358
Node: pq – libpq wrapper module472420
Ref: api/pq doc472576
Ref: 2d8472576
Ref: api/pq pq-libpq-wrapper-module472576
Ref: 2d9472576
Ref: api/pq psycopg-pq472576
Ref: 15472576
Ref: api/pq module-psycopg pq472653
Ref: 7472653
Ref: pq – libpq wrapper module-Footnote-1473079
Node: pq module implementations473138
Ref: api/pq pq-impl473251
Ref: 26473251
Ref: api/pq pq-module-implementations473251
Ref: 2da473251
Ref: pq module implementations-Footnote-1475054
Ref: pq module implementations-Footnote-2475122
Node: Module content475150
Ref: api/pq module-content475319
Ref: 2dc475319
Ref: api/pq psycopg pq __impl__475368
Ref: 2db475368
Ref: api/pq psycopg pq version475671
Ref: 29475671
Ref: api/pq psycopg pq __build_version__476008
Ref: 2a476008
Ref: api/pq psycopg pq error_message476371
Ref: 2dd476371
Ref: Module content-Footnote-1476886
Ref: Module content-Footnote-2476946
Ref: Module content-Footnote-3477025
Node: Objects wrapping libpq structures and functions477086
Ref: api/pq objects-wrapping-libpq-structures-and-functions477242
Ref: 2df477242
Ref: api/pq psycopg pq PGconn477390
Ref: 1c1477390
Ref: api/pq psycopg pq PGconn pgconn_ptr477471
Ref: 2e0477471
Ref: api/pq psycopg pq PGconn cancel_conn477831
Ref: 2e1477831
Ref: api/pq psycopg pq PGconn get_cancel478004
Ref: 2e2478004
Ref: api/pq psycopg pq PGconn needs_password478184
Ref: 27c478184
Ref: api/pq psycopg pq PGconn used_password478394
Ref: 27d478394
Ref: api/pq psycopg pq PGconn encrypt_password478564
Ref: 2e3478564
Ref: api/pq psycopg pq PGconn change_password478995
Ref: 2e4478995
Ref: api/pq psycopg pq PGconn trace479266
Ref: 2e5479266
Ref: api/pq psycopg pq PGconn set_trace_flags479446
Ref: 243479446
Ref: api/pq psycopg pq PGconn untrace479693
Ref: 2e6479693
Ref: api/pq psycopg pq PGresult480894
Ref: 189480894
Ref: api/pq psycopg pq PGresult pgresult_ptr480973
Ref: 2e7480973
Ref: api/pq psycopg pq Conninfo481346
Ref: 2e8481346
Ref: api/pq psycopg pq Escaping481433
Ref: 2e9481433
Ref: api/pq psycopg pq PGcancelConn481556
Ref: 2de481556
Ref: api/pq psycopg pq PGcancelConn start481700
Ref: 2ea481700
Ref: api/pq psycopg pq PGcancelConn blocking481902
Ref: 2eb481902
Ref: api/pq psycopg pq PGcancelConn finish482106
Ref: 2ec482106
Ref: api/pq psycopg pq PGcancel482397
Ref: 2ed482397
Ref: api/pq psycopg pq PGcancel free482539
Ref: 2ee482539
Ref: api/pq psycopg pq PGcancel cancel482821
Ref: 2ef482821
Ref: Objects wrapping libpq structures and functions-Footnote-1483031
Ref: Objects wrapping libpq structures and functions-Footnote-2483099
Ref: Objects wrapping libpq structures and functions-Footnote-3483182
Ref: Objects wrapping libpq structures and functions-Footnote-4483262
Ref: Objects wrapping libpq structures and functions-Footnote-5483356
Ref: Objects wrapping libpq structures and functions-Footnote-6483449
Ref: Objects wrapping libpq structures and functions-Footnote-7483537
Ref: Objects wrapping libpq structures and functions-Footnote-8483620
Ref: Objects wrapping libpq structures and functions-Footnote-9483697
Ref: Objects wrapping libpq structures and functions-Footnote-10483782
Ref: Objects wrapping libpq structures and functions-Footnote-11483862
Ref: Objects wrapping libpq structures and functions-Footnote-12483931
Ref: Objects wrapping libpq structures and functions-Footnote-13484014
Ref: Objects wrapping libpq structures and functions-Footnote-14484100
Ref: Objects wrapping libpq structures and functions-Footnote-15484184
Ref: Objects wrapping libpq structures and functions-Footnote-16484265
Ref: Objects wrapping libpq structures and functions-Footnote-17484347
Node: Enumerations484425
Ref: api/pq enumerations484558
Ref: 2f0484558
Ref: api/pq psycopg pq ConnStatus484603
Ref: 2f1484603
Ref: api/pq psycopg pq ConnStatus OK485118
Ref: 22d485118
Ref: api/pq psycopg pq ConnStatus BAD485146
Ref: 22e485146
Ref: api/pq psycopg pq PollingStatus485175
Ref: 2f2485175
Ref: api/pq psycopg pq PollingStatus FAILED485444
Ref: 2f3485444
Ref: api/pq psycopg pq PollingStatus READING485476
Ref: 2f4485476
Ref: api/pq psycopg pq PollingStatus WRITING485509
Ref: 2f5485509
Ref: api/pq psycopg pq PollingStatus OK485542
Ref: 2f6485542
Ref: api/pq psycopg pq TransactionStatus485570
Ref: 2f7485570
Ref: api/pq psycopg pq TransactionStatus IDLE485766
Ref: 1cd485766
Ref: api/pq psycopg pq TransactionStatus ACTIVE485796
Ref: 1ee485796
Ref: api/pq psycopg pq TransactionStatus INTRANS485828
Ref: 22f485828
Ref: api/pq psycopg pq TransactionStatus INERROR485861
Ref: 230485861
Ref: api/pq psycopg pq TransactionStatus UNKNOWN485894
Ref: 231485894
Ref: api/pq psycopg pq ExecStatus485927
Ref: 2f8485927
Ref: api/pq psycopg pq ExecStatus EMPTY_QUERY486096
Ref: 2f9486096
Ref: api/pq psycopg pq ExecStatus COMMAND_OK486133
Ref: 2fa486133
Ref: api/pq psycopg pq ExecStatus TUPLES_OK486169
Ref: 2fb486169
Ref: api/pq psycopg pq ExecStatus COPY_OUT486204
Ref: 2fc486204
Ref: api/pq psycopg pq ExecStatus COPY_IN486238
Ref: 2fd486238
Ref: api/pq psycopg pq ExecStatus BAD_RESPONSE486271
Ref: 2fe486271
Ref: api/pq psycopg pq ExecStatus NONFATAL_ERROR486309
Ref: 2ff486309
Ref: api/pq psycopg pq ExecStatus FATAL_ERROR486349
Ref: 300486349
Ref: api/pq psycopg pq ExecStatus COPY_BOTH486386
Ref: 301486386
Ref: api/pq psycopg pq ExecStatus SINGLE_TUPLE486421
Ref: 302486421
Ref: api/pq psycopg pq ExecStatus PIPELINE_SYNC486459
Ref: 303486459
Ref: api/pq psycopg pq ExecStatus PIPELINE_ABORTED486499
Ref: 304486499
Ref: api/pq psycopg pq ExecStatus TUPLES_CHUNK486542
Ref: 305486542
Ref: api/pq psycopg pq PipelineStatus486581
Ref: 306486581
Ref: api/pq psycopg pq PipelineStatus OFF486777
Ref: 307486777
Ref: api/pq psycopg pq PipelineStatus ON486806
Ref: 308486806
Ref: api/pq psycopg pq PipelineStatus ABORTED486834
Ref: 309486834
Ref: api/pq psycopg pq Format486867
Ref: 18a486867
Ref: api/pq psycopg pq Format TEXT487152
Ref: 5a487152
Ref: api/pq psycopg pq Format BINARY487182
Ref: 5b487182
Ref: api/pq psycopg pq DiagnosticField487214
Ref: 30a487214
Ref: api/pq psycopg pq DiagnosticField SEVERITY487324
Ref: 30b487324
Ref: api/pq psycopg pq DiagnosticField SEVERITY_NONLOCALIZED487353
Ref: 30c487353
Ref: api/pq psycopg pq DiagnosticField SQLSTATE487395
Ref: 30d487395
Ref: api/pq psycopg pq DiagnosticField MESSAGE_PRIMARY487424
Ref: 30e487424
Ref: api/pq psycopg pq DiagnosticField MESSAGE_DETAIL487460
Ref: 30f487460
Ref: api/pq psycopg pq DiagnosticField MESSAGE_HINT487495
Ref: 310487495
Ref: api/pq psycopg pq DiagnosticField STATEMENT_POSITION487528
Ref: 311487528
Ref: api/pq psycopg pq DiagnosticField INTERNAL_POSITION487567
Ref: 312487567
Ref: api/pq psycopg pq DiagnosticField INTERNAL_QUERY487605
Ref: 313487605
Ref: api/pq psycopg pq DiagnosticField CONTEXT487640
Ref: 314487640
Ref: api/pq psycopg pq DiagnosticField SCHEMA_NAME487668
Ref: 315487668
Ref: api/pq psycopg pq DiagnosticField TABLE_NAME487700
Ref: 316487700
Ref: api/pq psycopg pq DiagnosticField COLUMN_NAME487731
Ref: 317487731
Ref: api/pq psycopg pq DiagnosticField DATATYPE_NAME487763
Ref: 318487763
Ref: api/pq psycopg pq DiagnosticField CONSTRAINT_NAME487797
Ref: 319487797
Ref: api/pq psycopg pq DiagnosticField SOURCE_FILE487833
Ref: 31a487833
Ref: api/pq psycopg pq DiagnosticField SOURCE_LINE487865
Ref: 31b487865
Ref: api/pq psycopg pq DiagnosticField SOURCE_FUNCTION487897
Ref: 31c487897
Ref: api/pq psycopg pq Ping488032
Ref: 31d488032
Ref: api/pq psycopg pq Ping OK488198
Ref: 31e488198
Ref: api/pq psycopg pq Ping REJECT488226
Ref: 31f488226
Ref: api/pq psycopg pq Ping NO_RESPONSE488258
Ref: 320488258
Ref: api/pq psycopg pq Ping NO_ATTEMPT488295
Ref: 321488295
Ref: api/pq psycopg pq Trace488331
Ref: 322488331
Ref: api/pq psycopg pq Trace SUPPRESS_TIMESTAMPS488531
Ref: 323488531
Ref: api/pq psycopg pq Trace REGRESS_MODE488576
Ref: 324488576
Ref: Enumerations-Footnote-1488650
Ref: Enumerations-Footnote-2488727
Ref: Enumerations-Footnote-3488810
Ref: Enumerations-Footnote-4488900
Ref: Enumerations-Footnote-5488988
Ref: Enumerations-Footnote-6489069
Ref: Enumerations-Footnote-7489161
Ref: Enumerations-Footnote-8489246
Ref: Enumerations-Footnote-9489328
Node: crdb – CockroachDB support489413
Ref: api/crdb doc489570
Ref: 325489570
Ref: api/crdb crdb-cockroachdb-support489570
Ref: 326489570
Ref: api/crdb module-psycopg crdb489570
Ref: 5489570
Ref: crdb – CockroachDB support-Footnote-1490265
Node: Main differences from PostgreSQL490304
Ref: api/crdb crdb-differences490439
Ref: 328490439
Ref: api/crdb main-differences-from-postgresql490439
Ref: 329490439
Ref: Main differences from PostgreSQL-Footnote-1491701
Ref: Main differences from PostgreSQL-Footnote-2491782
Ref: Main differences from PostgreSQL-Footnote-3491850
Ref: Main differences from PostgreSQL-Footnote-4491915
Ref: Main differences from PostgreSQL-Footnote-5491985
Node: CockroachDB-specific objects492055
Ref: api/crdb cockroachdb-specific-objects492190
Ref: 32b492190
Ref: api/crdb crdb-objects492190
Ref: 32c492190
Ref: api/crdb psycopg crdb connect492267
Ref: 327492267
Ref: api/crdb psycopg crdb CrdbConnection492861
Ref: 32d492861
Ref: api/crdb psycopg crdb CrdbConnection is_crdb493085
Ref: 32e493085
Ref: api/crdb psycopg crdb AsyncCrdbConnection493448
Ref: 32f493448
Ref: api/crdb psycopg crdb CrdbConnectionInfo493694
Ref: 330493694
Ref: api/crdb psycopg crdb CrdbConnectionInfo vendor494067
Ref: 331494067
Ref: api/crdb psycopg crdb CrdbConnectionInfo server_version494136
Ref: 332494136
Ref: api/crdb psycopg crdb adapters494321
Ref: 32a494321
Node: _dns – DNS resolution utilities495244
Ref: api/dns doc495365
Ref: 333495365
Ref: api/dns dns-dns-resolution-utilities495365
Ref: 334495365
Ref: api/dns module-psycopg _dns495365
Ref: 1495365
Ref: api/dns psycopg _dns resolve_srv496027
Ref: 335496027
Ref: api/dns psycopg _dns resolve_srv_async497721
Ref: 337497721
Ref: api/dns psycopg Connection _get_connection_params497834
Ref: 336497834
Ref: api/dns psycopg AsyncConnection _get_connection_params498542
Ref: 338498542
Ref: api/dns psycopg _dns resolve_hostaddr_async498794
Ref: 108498794
Ref: _dns – DNS resolution utilities-Footnote-1500869
Ref: _dns – DNS resolution utilities-Footnote-2500911
Ref: _dns – DNS resolution utilities-Footnote-3500970
Node: Release notes501058
Ref: index release-notes501171
Ref: 339501171
Node: psycopg release notes501275
Ref: news doc501382
Ref: 33a501382
Ref: news psycopg-release-notes501382
Ref: 33b501382
Node: Current release501561
Ref: news current-release501655
Ref: 33c501655
Node: Psycopg 3 2 12502104
Ref: news psycopg-3-2-12502194
Ref: 33d502194
Ref: Psycopg 3 2 12-Footnote-1502434
Node: Psycopg 3 2 11502489
Ref: news psycopg-3-2-11502602
Ref: 33e502602
Ref: Psycopg 3 2 11-Footnote-1503289
Ref: Psycopg 3 2 11-Footnote-2503344
Ref: Psycopg 3 2 11-Footnote-3503398
Ref: Psycopg 3 2 11-Footnote-4503453
Ref: Psycopg 3 2 11-Footnote-5503508
Ref: Psycopg 3 2 11-Footnote-6503563
Node: Psycopg 3 2 10503618
Ref: news id1503730
Ref: 33f503730
Ref: news psycopg-3-2-10503730
Ref: 11e503730
Ref: Psycopg 3 2 10-Footnote-1505643
Ref: Psycopg 3 2 10-Footnote-2505733
Ref: Psycopg 3 2 10-Footnote-3505788
Ref: Psycopg 3 2 10-Footnote-4505843
Ref: Psycopg 3 2 10-Footnote-5505898
Ref: Psycopg 3 2 10-Footnote-6505953
Ref: Psycopg 3 2 10-Footnote-7506008
Node: Psycopg 3 2 9506063
Ref: news psycopg-3-2-9506174
Ref: 341506174
Ref: Psycopg 3 2 9-Footnote-1506391
Node: Psycopg 3 2 8506446
Ref: news psycopg-3-2-8506556
Ref: 342506556
Ref: Psycopg 3 2 8-Footnote-1507718
Ref: Psycopg 3 2 8-Footnote-2507773
Ref: Psycopg 3 2 8-Footnote-3507828
Ref: Psycopg 3 2 8-Footnote-4507883
Ref: Psycopg 3 2 8-Footnote-5507938
Ref: Psycopg 3 2 8-Footnote-6508000
Ref: Psycopg 3 2 8-Footnote-7508055
Ref: Psycopg 3 2 8-Footnote-8508110
Ref: Psycopg 3 2 8-Footnote-9508165
Ref: Psycopg 3 2 8-Footnote-10508220
Node: Psycopg 3 2 7508276
Ref: news psycopg-3-2-7508386
Ref: 343508386
Ref: Psycopg 3 2 7-Footnote-1508591
Ref: Psycopg 3 2 7-Footnote-2508646
Node: Psycopg 3 2 6508701
Ref: news psycopg-3-2-6508811
Ref: 344508811
Ref: Psycopg 3 2 6-Footnote-1508999
Node: Psycopg 3 2 5509054
Ref: news psycopg-3-2-5509164
Ref: 345509164
Ref: Psycopg 3 2 5-Footnote-1509334
Ref: Psycopg 3 2 5-Footnote-2509388
Node: Psycopg 3 2 4509442
Ref: news id2509552
Ref: 340509552
Ref: news psycopg-3-2-4509552
Ref: 11d509552
Ref: Psycopg 3 2 4-Footnote-1510676
Ref: Psycopg 3 2 4-Footnote-2510730
Ref: Psycopg 3 2 4-Footnote-3510784
Ref: Psycopg 3 2 4-Footnote-4510838
Ref: Psycopg 3 2 4-Footnote-5510892
Ref: Psycopg 3 2 4-Footnote-6510934
Node: Psycopg 3 2 3510988
Ref: news id3511098
Ref: 346511098
Ref: news psycopg-3-2-3511098
Ref: 347511098
Ref: Psycopg 3 2 3-Footnote-1511264
Node: Psycopg 3 2 2511318
Ref: news psycopg-3-2-2511428
Ref: 348511428
Ref: Psycopg 3 2 2-Footnote-1511730
Node: Psycopg 3 2 1511784
Ref: news psycopg-3-2-1511872
Ref: 349511872
Ref: Psycopg 3 2 1-Footnote-1512055
Node: Psycopg 3 2512109
Ref: news psycopg-3-2512223
Ref: 34a512223
Ref: Psycopg 3 2-Footnote-1515435
Ref: Psycopg 3 2-Footnote-2515525
Ref: Psycopg 3 2-Footnote-3515579
Ref: Psycopg 3 2-Footnote-4515633
Ref: Psycopg 3 2-Footnote-5515687
Ref: Psycopg 3 2-Footnote-6515741
Ref: Psycopg 3 2-Footnote-7515795
Ref: Psycopg 3 2-Footnote-8515849
Ref: Psycopg 3 2-Footnote-9515903
Ref: Psycopg 3 2-Footnote-10515957
Ref: Psycopg 3 2-Footnote-11516012
Ref: Psycopg 3 2-Footnote-12516067
Ref: Psycopg 3 2-Footnote-13516122
Ref: Psycopg 3 2-Footnote-14516177
Ref: Psycopg 3 2-Footnote-15516232
Ref: Psycopg 3 2-Footnote-16516287
Ref: Psycopg 3 2-Footnote-17516342
Node: Psycopg 3 1 20516397
Ref: news id4516483
Ref: 34b516483
Ref: news psycopg-3-1-20516483
Ref: 34c516483
Ref: Psycopg 3 1 20-Footnote-1517083
Ref: Psycopg 3 1 20-Footnote-2517137
Ref: Psycopg 3 1 20-Footnote-3517191
Ref: Psycopg 3 1 20-Footnote-4517245
Node: Psycopg 3 1 19517299
Ref: news psycopg-3-1-19517408
Ref: 34d517408
Ref: Psycopg 3 1 19-Footnote-1517812
Ref: Psycopg 3 1 19-Footnote-2517866
Ref: Psycopg 3 1 19-Footnote-3517920
Ref: Psycopg 3 1 19-Footnote-4517974
Node: Psycopg 3 1 18518028
Ref: news psycopg-3-1-18518137
Ref: 34e518137
Ref: Psycopg 3 1 18-Footnote-1518470
Ref: Psycopg 3 1 18-Footnote-2518524
Ref: Psycopg 3 1 18-Footnote-3518578
Ref: Psycopg 3 1 18-Footnote-4518633
Node: Psycopg 3 1 17518687
Ref: news id5518796
Ref: 34f518796
Ref: news psycopg-3-1-17518796
Ref: 350518796
Ref: Psycopg 3 1 17-Footnote-1519145
Ref: Psycopg 3 1 17-Footnote-2519199
Ref: Psycopg 3 1 17-Footnote-3519265
Node: Psycopg 3 1 16519319
Ref: news psycopg-3-1-16519428
Ref: 351519428
Ref: Psycopg 3 1 16-Footnote-1519605
Node: Psycopg 3 1 15519659
Ref: news psycopg-3-1-15519768
Ref: 352519768
Ref: Psycopg 3 1 15-Footnote-1520171
Ref: Psycopg 3 1 15-Footnote-2520225
Node: Psycopg 3 1 14520279
Ref: news psycopg-3-1-14520388
Ref: 353520388
Ref: Psycopg 3 1 14-Footnote-1520582
Ref: Psycopg 3 1 14-Footnote-2520636
Node: Psycopg 3 1 13520690
Ref: news gevent520799
Ref: 354520799
Ref: news psycopg-3-1-13520799
Ref: 355520799
Ref: Psycopg 3 1 13-Footnote-1521476
Ref: Psycopg 3 1 13-Footnote-2521546
Ref: Psycopg 3 1 13-Footnote-3521620
Ref: Psycopg 3 1 13-Footnote-4521674
Ref: Psycopg 3 1 13-Footnote-5521750
Ref: Psycopg 3 1 13-Footnote-6521792
Ref: Psycopg 3 1 13-Footnote-7521846
Ref: Psycopg 3 1 13-Footnote-8521900
Node: Psycopg 3 1 12521954
Ref: news psycopg-3-1-12522063
Ref: 356522063
Ref: Psycopg 3 1 12-Footnote-1522383
Ref: Psycopg 3 1 12-Footnote-2522437
Node: Psycopg 3 1 11522491
Ref: news psycopg-3-1-11522600
Ref: 357522600
Ref: Psycopg 3 1 11-Footnote-1523415
Ref: Psycopg 3 1 11-Footnote-2523469
Ref: Psycopg 3 1 11-Footnote-3523523
Ref: Psycopg 3 1 11-Footnote-4523577
Ref: Psycopg 3 1 11-Footnote-5523631
Ref: Psycopg 3 1 11-Footnote-6523685
Node: Psycopg 3 1 10523739
Ref: news psycopg-3-1-10523847
Ref: 358523847
Ref: Psycopg 3 1 10-Footnote-1525009
Ref: Psycopg 3 1 10-Footnote-2525071
Ref: Psycopg 3 1 10-Footnote-3525131
Ref: Psycopg 3 1 10-Footnote-4525185
Ref: Psycopg 3 1 10-Footnote-5525239
Ref: Psycopg 3 1 10-Footnote-6525293
Ref: Psycopg 3 1 10-Footnote-7525347
Ref: Psycopg 3 1 10-Footnote-8525401
Node: Psycopg 3 1 9525455
Ref: news psycopg-3-1-9525562
Ref: 359525562
Ref: Psycopg 3 1 9-Footnote-1526286
Ref: Psycopg 3 1 9-Footnote-2526340
Ref: Psycopg 3 1 9-Footnote-3526394
Ref: Psycopg 3 1 9-Footnote-4526448
Ref: Psycopg 3 1 9-Footnote-5526502
Ref: Psycopg 3 1 9-Footnote-6526556
Node: Psycopg 3 1 8526610
Ref: news psycopg-3-1-8526716
Ref: 35a526716
Ref: Psycopg 3 1 8-Footnote-1527188
Ref: Psycopg 3 1 8-Footnote-2527242
Ref: Psycopg 3 1 8-Footnote-3527296
Node: Psycopg 3 1 7527350
Ref: news psycopg-3-1-7527456
Ref: 35b527456
Ref: Psycopg 3 1 7-Footnote-1527607
Node: Psycopg 3 1 6527661
Ref: news psycopg-3-1-6527767
Ref: 35c527767
Ref: Psycopg 3 1 6-Footnote-1527936
Node: Psycopg 3 1 5527990
Ref: news psycopg-3-1-5528096
Ref: 35d528096
Ref: Psycopg 3 1 5-Footnote-1528823
Ref: Psycopg 3 1 5-Footnote-2528877
Ref: Psycopg 3 1 5-Footnote-3528931
Ref: Psycopg 3 1 5-Footnote-4528985
Ref: Psycopg 3 1 5-Footnote-5529039
Ref: Psycopg 3 1 5-Footnote-6529093
Ref: Psycopg 3 1 5-Footnote-7529147
Node: Psycopg 3 1 4529201
Ref: news psycopg-3-1-4529307
Ref: 35e529307
Ref: Psycopg 3 1 4-Footnote-1529569
Node: Psycopg 3 1 3529623
Ref: news psycopg-3-1-3529729
Ref: 35f529729
Ref: Psycopg 3 1 3-Footnote-1530282
Ref: Psycopg 3 1 3-Footnote-2530336
Ref: Psycopg 3 1 3-Footnote-3530390
Ref: Psycopg 3 1 3-Footnote-4530444
Node: Psycopg 3 1 2530498
Ref: news psycopg-3-1-2530604
Ref: 360530604
Ref: Psycopg 3 1 2-Footnote-1531208
Ref: Psycopg 3 1 2-Footnote-2531262
Ref: Psycopg 3 1 2-Footnote-3531316
Ref: Psycopg 3 1 2-Footnote-4531370
Ref: Psycopg 3 1 2-Footnote-5531424
Node: Psycopg 3 1 1531478
Ref: news psycopg-3-1-1531562
Ref: 361531562
Ref: Psycopg 3 1 1-Footnote-1531871
Ref: Psycopg 3 1 1-Footnote-2531925
Node: Psycopg 3 1531979
Ref: news psycopg-3-1532089
Ref: 362532089
Ref: Psycopg 3 1-Footnote-1534053
Ref: Psycopg 3 1-Footnote-2534106
Ref: Psycopg 3 1-Footnote-3534160
Ref: Psycopg 3 1-Footnote-4534199
Ref: Psycopg 3 1-Footnote-5534253
Ref: Psycopg 3 1-Footnote-6534306
Ref: Psycopg 3 1-Footnote-7534360
Ref: Psycopg 3 1-Footnote-8534414
Ref: Psycopg 3 1-Footnote-9534468
Ref: Psycopg 3 1-Footnote-10534522
Ref: Psycopg 3 1-Footnote-11534577
Ref: Psycopg 3 1-Footnote-12534632
Ref: Psycopg 3 1-Footnote-13534687
Ref: Psycopg 3 1-Footnote-14534764
Ref: Psycopg 3 1-Footnote-15534807
Ref: Psycopg 3 1-Footnote-16534862
Node: Psycopg 3 0 17534917
Ref: news psycopg-3-0-17535003
Ref: 363535003
Ref: Psycopg 3 0 17-Footnote-1535272
Ref: Psycopg 3 0 17-Footnote-2535340
Ref: Psycopg 3 0 17-Footnote-3535394
Node: Psycopg 3 0 16535462
Ref: news psycopg-3-0-16535571
Ref: 364535571
Ref: Psycopg 3 0 16-Footnote-1535790
Ref: Psycopg 3 0 16-Footnote-2535844
Node: Psycopg 3 0 15535898
Ref: news psycopg-3-0-15536007
Ref: 365536007
Ref: Psycopg 3 0 15-Footnote-1536466
Ref: Psycopg 3 0 15-Footnote-2536538
Node: Psycopg 3 0 14536592
Ref: news psycopg-3-0-14536701
Ref: 366536701
Ref: Psycopg 3 0 14-Footnote-1537034
Ref: Psycopg 3 0 14-Footnote-2537088
Ref: Psycopg 3 0 14-Footnote-3537142
Node: Psycopg 3 0 13537196
Ref: news psycopg-3-0-13537305
Ref: 367537305
Ref: Psycopg 3 0 13-Footnote-1537663
Ref: Psycopg 3 0 13-Footnote-2537717
Node: Psycopg 3 0 12537771
Ref: news psycopg-3-0-12537880
Ref: 368537880
Ref: Psycopg 3 0 12-Footnote-1538135
Ref: Psycopg 3 0 12-Footnote-2538201
Ref: Psycopg 3 0 12-Footnote-3538268
Ref: Psycopg 3 0 12-Footnote-4538322
Node: Psycopg 3 0 11538387
Ref: news psycopg-3-0-11538496
Ref: 369538496
Ref: Psycopg 3 0 11-Footnote-1538838
Ref: Psycopg 3 0 11-Footnote-2538892
Ref: Psycopg 3 0 11-Footnote-3538946
Node: Psycopg 3 0 10539000
Ref: news psycopg-3-0-10539108
Ref: 36a539108
Ref: Psycopg 3 0 10-Footnote-1539483
Ref: Psycopg 3 0 10-Footnote-2539537
Ref: Psycopg 3 0 10-Footnote-3539591
Node: Psycopg 3 0 9539645
Ref: news psycopg-3-0-9539752
Ref: 36b539752
Ref: Psycopg 3 0 9-Footnote-1540043
Ref: Psycopg 3 0 9-Footnote-2540097
Node: Psycopg 3 0 8540151
Ref: news psycopg-3-0-8540257
Ref: 36c540257
Ref: Psycopg 3 0 8-Footnote-1540681
Ref: Psycopg 3 0 8-Footnote-2540735
Ref: Psycopg 3 0 8-Footnote-3540789
Node: Psycopg 3 0 7540843
Ref: news psycopg-3-0-7540949
Ref: 36d540949
Ref: Psycopg 3 0 7-Footnote-1541234
Ref: Psycopg 3 0 7-Footnote-2541288
Node: Psycopg 3 0 6541342
Ref: news psycopg-3-0-6541448
Ref: 36e541448
Ref: Psycopg 3 0 6-Footnote-1542047
Ref: Psycopg 3 0 6-Footnote-2542101
Ref: Psycopg 3 0 6-Footnote-3542155
Ref: Psycopg 3 0 6-Footnote-4542209
Ref: Psycopg 3 0 6-Footnote-5542263
Node: Psycopg 3 0 5542317
Ref: news psycopg-3-0-5542423
Ref: 36f542423
Ref: Psycopg 3 0 5-Footnote-1542752
Ref: Psycopg 3 0 5-Footnote-2542806
Node: Psycopg 3 0 4542860
Ref: news psycopg-3-0-4542966
Ref: 370542966
Ref: Psycopg 3 0 4-Footnote-1543425
Ref: Psycopg 3 0 4-Footnote-2543479
Ref: Psycopg 3 0 4-Footnote-3543533
Ref: Psycopg 3 0 4-Footnote-4543601
Node: Psycopg 3 0 3543655
Ref: news psycopg-3-0-3543761
Ref: 371543761
Ref: Psycopg 3 0 3-Footnote-1544093
Ref: Psycopg 3 0 3-Footnote-2544147
Node: Psycopg 3 0 2544201
Ref: news psycopg-3-0-2544307
Ref: 372544307
Ref: Psycopg 3 0 2-Footnote-1544744
Ref: Psycopg 3 0 2-Footnote-2544798
Ref: Psycopg 3 0 2-Footnote-3544852
Ref: Psycopg 3 0 2-Footnote-4544920
Ref: Psycopg 3 0 2-Footnote-5544974
Node: Psycopg 3 0 1545028
Ref: news psycopg-3-0-1545112
Ref: 373545112
Ref: Psycopg 3 0 1-Footnote-1545318
Node: Psycopg 3 0545372
Ref: news psycopg-3-0545462
Ref: 374545462
Ref: Psycopg 3 0-Footnote-1546241
Ref: Psycopg 3 0-Footnote-2546294
Ref: Psycopg 3 0-Footnote-3546347
Ref: Psycopg 3 0-Footnote-4546400
Ref: Psycopg 3 0-Footnote-5546453
Ref: Psycopg 3 0-Footnote-6546506
Node: Psycopg 3 0b1546560
Ref: news psycopg-3-0b1546622
Ref: 375546622
Node: psycopg_pool release notes546705
Ref: news_pool doc546812
Ref: 376546812
Ref: news_pool psycopg-pool-release-notes546812
Ref: 377546812
Node: Future releases547078
Ref: news_pool future-releases547184
Ref: 378547184
Node: psycopg_pool 3 2 7 unreleased547309
Ref: news_pool psycopg-pool-3-2-7-unreleased547391
Ref: 379547391
Ref: psycopg_pool 3 2 7 unreleased-Footnote-1547711
Ref: psycopg_pool 3 2 7 unreleased-Footnote-2547766
Node: Current release<2>547821
Ref: news_pool current-release547954
Ref: 37a547954
Node: psycopg_pool 3 2 6548265
Ref: news_pool psycopg-pool-3-2-6548366
Ref: 37b548366
Ref: psycopg_pool 3 2 6-Footnote-1548540
Node: psycopg_pool 3 2 5548595
Ref: news_pool psycopg-pool-3-2-5548723
Ref: 37c548723
Ref: psycopg_pool 3 2 5-Footnote-1548886
Node: psycopg_pool 3 2 4548941
Ref: news_pool psycopg-pool-3-2-4549069
Ref: 37d549069
Ref: psycopg_pool 3 2 4-Footnote-1549355
Node: psycopg_pool 3 2 3549409
Ref: news_pool psycopg-pool-3-2-3549537
Ref: 37e549537
Node: psycopg_pool 3 2 2549654
Ref: news_pool psycopg-pool-3-2-2549782
Ref: 37f549782
Ref: psycopg_pool 3 2 2-Footnote-1550170
Ref: psycopg_pool 3 2 2-Footnote-2550243
Ref: psycopg_pool 3 2 2-Footnote-3550321
Ref: psycopg_pool 3 2 2-Footnote-4550375
Node: psycopg_pool 3 2 1550429
Ref: news_pool psycopg-pool-3-2-1550530
Ref: 380550530
Ref: psycopg_pool 3 2 1-Footnote-1550984
Ref: psycopg_pool 3 2 1-Footnote-2551038
Ref: psycopg_pool 3 2 1-Footnote-3551104
Node: psycopg_pool 3 2 0551158
Ref: news_pool psycopg-pool-3-2-0551294
Ref: 381551294
Ref: psycopg_pool 3 2 0-Footnote-1552420
Ref: psycopg_pool 3 2 0-Footnote-2552474
Ref: psycopg_pool 3 2 0-Footnote-3552528
Ref: psycopg_pool 3 2 0-Footnote-4552582
Ref: psycopg_pool 3 2 0-Footnote-5552636
Node: psycopg_pool 3 1 9552690
Ref: news_pool psycopg-pool-3-1-9552791
Ref: 382552791
Ref: psycopg_pool 3 1 9-Footnote-1552984
Node: psycopg_pool 3 1 8553038
Ref: news_pool psycopg-pool-3-1-8553166
Ref: 383553166
Ref: psycopg_pool 3 1 8-Footnote-1553353
Node: psycopg_pool 3 1 7553407
Ref: news_pool psycopg-pool-3-1-7553535
Ref: 384553535
Ref: psycopg_pool 3 1 7-Footnote-1553723
Node: psycopg_pool 3 1 6553777
Ref: news_pool psycopg-pool-3-1-6553905
Ref: 385553905
Ref: psycopg_pool 3 1 6-Footnote-1554105
Node: psycopg_pool 3 1 5554159
Ref: news_pool psycopg-pool-3-1-5554287
Ref: 386554287
Ref: psycopg_pool 3 1 5-Footnote-1554562
Ref: psycopg_pool 3 1 5-Footnote-2554616
Node: psycopg_pool 3 1 4554670
Ref: news_pool psycopg-pool-3-1-4554798
Ref: 387554798
Ref: psycopg_pool 3 1 4-Footnote-1555025
Node: psycopg_pool 3 1 3555079
Ref: news_pool psycopg-pool-3-1-3555207
Ref: 388555207
Ref: psycopg_pool 3 1 3-Footnote-1555352
Node: psycopg_pool 3 1 2555406
Ref: news_pool psycopg-pool-3-1-2555534
Ref: 389555534
Ref: psycopg_pool 3 1 2-Footnote-1555730
Node: psycopg_pool 3 1 1555784
Ref: news_pool psycopg-pool-3-1-1555885
Ref: 38a555885
Ref: psycopg_pool 3 1 1-Footnote-1556086
Node: psycopg_pool 3 1 0556140
Ref: news_pool psycopg-pool-3-1-0556274
Ref: 38b556274
Ref: psycopg_pool 3 1 0-Footnote-1556716
Ref: psycopg_pool 3 1 0-Footnote-2556770
Node: psycopg_pool 3 0 3556824
Ref: news_pool psycopg-pool-3-0-3556925
Ref: 38c556925
Node: psycopg_pool 3 0 2557205
Ref: news_pool psycopg-pool-3-0-2557333
Ref: 38d557333
Node: psycopg_pool 3 0 1557460
Ref: news_pool psycopg-pool-3-0-1557561
Ref: 38e557561
Ref: psycopg_pool 3 0 1-Footnote-1557763
Node: psycopg_pool 3 0557817
Ref: news_pool psycopg-pool-3-0557924
Ref: 38f557924
Node: Indices and tables558006
Ref: index indices-and-tables558097
Ref: 390558097
Node: Python Module Index558174
Node: Index558548

End Tag Table


Local Variables:
coding: utf-8
End:
